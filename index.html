<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>텍사스 홀덤 (최종 통합본) - v8.6 Tutorial Flow Refined</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            background-color: #2c3e50;
            margin: 0;
            padding: 10px;
            color: #ecf0f1;
            height: 100vh;
            box-sizing: border-box;
            position: relative;
            overflow-x: hidden;
        }

        .poker-hands-button {
            position: fixed;
            top: 10px;
            left: 10px; /* 기본 위치 */
            padding: 8px 12px;
            background-color: #e67e22;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
        }
        #tutorial-button {
            left: 115px; 
            background-color: #3498db;
        }
        #tutorial-button:hover {
            background-color: #2980b9;
        }

        .poker-hands-guide {
            display: none;
            position: fixed;
            top: 45px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 999;
            width: 450px;
            max-width: 90vw;
            font-size: 0.9em;
        }
        .poker-hands-guide h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        .poker-hands-guide ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .poker-hands-guide li {
            margin-bottom: 5px;
            padding: 8px;
            background-color: rgba(0,0,0,0.03);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100px;
        }

        .current-hand-display {
            font-size: 0.8em;
            color: #f1c40f;
            margin-top: 5px;
            font-weight: bold;
        }

        .game-container {
            display: flex;
            width: 100%;
            height: calc(100vh - 20px);
        }

        .main-game-area {
            flex-grow: 1;
            flex-basis: 68%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding-right: 5px;
            box-sizing: border-box;
        }

        .game-table {
            display: none; 
            background-color: #006400;
            border-radius: 150px;
            padding: 15px;
            border: 5px solid #8B4513;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: auto auto auto;
            align-items: center;
            justify-items: center;
            width: 95%;
            max-width: 900px;
            position: relative;
            gap: 5px;
        }

        .ai-action-effect {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 150px; box-shadow: 0 0 30px 10px gold;
            opacity: 0; transition: opacity 0.3s ease-out;
            pointer-events: none; z-index: 10;
        }
        .ai-action-effect.active { opacity: 0.8; }

        .player-slot {
            border: 1px solid #4a6278;
            border-radius: 10px;
            padding: 5px;
            background-color: rgba(0,0,0,0.2);
            min-width: 150px;
            min-height: 115px;
            text-align: center;
            position: relative;
        }
        .player-slot.acting { box-shadow: 0 0 15px 5px gold; }
        .player-slot.folded { opacity: 0.5; background-color: rgba(100,100,100,0.3); }

        .enhanced-feedback {
            position: absolute;
            top: 50%;
            left: calc(100% + 10px);
            transform: translateY(-50%) scale(0.8);
            font-size: 1.8em;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.7s ease-out, transform 0.7s ease-out, font-size 0.7s ease-out;
            z-index: 100;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: rgba(0,0,0,0.1);
        }
        .enhanced-feedback.show { opacity: 1; transform: translateY(-50%) scale(1.1); font-size: 2.2em; }
        .enhanced-feedback.fade-out { opacity: 0; transform: translateY(-50%) translateX(10px) scale(0.7); font-size: 1.5em; }
        .feedback-raise { color: #e74c3c; border: 2px solid #c0392b; }
        .feedback-call { color: #2ecc71; border: 2px solid #27ae60; }
        .feedback-bet { color: #f39c12; border: 2px solid #e67e22; }
        .feedback-check { color: #3498db; border: 2px solid #2980b9; }
        .feedback-fold { color: #95a5a6; border: 2px solid #7f8c8d; }
        .feedback-win { color: #f1c40f; border: 2px solid #f39c12; font-size: 2.5em !important; }
        .feedback-lose { color: #7f8c8d; border: 2px solid #34495e; font-style: italic; }

        #player-slot-0 { grid-column: 2 / 3; grid-row: 3 / 4; align-self: end; }
        #player-slot-1 { grid-column: 2 / 3; grid-row: 1 / 2; align-self: start; }
        #player-slot-2 { grid-column: 1 / 2; grid-row: 2 / 3; justify-self: start; }
        #player-slot-3 { grid-column: 3 / 4; grid-row: 2 / 3; justify-self: end; }

        .community-cards-area {
            grid-column: 2 / 3; grid-row: 2 / 3;
            text-align: center; width: 100%;
        }
        .community-cards-area h2 { margin-top:0; margin-bottom: 5px; font-size: 1.3em;}

        .cards-container { display: flex; justify-content: center; gap: 5px; margin-top: 5px; perspective: 1000px; }
        .card {
            width: 50px; height: 75px; border: 1px solid #000; border-radius: 4px;
            font-size: 14px; font-weight: bold; background-color: white;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3); position: relative;
            transform-style: preserve-3d; transition: transform 0.6s, opacity 0.3s;
            opacity: 0;
        }
        .card.hidden .card-front { transform: rotateY(180deg); }
        .card.hidden .card-back { transform: rotateY(0deg); }
        .card.is-dealt { opacity: 1; }
        .card.is-flipping .card-front { transform: rotateY(0deg); }
        .card.is-flipping .card-back { transform: rotateY(-180deg); }

        .card-face {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            display: flex; flex-direction: column; justify-content: space-around;
            align-items: center; border-radius: 4px;
        }
        .card-front { background-color: white; transform: rotateY(0deg); }
        .card-back {
            background-color: #6c757d;
            background-image: repeating-linear-gradient(45deg, #5a6268, #5a6268 6px, #6c757d 6px, #6c757d 12px);
            transform: rotateY(180deg);
        }
        .card .rank { font-size: 18px; } .card .suit { font-size: 16px; }
        .suit-♠, .suit-♣ { color: black; } .suit-♥, .suit-♦ { color: red; }

        .chips-display, .dealer-chip-ui, .blind-chip-ui {
            background-color: #f5f5dc; padding: 5px 10px; border-radius: 15px;
            font-size: 13px; border: 1px solid #d2b48c; margin-top: 3px;
            display: inline-block; color: #333;
        }
        .dealer-chip-ui { background-color: #FFD700; color: black; font-weight: bold; padding: 3px 6px; font-size: 9px; margin-left: 5px; }
        .blind-chip-ui { background-color: #7f8c8d; color: white; font-weight: bold; padding: 3px 6px; font-size: 9px; margin-left: 3px;}

        .player-name-display { font-weight: bold; color: white; margin-bottom: 3px; }

        .actions-area {
            display: none; 
            grid-column: 1 / 4; grid-row: 4 / 5; margin: 10px 0;
            gap: 8px; flex-wrap: wrap; justify-content: center;
        }
        .actions-area button, .game-controls button {
            padding: 8px 12px; font-size: 14px; cursor: pointer;
            background-color: #4CAF50; color: white; border: none;
            border-radius: 5px; transition: background-color 0.3s;
        }
        .actions-area button:hover, .game-controls button:hover { background-color: #45a049; }
        .actions-area button:disabled, .game-controls button:disabled { background-color: #7f8c8d; cursor: not-allowed; opacity: 0.7; }
        #raise-input { padding: 8px; font-size: 14px; width: 80px; border-radius: 5px; border: 1px solid #ccc; }

        .bet-amount-display {
            background-color: rgba(0,0,0,0.7); color: white; padding: 2px 6px;
            border-radius: 5px; font-size: 11px; margin-top: 3px; display: inline-block;
        }

        .right-panel {
            flex-basis: 32%;
            min-width: 280px;
            height: calc(100vh - 20px);
            margin-left: 5px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .chat-area {
            flex-grow: 1;
            background-color: #34495e; padding: 10px;
            border-radius: 8px; box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; box-sizing: border-box;
            min-height: 200px;
        }
        .chat-area h3 { margin-top: 0; color: #ecf0f1; text-align: center; border-bottom: 1px solid #7f8c8d; padding-bottom: 5px; }
        .message-log { flex-grow: 1; overflow-y: auto; font-size: 0.9em; line-height: 1.4; }
        .message-log p { margin: 5px 0; padding: 3px; border-bottom: 1px dashed #4a6278; }
        .message-log p:last-child { border-bottom: none; }
        .message-log .player-action { color: #2ecc71; } .message-log .ai-action { color: #e74c3c; }
        .message-log .game-event { color: #f1c40f; } .message-log .system-message { color: #bdc3c7; }
        .admin-message { color: #e67e22; font-weight: bold;}
        .tutorial-message { color: #3498db; font-style: italic; font-weight: bold; border-left: 3px solid #2980b9; padding-left: 5px;}

        .game-info-bottom-right {
            padding: 10px;
            background-color: #1e2b37;
            border-radius: 8px;
            margin-top: 10px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            text-align: center;
        }
        .game-info-bottom-right div {
            font-size: 1.1em;
            font-weight: bold;
            color: #ecf0f1;
            padding: 6px 0;
            border-bottom: 1px solid #34495e;
        }
        .game-info-bottom-right div:last-child { border-bottom: none; }
        #pot-display-bottom-right { color: #f1c40f; }
        #sb-bb-display-area { color: #bdc3c7; }

        .game-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 10px; padding: 10px; }
        .player-setup, .game-settings-inputs { display: flex; gap: 10px; align-items: center; margin-bottom:10px; flex-wrap: wrap; justify-content: center;}
        .game-settings-inputs label { font-size: 0.9em; }
        .game-settings-inputs input[type="number"] {
            width: 70px; padding: 6px; border-radius: 4px; border: 1px solid #7f8c8d;
            background-color: #ecf0f1; color: #2c3e50;
        }
        #ai-delay-input { width: 50px; }

        .end-game-buttons { display: flex; gap: 10px; }
        .end-game-buttons button#continue-game-button { background-color: #3498db; }
        .end-game-buttons button#start-game-button-main { background-color: #27ae60; }

        .poker-hands-guide .hand-example-cards {
            display: flex; justify-content: center; gap: 2px;
            margin-top: 5px; padding: 3px;
            background-color: rgba(0, 80, 0, 0.1); border-radius: 3px;
        }
        .poker-hands-guide .card {
            width: 30px; height: 45px; font-size: 8px;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.2); border-radius: 3px;
            opacity: 1 !important; position: relative;
            transform-style: flat; background-color: white;
        }
        .poker-hands-guide .card .card-face { display: flex; flex-direction: column; justify-content: space-around; align-items: center; width: 100%; height: 100%; }
        .poker-hands-guide .card .card-front { transform: rotateY(0deg) !important; backface-visibility: hidden; }
        .poker-hands-guide .card .card-back { display: none !important; }
        .poker-hands-guide .card .rank { font-size: 12px; font-weight: bold; line-height: 1; }
        .poker-hands-guide .card .suit { font-size: 10px; line-height: 1; }

        #tutorial-overlay {
            display: none; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            z-index: 1001; 
            justify-content: center;
            align-items: center;
            padding: 15px;
            box-sizing: border-box;
        }
        #tutorial-message-box {
            background-color: #e0e0e0; 
            color: #1a1a1a; 
            padding: 25px;
            border-radius: 12px;
            max-width: 600px; 
            width: 90%;
            text-align: left; 
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            border: 2px solid #3498db; 
            line-height: 1.6;
        }
        #tutorial-message-box h3 {
            margin-top: 0;
            color: #2980b9; 
            border-bottom: 1px solid #bdc3c7;
            padding-bottom: 10px;
            font-size: 1.4em;
        }
        #tutorial-message-box p {
            font-size: 1.05em; 
            margin-bottom: 15px;
        }
        #tutorial-message-box button {
            padding: 10px 18px;
            margin: 10px 5px 0;
            font-size: 0.95em;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #tutorial-message-box button:hover {
            background-color: #2980b9;
        }
        #tutorial-next-button { background-color: #27ae60; }
        #tutorial-next-button:hover { background-color: #229954; }

        .tutorial-highlight {
            box-shadow: 0 0 12px 4px gold !important;
            border: 2px solid gold !important;
            transition: box-shadow 0.3s ease-in-out, border 0.3s ease-in-out;
            border-radius: 5px; 
        }

        @media (max-width: 768px) {
            body { height: auto; padding: 5px; }
            .game-container { flex-direction: column; height: auto; }
            .main-game-area { flex-basis: auto; width: 100%; order: 1; padding-right: 0; }
            .right-panel { flex-basis: auto; width: 100%; margin-left: 0; margin-top: 15px; height: 250px; order: 2; }
            .game-table { border-radius: 50px; padding: 10px; gap: 3px; }
            .player-slot { min-width: 100px; min-height: 90px; padding: 3px; }
            .card { width: 40px; height: 60px; font-size: 12px; }
            .card .rank { font-size: 14px; } .card .suit { font-size: 12px; }
            .actions-area { margin: 5px 0; gap: 5px; }
            .actions-area button { padding: 8px 6px; font-size: 12px; }
            #raise-input { padding: 8px; width: 50px; font-size: 12px; }
            .poker-hands-button { font-size: 0.8em; padding: 6px 8px; }
            #tutorial-button { left: 90px; } 

            .poker-hands-guide {
                width: 90vw; left: 5vw; top: 50px; font-size: 0.85em;
                max-height: 80vh; overflow-y: auto; padding: 10px;
            }
            .poker-hands-guide ul { grid-template-columns: 1fr; gap: 8px; }
            .poker-hands-guide li { padding: 6px; min-height: auto; }
            .poker-hands-guide li b { font-size: 0.95em; }
            .poker-hands-guide .hand-example-cards { margin-top: 4px; gap: 1px; }
            .poker-hands-guide .card { width: 24px; height: 36px; }
            .poker-hands-guide .card .rank { font-size: 10px; }
            .poker-hands-guide .card .suit { font-size: 8px; }
            .enhanced-feedback { font-size: 1.3em !important; left: calc(100% + 5px); }
            .enhanced-feedback.show { font-size: 1.6em !important; }
            .enhanced-feedback.fade-out { font-size: 1.1em !important; transform: translateY(-50%) translateX(5px) scale(0.7); }
            .feedback-win { font-size: 2em !important; }

            #tutorial-message-box { max-width: 90%; padding: 15px; }
            #tutorial-message-box h3 { font-size: 1.2em; }
            #tutorial-message-box p { font-size: 0.95em; }
        }
        @media (max-width: 480px) {
            .player-slot { min-width: 80px; min-height: 80px; }
            .chips-display { font-size: 11px; padding: 3px 6px;}
            .dealer-chip-ui, .blind-chip-ui { font-size: 8px; padding: 2px 4px;}
            .current-hand-display { font-size: 0.7em; }
            .community-cards-area h2 { font-size: 1.2em; }
            #tutorial-button { left: 80px; font-size: 0.75em; padding: 5px 7px;}
            .poker-hands-guide { font-size: 0.8em; }
            .poker-hands-guide li b { font-size: 0.9em; }
            .poker-hands-guide .card { width: 20px; height: 30px; }
            .poker-hands-guide .card .rank { font-size: 8px; }
            .poker-hands-guide .card .suit { font-size: 7px; }
            #tutorial-message-box h3 { font-size: 1.1em; }
            #tutorial-message-box p { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <button class="poker-hands-button" id="poker-hands-info-btn">포커 족보</button>
    <button class="poker-hands-button" id="tutorial-button">튜토리얼</button>

    <div class="poker-hands-guide" id="poker-hands-guide-div">
        <h4>포커 족보 (높은 순)</h4>
        <ul>
            <li><b>로열 플러쉬</b> (Royal Flush): 같은 무늬 A-K-Q-J-10 <div class="hand-example-cards" data-hand-name="royal-flush"></div></li>
            <li><b>스트레이트 플러쉬</b> (Straight Flush): 같은 무늬 연속 숫자 <div class="hand-example-cards" data-hand-name="straight-flush"></div></li>
            <li><b>포카드</b> (Four of a Kind): 같은 숫자 4장 <div class="hand-example-cards" data-hand-name="four-of-a-kind"></div></li>
            <li><b>풀하우스</b> (Full House): 트리플 + 원 페어 <div class="hand-example-cards" data-hand-name="full-house"></div></li>
            <li><b>플러쉬</b> (Flush): 같은 무늬 5장 <div class="hand-example-cards" data-hand-name="flush"></div></li>
            <li><b>스트레이트</b> (Straight): 연속된 숫자 5장 <div class="hand-example-cards" data-hand-name="straight"></div></li>
            <li><b>트리플</b> (Three of a Kind): 같은 숫자 3장 <div class="hand-example-cards" data-hand-name="three-of-a-kind"></div></li>
            <li><b>투 페어</b> (Two Pair): 페어 2쌍 <div class="hand-example-cards" data-hand-name="two-pair"></div></li>
            <li><b>원 페어</b> (One Pair): 페어 1쌍 <div class="hand-example-cards" data-hand-name="one-pair"></div></li>
            <li><b>하이 카드</b> (High Card): 위 족보에 해당 없을 시 가장 높은 카드 <div class="hand-example-cards" data-hand-name="high-card"></div></li>
        </ul>
    </div>

    <div id="tutorial-overlay">
        <div id="tutorial-message-box">
            <h3 id="tutorial-title">튜토리얼</h3>
            <p id="tutorial-text">튜토리얼 메시지가 여기에 표시됩니다.</p>
            <div id="tutorial-specific-buttons" style="margin-top: 15px; text-align: center;">
                {/* <!-- 여기에 CLICK_TUTORIAL_START_GAME_BUTTON 용 버튼이 동적으로 생성됨 --> */}
            </div>
            <button id="tutorial-next-button" style="display:none;">다음 설명</button>
            <button id="tutorial-skip-step-button" style="display:none; background-color: #f39c12;">지시 건너뛰기 (임시)</button>
            <button id="tutorial-close-button">튜토리얼 종료</button>
        </div>
    </div>

    <div class="game-container">
        <div class="main-game-area">
            <div class="game-table" id="game-table-main">
                <div id="ai-action-effect-indicator" class="ai-action-effect"></div>
                <div id="player-slot-1" class="player-slot" style="display:none;"></div>
                <div id="player-slot-2" class="player-slot" style="display:none;"></div>
                <div id="player-slot-3" class="player-slot" style="display:none;"></div>
                <div class="community-cards-area">
                    <h2>커뮤니티 카드</h2>
                    <div id="community-cards" class="cards-container"></div>
                </div>
                <div id="player-slot-0" class="player-slot"></div>
                <div class="actions-area" id="actions-area-main">
                    <button id="check-call-button">체크</button>
                    <button id="bet-raise-button">벳</button>
                    <input type="number" id="raise-input" value="0" min="0">
                    <button id="fold-button">폴드</button>
                </div>
            </div>
            <div class="game-controls">
                <div class="player-setup">
                    <label for="num-players-select">참가 인원 (AI 포함):</label>
                    <select id="num-players-select">
                        <option value="2" selected>2명</option>
                        <option value="3">3명</option>
                        <option value="4">4명</option>
                    </select>
                </div>
                <div class="game-settings-inputs">
                    <label for="starting-chips-input">시작 칩:</label>
                    <input type="number" id="starting-chips-input" placeholder="1000" min="100">
                    <label for="big-blind-input">BB 금액:</label>
                    <input type="number" id="big-blind-input" placeholder="20" min="2">
                    <label for="ai-delay-input">AI 딜레이(초):</label>
                    <input type="number" id="ai-delay-input" placeholder="0" min="0" value="0">
                </div>
                <div id="control-buttons-area" class="end-game-buttons">
                    <button id="start-game-button-main">새 게임</button>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="chat-area">
                <h3>게임 로그</h3>
                <div id="message-log" class="message-log">
                    <p class="system-message">텍사스 홀덤 게임에 오신 것을 환영합니다!</p>
                    <p class="system-message">참가 인원, 시작 칩, BB 금액, AI 딜레이를 설정하고 '새 게임'을 누르세요.</p>
                </div>
            </div>
            <div class="game-info-bottom-right">
                <div id="pot-display-bottom-right">팟: 0원</div>
                <div id="sb-bb-display-area">SB: 10 / BB: 20</div>
            </div>
        </div>
    </div>

    <script>
        const SUITS = ["♠", "♥", "♦", "♣"];
        const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
        const RANK_VALUES = { "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, "J": 11, "Q": 12, "K": 13, "A": 14, "A_LOW": 1 };
        const HAND_STRENGTH = { HIGH_CARD: 0, ONE_PAIR: 1, TWO_PAIR: 2, THREE_OF_A_KIND: 3, STRAIGHT: 4, FLUSH: 5, FULL_HOUSE: 6, FOUR_OF_A_KIND: 7, STRAIGHT_FLUSH: 8, ROYAL_FLUSH: 9 };

        let STARTING_CHIPS_CONFIG = 1000;
        let BIG_BLIND_AMOUNT_CONFIG = 20;
        let SMALL_BLIND_AMOUNT_CONFIG = 10;
        let AI_ACTION_BASE_DELAY_MS = 0;

        const BLUFF_PROBABILITY_BASE = 0.09;
        const KONAMI_CODE = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
        const VISUAL_ORDER_RULES = { 4: [1, 2, 0, 3], 3: [1, 2, 0], 2: [] };

        let deck = [], communityCards = [], players = [];
        let pot = 0, currentBet = 0, minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG;
        let gamePhase = "", currentPlayerIndex = -1, dealerIndex = -1;
        let currentHandActivePlayerIdsOrder = [], currentTurnInOrderIndex = -1;
        let lastRaiserId = -1, actualNumPlayersInCurrentGame = 0;
        let initialPlayerChipsBeforeHand = {};
        let initialNumPlayersForNextHandLogic = 0;

        let isAdminMode = false, konamiCodePosition = 0;
        let isTutorialMode = false;
        let tutorialStep = 0;
        let tutorialMessages = [];
        let tutorialActionLock = false;

        const gameTableMainEl = document.getElementById('game-table-main');
        const actionsAreaMainEl = document.getElementById('actions-area-main');
        const communityCardsDiv = document.getElementById('community-cards');
        const potDisplayBottomRightEl = document.getElementById('pot-display-bottom-right');
        const sbBbDisplayAreaEl = document.getElementById('sb-bb-display-area');
        const messageLogDiv = document.getElementById('message-log');
        const checkCallButton = document.getElementById('check-call-button');
        const betRaiseButton = document.getElementById('bet-raise-button');
        const raiseInput = document.getElementById('raise-input');
        const foldButton = document.getElementById('fold-button');
        const mainStartGameButton = document.getElementById('start-game-button-main');
        const controlButtonsArea = document.getElementById('control-buttons-area');
        const numPlayersSelect = document.getElementById('num-players-select');
        const aiActionEffectIndicator = document.getElementById('ai-action-effect-indicator');
        const pokerHandsInfoBtn = document.getElementById('poker-hands-info-btn');
        const pokerHandsGuideDiv = document.getElementById('poker-hands-guide-div');
        const startingChipsInputEl = document.getElementById('starting-chips-input');
        const bigBlindInputEl = document.getElementById('big-blind-input');
        const aiDelayInputEl = document.getElementById('ai-delay-input');

        const tutorialButton = document.getElementById('tutorial-button');
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const tutorialMessageBox = document.getElementById('tutorial-message-box');
        const tutorialTitle = document.getElementById('tutorial-title');
        const tutorialText = document.getElementById('tutorial-text');
        const tutorialNextButton = document.getElementById('tutorial-next-button');
        const tutorialSkipStepButton = document.getElementById('tutorial-skip-step-button');
        const tutorialCloseButton = document.getElementById('tutorial-close-button');
        const tutorialSpecificButtonsContainer = document.getElementById('tutorial-specific-buttons'); // 이 줄 추가

        const pokerHandExamples = { "royal-flush": [ { rank: "A", suit: "♠" }, { rank: "K", suit: "♠" }, { rank: "Q", suit: "♠" }, { rank: "J", suit: "♠" }, { rank: "10", suit: "♠" } ], "straight-flush": [ { rank: "9", suit: "♥" }, { rank: "8", suit: "♥" }, { rank: "7", suit: "♥" }, { rank: "6", suit: "♥" }, { rank: "5", suit: "♥" } ], "four-of-a-kind": [ { rank: "A", suit: "♦" }, { rank: "A", suit: "♣" }, { rank: "A", suit: "♥" }, { rank: "A", suit: "♠" }, { rank: "K", suit: "♠" } ], "full-house": [ { rank: "K", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "K", suit: "♥" }, { rank: "7", suit: "♣" }, { rank: "7", suit: "♦" } ], "flush": [ { rank: "A", suit: "♣" }, { rank: "J", suit: "♣" }, { rank: "9", suit: "♣" }, { rank: "5", suit: "♣" }, { rank: "3", suit: "♣" } ], "straight": [ { rank: "A", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "Q", suit: "♥" }, { rank: "J", suit: "♣" }, { rank: "10", suit: "♠" } ], "three-of-a-kind": [ { rank: "Q", suit: "♠" }, { rank: "Q", suit: "♦" }, { rank: "Q", suit: "♥" }, { rank: "A", suit: "♣" }, { rank: "K", suit: "♦" } ], "two-pair": [ { rank: "J", suit: "♠" }, { rank: "J", suit: "♦" }, { rank: "8", suit: "♥" }, { rank: "8", suit: "♣" }, { rank: "A", suit: "♦" } ], "one-pair": [ { rank: "10", suit: "♠" }, { rank: "10", suit: "♦" }, { rank: "A", suit: "♥" }, { rank: "K", suit: "♣" }, { rank: "Q", suit: "♦" } ], "high-card": [ { rank: "A", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "J", suit: "♥" }, { rank: "9", suit: "♣" }, { rank: "7", suit: "♠" } ] };
        function renderSingleExampleCard(cardData) { const cardDiv = document.createElement('div'); cardDiv.classList.add('card'); const cardFaceFront = document.createElement('div'); cardFaceFront.classList.add('card-face', 'card-front'); const rankDiv = document.createElement('span'); rankDiv.classList.add('rank'); rankDiv.textContent = cardData.rank; const suitDiv = document.createElement('span'); suitDiv.classList.add('suit', `suit-${cardData.suit}`); suitDiv.innerHTML = cardData.suit; cardFaceFront.appendChild(rankDiv); cardFaceFront.appendChild(suitDiv); cardFaceFront.style.color = (cardData.suit === "♥" || cardData.suit === "♦") ? "red" : "black"; cardDiv.appendChild(cardFaceFront); return cardDiv; }
        function populatePokerHandExamples() { const exampleContainers = document.querySelectorAll('.poker-hands-guide .hand-example-cards'); exampleContainers.forEach(container => { container.innerHTML = ''; const handName = container.dataset.handName; const cardsData = pokerHandExamples[handName]; if (cardsData) { cardsData.forEach(cardInfo => { container.appendChild(renderSingleExampleCard(cardInfo)); }); } }); }
        function formatNumberWithCommas(number) { if (number === null || number === undefined) return '0'; return Math.floor(Number(number)).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        function showAIActionEffect() { aiActionEffectIndicator.classList.add('active'); setTimeout(() => aiActionEffectIndicator.classList.remove('active'), 700); }
        function getPlayerSlotElement(playerIndex) { return document.getElementById(`player-slot-${playerIndex}`); }
        function showEnhancedFeedback(playerId, text, typeClass) { const playerSlot = getPlayerSlotElement(playerId); if (!playerSlot) return; const existingFeedback = playerSlot.querySelector('.enhanced-feedback'); if (existingFeedback) { existingFeedback.remove(); } const feedbackDiv = document.createElement('div'); feedbackDiv.classList.add('enhanced-feedback', typeClass); feedbackDiv.textContent = text; playerSlot.appendChild(feedbackDiv); requestAnimationFrame(() => { setTimeout(() => { feedbackDiv.classList.add('show'); }, 20); }); setTimeout(() => { feedbackDiv.classList.add('fade-out'); setTimeout(() => { if (feedbackDiv.parentNode) { feedbackDiv.remove(); } }, 700); }, 1500); }
        function getPlayerPositionCategory(player, dealerPlayerId, numActivePlayersInHandForPos, currentHandOrder) { if (numActivePlayersInHandForPos <= 1) return "OnlyPlayer"; const playerActualOrder = currentHandOrder; const playerIndexInOrder = playerActualOrder.indexOf(player.id); if (playerIndexInOrder === -1) return "PositionError_NotFoundInOrder"; if (numActivePlayersInHandForPos === 2) { return player.isSB ? "SB_Dealer" : "BB_Opponent"; } if (playerIndexInOrder === 0) return "SB"; if (playerIndexInOrder === 1) return "BB"; const bbPlayer = players.find(p => p.isBB && playerActualOrder.includes(p.id)); let bbIndexInOrder = bbPlayer ? playerActualOrder.indexOf(bbPlayer.id) : 1; if (bbIndexInOrder === -1) bbIndexInOrder = 1; if (playerIndexInOrder === (bbIndexInOrder + 1) % numActivePlayersInHandForPos) return "UTG"; if (player.id === dealerPlayerId) return "Dealer"; const dealerIndexInActualOrder = playerActualOrder.indexOf(dealerPlayerId); if (dealerIndexInActualOrder !== -1) { if (playerIndexInOrder === (dealerIndexInActualOrder - 1 + numActivePlayersInHandForPos) % numActivePlayersInHandForPos) return "CutOff"; } if (numActivePlayersInHandForPos <= 6) { if (playerIndexInOrder < Math.floor(numActivePlayersInHandForPos / 2) && playerIndexInOrder > 1) return "Early"; else if (playerIndexInOrder >= Math.floor(numActivePlayersInHandForPos / 2) && player.id !== dealerPlayerId && playerActualOrder.indexOf(dealerPlayerId) !== playerIndexInOrder -1 ) return "Late"; } else { if (playerIndexInOrder < numActivePlayersInHandForPos / 3 && playerIndexInOrder > 1) return "Early"; if (playerIndexInOrder < (numActivePlayersInHandForPos * 2) / 3  && playerIndexInOrder > 1) return "Middle"; if (player.id !== dealerPlayerId && playerActualOrder.indexOf(dealerPlayerId) !== playerIndexInOrder -1 ) return "Late"; } return "Middle"; }
        function calculatePotOdds(amountToCall, currentPotTotal) { if (amountToCall <= 0) return 1; return amountToCall / (currentPotTotal + amountToCall); }
        function analyzeBoardTexture(communityCards) { if (!communityCards || communityCards.length < 3) return { type: "preflop", isWet: false, isPaired: false, flushDraws: 0, straightDraws: 0, highCardValue:0 }; let texture = { type: "unknown", isWet: false, isPaired: false, flushDraws: 0, straightDraws: 0, highCardValue:0 }; const ranks = communityCards.map(c => c.value).sort((a,b)=>b-a); const suits = communityCards.map(c => c.suit); texture.highCardValue = ranks[0] || 0; const rankCounts = {}; ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1); if (Object.values(rankCounts).some(count => count >= 2)) texture.isPaired = true; if (Object.values(rankCounts).some(count => count >= 3)) { texture.isPaired = true; texture.isWet = true; } const suitCounts = {}; suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1); Object.values(suitCounts).forEach(count => { if (count === 2 && communityCards.length === 3) texture.flushDraws = 1; if (count >= 3) {texture.flushDraws = Math.max(texture.flushDraws, count); texture.isWet = true;} }); const uniqueSortedRanks = [...new Set(ranks)].sort((a,b)=>a-b); if (uniqueSortedRanks.length >= 3) { for (let i = 0; i <= uniqueSortedRanks.length - 3; i++) { if (uniqueSortedRanks[i+2] - uniqueSortedRanks[i] <= 4) { texture.straightDraws++; texture.isWet = true; } } if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(2) && uniqueSortedRanks.includes(3)) texture.straightDraws++; if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(2) && uniqueSortedRanks.includes(4) && !uniqueSortedRanks.includes(3)) texture.straightDraws++; if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(3) && uniqueSortedRanks.includes(4) && !uniqueSortedRanks.includes(2)) texture.straightDraws++; } if (texture.straightDraws > 1 || (texture.straightDraws > 0 && texture.flushDraws >=3 )) texture.isWet = true; if (!texture.isWet && !texture.isPaired && texture.highCardValue < RANK_VALUES.J && ranks.length >=3 && (ranks[0] - ranks[ranks.length-1] > 5)) { texture.type = "dry_uncoordinated"; } else if (texture.isWet) { texture.type = "wet_drawy"; } else if (texture.isPaired) { texture.type = "paired"; } else { texture.type = "semi_coordinated"; } return texture; }
        function createDeck() { deck = []; for (let suit of SUITS) for (let rank of RANKS) deck.push({ suit, rank, value: RANK_VALUES[rank], id: rank+suit+Date.now()+Math.random() }); }
        function shuffleDeck() { for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } }
        function dealCardFromDeck(hiddenInitially = false) { if (deck.length > 0) { const card = deck.pop(); card.hidden = hiddenInitially; card.revealed = !hiddenInitially; return card; } return null; }
        function burnCard() { if (deck.length > 0) deck.pop(); }
        function createPlayerSlotUI(player) { const slotDiv = getPlayerSlotElement(player.id); if (!slotDiv) { console.error(`Slot DIV for player ${player.id} not found`); return; } slotDiv.innerHTML = `<div class="player-name-display">${player.name} <span id="dealer-chip-${player.id}" class="dealer-chip-ui" style="display:none;">D</span><span id="sb-chip-${player.id}" class="blind-chip-ui" style="display:none;">SB</span><span id="bb-chip-${player.id}" class="blind-chip-ui" style="display:none;">BB</span></div><div id="cards-player-${player.id}" class="cards-container"></div><div id="chips-player-${player.id}" class="chips-display">칩: ${formatNumberWithCommas(player.chips)}원</div><div id="bet-player-${player.id}" class="bet-amount-display" style="display:none;"></div><div id="current-hand-player-${player.id}" class="current-hand-display"></div>`; slotDiv.style.display = "block"; }
        function renderPlayerCard(player, cardData, hiddenInitially = false) { const cardsContainer = document.getElementById(`cards-player-${player.id}`); if (!cardsContainer) return; let cardIsActuallyHiddenForRender = hiddenInitially; if (isAdminMode && player.type === 'ai') { cardIsActuallyHiddenForRender = false; } const cardElement = renderSingleCard(cardData, false, cardIsActuallyHiddenForRender); cardsContainer.appendChild(cardElement); return cardElement; }
        function renderSingleCard(card, isCommunity = false, hiddenInitially = false) { const cardDiv = document.createElement('div'); cardDiv.classList.add('card'); cardDiv.dataset.cardId = card.id; const cardFaceFront = document.createElement('div'); cardFaceFront.classList.add('card-face', 'card-front'); const rankDiv = document.createElement('span'); rankDiv.classList.add('rank'); rankDiv.textContent = card.rank; const suitDiv = document.createElement('span'); suitDiv.classList.add('suit', `suit-${card.suit}`); suitDiv.innerHTML = card.suit; cardFaceFront.appendChild(rankDiv); cardFaceFront.appendChild(suitDiv); cardFaceFront.style.color = (card.suit === "♥" || card.suit === "♦") ? "red" : "black"; const cardFaceBack = document.createElement('div'); cardFaceBack.classList.add('card-face', 'card-back'); cardDiv.appendChild(cardFaceFront); cardDiv.appendChild(cardFaceBack); if (hiddenInitially) { cardDiv.classList.add('hidden');} let delay = 0; if (isCommunity) delay = communityCardsDiv.children.length * 150; setTimeout(() => { cardDiv.classList.add('is-dealt'); if (!hiddenInitially) { setTimeout(() => { if (!cardDiv.classList.contains('hidden')) { cardDiv.classList.add('is-flipping'); } }, 50 + delay + (isCommunity ? 100 : 0) ); } }, 50 + delay); return cardDiv; }
        async function dealAnimatedCommunityCard(cardData) { communityCards.push(cardData); const cardElement = renderSingleCard(cardData, true, false); communityCardsDiv.appendChild(cardElement); await sleep(isTutorialMode ? 50 : 200); }
        function revealHiddenCard(player, cardObj) { const cardElement = document.querySelector(`#cards-player-${player.id} .card[data-card-id="${cardObj.id}"]`); if (cardElement && cardElement.classList.contains('hidden')) { cardElement.classList.remove('hidden'); cardElement.classList.add('is-flipping'); } if(player.type === 'ai') { const gameCard = player.cards.find(c => c.id === cardObj.id); if(gameCard) { gameCard.hidden = false; gameCard.revealed = true;} } }

        function updateOverallUI() { players.forEach(p => { const slotDiv = getPlayerSlotElement(p.id); if (!slotDiv) return; document.getElementById(`chips-player-${p.id}`).textContent = `칩: ${formatNumberWithCommas(p.chips)}원`; const betDiv = document.getElementById(`bet-player-${p.id}`); if (p.betInRound > 0) { betDiv.textContent = `벳: ${formatNumberWithCommas(p.betInRound)}원`; betDiv.style.display = 'inline-block'; } else { betDiv.style.display = 'none'; } document.getElementById(`dealer-chip-${p.id}`).style.display = p.isDealer ? 'inline-block' : 'none'; document.getElementById(`sb-chip-${p.id}`).style.display = p.isSB ? 'inline-block' : 'none'; document.getElementById(`bb-chip-${p.id}`).style.display = p.isBB ? 'inline-block' : 'none'; const currentHandDiv = document.getElementById(`current-hand-player-${p.id}`); if (currentHandDiv && p.type === "human" && p.cards.length >= 2 && !p.isFolded) { if (communityCards.length >= 3) { const handDetails = getHandDetails([...p.cards, ...communityCards]); currentHandDiv.textContent = `현재 최고패: ${handDetails.handName}`; } else if (p.cards.length === 2) { let preflopHandName = ""; const card1 = p.cards[0]; const card2 = p.cards[1]; if (card1.value === card2.value) { preflopHandName = `${card1.rank} 페어`; } else { const highRankValue = Math.max(card1.value, card2.value); const lowRankValue = Math.min(card1.value, card2.value); const highRankName = Object.keys(RANK_VALUES).find(key => RANK_VALUES[key] === highRankValue && key !== "A_LOW"); const lowRankName = Object.keys(RANK_VALUES).find(key => RANK_VALUES[key] === lowRankValue && key !== "A_LOW"); preflopHandName = `${highRankName || card1.rank}${lowRankName || card2.rank}`; if (card1.suit === card2.suit) { preflopHandName += "s"; } else { preflopHandName += "o"; } preflopHandName += ` (하이: ${highRankName || card1.rank})`; } currentHandDiv.textContent = `손패: ${preflopHandName}`; } } else if (currentHandDiv) { currentHandDiv.textContent = ""; } slotDiv.classList.remove('acting', 'folded'); const currentPlayerObject = players[currentPlayerIndex]; if (currentPlayerObject && p.id === currentPlayerObject.id && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND" && !p.isFolded && !p.isAllIn) { slotDiv.classList.add('acting'); } if (p.isFolded) slotDiv.classList.add('folded'); if (isAdminMode && p.type === 'ai' && !p.isFolded) { p.cards.forEach(cardData => { const cardElement = document.querySelector(`#cards-player-${p.id} .card[data-card-id="${cardData.id}"]`); if (cardElement && cardElement.classList.contains('hidden')) { cardElement.classList.remove('hidden'); if (!cardElement.classList.contains('is-flipping') && !cardElement.classList.contains('is-dealt')) { setTimeout(() => cardElement.classList.add('is-dealt'), 50); setTimeout(() => cardElement.classList.add('is-flipping'), 150); } else if (!cardElement.classList.contains('is-flipping')) { cardElement.classList.add('is-flipping'); } } cardData.hidden = false; cardData.revealed = true; }); } }); if (potDisplayBottomRightEl) potDisplayBottomRightEl.textContent = `팟: ${formatNumberWithCommas(pot)}원`; updateActionButtonsForHuman(); }
        function updateActionButtonsForHuman() { const humanPlayer = players.find(p => p.type === "human"); if (!humanPlayer) { checkCallButton.disabled = true; betRaiseButton.disabled = true; raiseInput.disabled = true; foldButton.disabled = true; return; } const currentPlayerObject = players[currentPlayerIndex]; const isHumanTurn = currentPlayerObject && humanPlayer.id === currentPlayerObject.id && !humanPlayer.isFolded && !humanPlayer.isAllIn && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND"; let disableActionsDueToTutorial = isTutorialMode && tutorialActionLock; checkCallButton.disabled = !isHumanTurn || disableActionsDueToTutorial; betRaiseButton.disabled = !isHumanTurn || disableActionsDueToTutorial; raiseInput.disabled = !isHumanTurn || disableActionsDueToTutorial; foldButton.disabled = !isHumanTurn || disableActionsDueToTutorial; if (isHumanTurn) { const amountToCall = currentBet - humanPlayer.betInRound; if (amountToCall > 0) { checkCallButton.textContent = `콜 (${formatNumberWithCommas(Math.min(amountToCall, humanPlayer.chips))}원)`; betRaiseButton.textContent = "레이즈"; } else { checkCallButton.textContent = "체크"; betRaiseButton.textContent = "벳"; } let minNewTotalBet = currentBet + minRaiseAmount; if (currentBet === 0) minNewTotalBet = minRaiseAmount; minNewTotalBet = Math.max(minNewTotalBet, humanPlayer.betInRound + (currentBet > 0 ? minRaiseAmount : SMALL_BLIND_AMOUNT_CONFIG)); raiseInput.min = Math.floor(Math.min(humanPlayer.chips + humanPlayer.betInRound, minNewTotalBet)); raiseInput.value = Math.floor(Math.min(humanPlayer.chips + humanPlayer.betInRound, minNewTotalBet)); raiseInput.max = Math.floor(humanPlayer.chips + humanPlayer.betInRound); } else { checkCallButton.textContent = "체크"; betRaiseButton.textContent = "벳"; } }
        function displayMessage(msg, type = "system-message") { const p = document.createElement('p'); p.classList.add(type); p.textContent = msg; messageLogDiv.appendChild(p); messageLogDiv.scrollTop = messageLogDiv.scrollHeight; }

        function defineTutorialMessages() {
            tutorialMessages = [
                { // Step 0: 시작
                    title: "튜토리얼 시작",
                    text: "텍사스 홀덤 튜토리얼에 오신 것을 환영합니다! 이 튜토리얼은 게임의 기본 흐름과 규칙을 안내합니다.<br><br>먼저 게임 설정을 확인합니다. 참가 인원은 2명, 시작 칩 1000원, BB 금액 20원으로 설정됩니다. (튜토리얼에서는 고정)<br><br>'다음 설명' 버튼을 눌러 튜토리얼을 시작하세요.",
                    actionType: "CLICK_NEXT_BUTTON",
                    setup: () => {
                        numPlayersSelect.value = "2";
                        startingChipsInputEl.value = "1000";
                        bigBlindInputEl.value = "20";
                        aiDelayInputEl.value = "0";
                        numPlayersSelect.disabled = true;
                        startingChipsInputEl.disabled = true;
                        bigBlindInputEl.disabled = true;
                        aiDelayInputEl.disabled = true;
                        const existingStartButton = document.getElementById('start-game-button-main');
                        if (existingStartButton) existingStartButton.style.display = 'none'; // 일반 새 게임 버튼 숨김
                        // controlButtonsArea.innerHTML = ''; // 다른 버튼들도 제거
                    }
                },
                { // Step 1: 게임 시작 지시 (튜토리얼 박스 내 버튼으로)
                    title: "게임 시작하기",
                    text: "좋습니다! 이제 실제 게임 테이블에서 진행됩니다. 아래 '튜토리얼 게임 시작' 버튼을 눌러 첫 핸드를 시작하세요.<br><br>이 버튼을 누르면 딜러가 정해지고, 스몰 블라인드(SB)와 빅 블라인드(BB)가 자동으로 베팅됩니다.",
                    actionType: "CLICK_TUTORIAL_START_GAME_BUTTON",
                    waitForAction: true,
                    setup: () => {
                        tutorialNextButton.style.display = 'none';
                        const gameControlStartButton = document.getElementById('start-game-button-main');
                        if (gameControlStartButton) {
                            gameControlStartButton.style.display = 'none';
                        }
                    }
                },
                { // Step 2: 블라인드 및 딜러 설명
                    title: "딜러와 블라인드 베팅",
                    text: "게임이 시작되면, 한 명에게 딜러(D) 표시가 붙습니다. 딜러 왼쪽 플레이어가 스몰 블라인드(SB), 그 왼쪽이 빅 블라인드(BB)가 됩니다.<br><br>SB와 BB는 자신의 카드를 받기 전에 정해진 금액을 의무적으로 베팅해야 합니다. 현재 SB는 [SB금액]원, BB는 [BB금액]원입니다. 팟(Pot)은 현재까지 모인 총 베팅 금액입니다.<br><br>'다음 설명'을 누르세요.",
                    actionType: "CLICK_NEXT_BUTTON",
                    advanceAfterGameSetup: true, // 게임 설정(SB/BB 포스팅, 카드딜 완료) 후 이 단계로 자동 진입하도록 표시
                },
                { // Step 3: 홀 카드 (Hole Cards) 설명
                    title: "나의 카드 (홀 카드)",
                    text: "각 플레이어는 2장의 카드를 받습니다. 이 카드는 자신만 볼 수 있으며 (이 튜토리얼에서는 AI의 카드도 특별히 보입니다), 이를 '홀 카드(Hole Cards)' 또는 '포켓 카드(Pocket Cards)'라고 부릅니다.<br><br>이 두 장의 카드는 게임에서 매우 중요합니다! '다음 설명'을 누르세요.",
                    actionType: "CLICK_NEXT_BUTTON",
                },
                { // Step 4: 프리플랍 베팅 라운드 시작 및 플레이어 액션 (플레이어가 SB, 2인 가정)
                    title: "프리플랍 베팅 (1/2)",
                    text: "이제 첫 번째 베팅 라운드인 '프리플랍(Pre-flop)'이 시작됩니다. 커뮤니티 카드가 깔리기 전입니다.<br><br>당신은 딜러이자 스몰 블라인드(SB)입니다. 2인 게임에서는 SB가 가장 먼저 액션을 취합니다. 현재 BB가 [BB금액]원을 냈고, 당신은 SB로 [SB금액]원을 냈습니다. 따라서 당신은 추가로 [콜금액SB]원을 내면 '콜(Call)'이 됩니다.<br><br>혹은, BB금액보다 더 많이 베팅하는 '레이즈(Raise)', 게임을 포기하는 '폴드(Fold)'를 할 수 있습니다.<br><br>여기서는 '콜' 버튼을 눌러 [콜금액SB]원을 추가로 베팅해보세요.",
                    actionType: "USER_ACTION",
                    requiredPlayerAction: 'CHECK_CALL',
                    highlightElementId: 'check-call-button',
                    waitForAction: true,
                    setup: () => { tutorialActionLock = false; updateActionButtonsForHuman(); }
                },
                { // Step 5: AI의 액션 (튜토리얼용 - AI가 콜)
                    title: "프리플랍 베팅 (2/2) - 상대 액션",
                    text: "당신이 콜을 하자, 이제 상대방(AI 플레이어, BB)의 차례입니다.<br><br>AI는 당신의 액션을 보고 자신의 액션을 결정합니다. (튜토리얼에서는 AI가 콜을 할 것입니다.)<br><br>만약 AI가 레이즈를 했다면, 다시 당신의 차례가 돌아와서 콜, 레이즈, 또는 폴드를 결정해야 합니다. AI가 체크나 콜을 하면 베팅이 완료됩니다.<br><br>'다음 설명'을 눌러 커뮤니티 카드를 보세요.",
                    actionType: "CLICK_NEXT_BUTTON",
                    aiScriptedAction: { type: 'CHECK_CALL' },
                    setup: () => { tutorialActionLock = true; }
                },
                {
                    title: "플랍 (Flop) - 커뮤니티 카드",
                    text: "프리플랍 베팅이 끝나면, 테이블 중앙에 3장의 카드가 앞면으로 공개됩니다. 이를 '플랍(Flop)'이라고 합니다.<br><br>이 카드들은 모든 플레이어가 공유하며, 자신의 홀 카드 2장과 플랍 카드 3장을 조합하여 더 강한 포커 핸드를 만들 수 있습니다.<br><br>'다음 설명'을 누르세요.",
                    actionType: "CLICK_NEXT_BUTTON",
                    advanceAfterFlopDealt: true, // 플랍 카드가 깔린 후 자동 진행 플래그
                },
                {
                    title: "튜토리얼 완료 (기초)",
                    text: "여기까지 텍사스 홀덤의 기본적인 프리플랍과 플랍 진행을 알아보았습니다. 계속해서 턴, 리버, 쇼다운 과정을 익히고 다양한 베팅 전략을 연습해보세요!<br><br>이 튜토리얼은 여기서 마무리됩니다. '튜토리얼 종료' 버튼을 눌러 실제 게임을 즐기거나, 이 코드를 바탕으로 더 많은 튜토리얼 단계를 추가해보세요.",
                    actionType: "CLICK_CLOSE_BUTTON"
                }
            ];
        }

        function parseTutorialMessage(message) {
            if (!message) return "";
            message = message.replace(/\[BB금액\]/g, `<strong>${formatNumberWithCommas(BIG_BLIND_AMOUNT_CONFIG)}</strong>`);
            message = message.replace(/\[SB금액\]/g, `<strong>${formatNumberWithCommas(SMALL_BLIND_AMOUNT_CONFIG)}</strong>`);
            const humanPlayer = players.find(p => p.type === "human");
            if (humanPlayer) {
                const callAmountForSB = BIG_BLIND_AMOUNT_CONFIG - SMALL_BLIND_AMOUNT_CONFIG;
                message = message.replace(/\[콜금액SB\]/g, `<strong>${formatNumberWithCommas(callAmountForSB)}</strong>`);
                const amountToCall = currentBet - humanPlayer.betInRound;
                message = message.replace(/\[콜금액플레이어\]/g, `<strong>${formatNumberWithCommas(Math.max(0, amountToCall > 0 ? Math.min(amountToCall, humanPlayer.chips) : 0))}</strong>`);
            }
            return message;
        }

        function startTutorial() {
            if (isTutorialMode) return;
            isTutorialMode = true;
            tutorialStep = 0;
            tutorialActionLock = false;
            displayMessage("튜토리얼 모드가 시작되었습니다. 안내에 따라 진행해주세요.", "tutorial-message");

            gameTableMainEl.style.display = 'none';
            actionsAreaMainEl.style.display = 'none';
            const gameCtrlStartBtn = document.getElementById('start-game-button-main');
            if (gameCtrlStartBtn) gameCtrlStartBtn.style.display = 'none'; // 일반 시작 버튼 숨김
            controlButtonsArea.innerHTML = ''; // 다른 게임 컨트롤 버튼도 숨김

            defineTutorialMessages();
            displayTutorialStep();
            tutorialOverlay.style.display = 'flex';
        }

        function endTutorial(forceEndGame = true) {
            isTutorialMode = false;
            tutorialOverlay.style.display = 'none';
            tutorialStep = 0;
            tutorialActionLock = false;
            displayMessage("튜토리얼 모드가 종료되었습니다.", "system-message");

            document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
            const gameCtrlStartBtn = document.getElementById('start-game-button-main');
            if (gameCtrlStartBtn) {
                gameCtrlStartBtn.textContent = '새 게임';
                gameCtrlStartBtn.disabled = false;
                gameCtrlStartBtn.style.display = 'inline-block'; // 일반 시작 버튼 다시 보이게
            }
            controlButtonsArea.innerHTML = `<button id="start-game-button-main">새 게임</button>`; // 버튼 영역 복원
             document.getElementById('start-game-button-main').addEventListener('click', () => initializeNewGame(false));


            numPlayersSelect.disabled = false;
            startingChipsInputEl.disabled = false;
            bigBlindInputEl.disabled = false;
            aiDelayInputEl.disabled = false;

            if (forceEndGame && (gamePhase !== "" && gamePhase !== "SETUP" && gamePhase !== "END_HAND")) {
                gameTableMainEl.style.display = 'none';
                actionsAreaMainEl.style.display = 'none';
                players = [];
                communityCards = [];
                communityCardsDiv.innerHTML = '';
                pot = 0;
                updateOverallUI();
            }
        }

        function displayTutorialStep() {
            if (!isTutorialMode || tutorialStep >= tutorialMessages.length) {
                if (isTutorialMode) endTutorial(false);
                return;
            }
            const currentStepData = tutorialMessages[tutorialStep];
            tutorialTitle.textContent = currentStepData.title;
            tutorialText.innerHTML = parseTutorialMessage(currentStepData.text);

            tutorialNextButton.style.display = (currentStepData.actionType === "CLICK_NEXT_BUTTON") ? 'inline-block' : 'none';
            tutorialSkipStepButton.style.display = (isAdminMode && currentStepData.waitForAction) ? 'inline-block' : 'none';

            if (tutorialSpecificButtonsContainer) { // null 체크 추가
                tutorialSpecificButtonsContainer.innerHTML = '';
                if (currentStepData.actionType === "CLICK_TUTORIAL_START_GAME_BUTTON") {
                    const startButton = document.createElement('button');
                    startButton.id = 'tutorial-initiate-game-btn';
                    startButton.textContent = '튜토리얼 게임 시작';
                    startButton.style.backgroundColor = '#27ae60';
                    startButton.style.color = 'white';
                    startButton.style.padding = '10px 18px';
                    startButton.style.fontSize = '0.95em';
                    startButton.style.border = 'none';
                    startButton.style.borderRadius = '5px';
                    startButton.style.cursor = 'pointer';
                    startButton.onmouseover = () => startButton.style.backgroundColor = '#229954';
                    startButton.onmouseout = () => startButton.style.backgroundColor = '#27ae60';
                    startButton.onclick = async () => {
                        if (isTutorialMode && tutorialMessages[tutorialStep]?.actionType === "CLICK_TUTORIAL_START_GAME_BUTTON") {
                            startButton.disabled = true;
                            startButton.textContent = '게임 시작 중...';
                            startButton.style.backgroundColor = '#7f8c8d';
                            await initializeNewGame(true);
                        }
                    };
                    tutorialSpecificButtonsContainer.appendChild(startButton);
                }
            }

            document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
            if (currentStepData.highlightElementId) {
                const elToHighlight = document.getElementById(currentStepData.highlightElementId);
                if (elToHighlight) elToHighlight.classList.add('tutorial-highlight');
            }

            if (currentStepData.setup) {
                currentStepData.setup();
            }
            updateActionButtonsForHuman();
        }

        async function advanceTutorial(fromGameLogic = false) {
            if (!isTutorialMode) return;

            const currentStepData = tutorialMessages[tutorialStep];
            if (currentStepData && currentStepData.highlightElementId) {
                const el = document.getElementById(currentStepData.highlightElementId);
                if (el) el.classList.remove('tutorial-highlight');
            }

            tutorialStep++;
            console.log(`Advancing to tutorial step: ${tutorialStep}`);
            displayTutorialStep();

            const nextStepData = tutorialMessages[tutorialStep];
            if (nextStepData) {
                if (nextStepData.aiScriptedAction && currentPlayerIndex !== -1 && players[currentPlayerIndex]?.type === 'ai' && !fromGameLogic) {
                    console.log("Tutorial: Triggering scripted AI action for next step.");
                    await sleep(500);
                    await handleAIAction(players[currentPlayerIndex]);
                } else if (nextStepData.advanceConditionMet && nextStepData.advanceConditionMet()) {
                    console.log("Tutorial: Advance condition met for next step.");
                    await sleep(100);
                    advanceTutorial();
                }
            }
        }

        async function initializeNewGame(isTutorialStart = false) {
            if (isTutorialMode && !isTutorialStart) {
                 displayMessage("튜토리얼 진행 중입니다. 튜토리얼 안내창의 버튼을 이용해주세요.", "tutorial-message");
                 return;
            }
            gameTableMainEl.style.display = 'grid'; actionsAreaMainEl.style.display = 'flex';
            let newStartingChips = parseInt(startingChipsInputEl.value); let newBigBlind = parseInt(bigBlindInputEl.value); let newAiDelay = parseInt(aiDelayInputEl.value);

            if (isTutorialMode) {
                STARTING_CHIPS_CONFIG = 1000;
                BIG_BLIND_AMOUNT_CONFIG = 20;
                AI_ACTION_BASE_DELAY_MS = 0;
                actualNumPlayersInCurrentGame = 2;
                numPlayersSelect.value = "2";
            } else {
                STARTING_CHIPS_CONFIG = (!isNaN(newStartingChips) && newStartingChips >= 100) ? newStartingChips : 1000;
                BIG_BLIND_AMOUNT_CONFIG = (!isNaN(newBigBlind) && newBigBlind >= 2) ? newBigBlind : 20;
                AI_ACTION_BASE_DELAY_MS = (!isNaN(newAiDelay) && newAiDelay >= 0) ? newAiDelay * 1000 : 0;
                actualNumPlayersInCurrentGame = parseInt(numPlayersSelect.value);
            }
            SMALL_BLIND_AMOUNT_CONFIG = Math.floor(BIG_BLIND_AMOUNT_CONFIG / 2); minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG;
            if (sbBbDisplayAreaEl) sbBbDisplayAreaEl.textContent = `SB: ${formatNumberWithCommas(SMALL_BLIND_AMOUNT_CONFIG)} / BB: ${formatNumberWithCommas(BIG_BLIND_AMOUNT_CONFIG)}`;
            initialNumPlayersForNextHandLogic = actualNumPlayersInCurrentGame;
            players = [];
            for (let i = 0; i < actualNumPlayersInCurrentGame; i++) { players.push({ id: i, name: i === 0 ? "플레이어" : `AI ${i}`, type: i === 0 ? "human" : "ai", chips: STARTING_CHIPS_CONFIG, cards: [], betInRound: 0, isFolded: false, isAllIn: false, isDealer: false, isSB: false, isBB: false, handDetails: null, hasActedThisBettingRound: false, positionCategory: "Unknown", previousAction: null, raisesThisRoundCount: 0, aggressionFactor: Math.random() * 0.5 + 0.75, tightnessFactor: Math.random() * 0.5 + 0.75 }); createPlayerSlotUI(players[i]); }
            for (let i = actualNumPlayersInCurrentGame; i <= 3; i++) { const slot = getPlayerSlotElement(i); if(slot) slot.style.display = "none"; }
            dealerIndex = -1;

            const gameCtrlStartBtn = document.getElementById('start-game-button-main');
            if (isTutorialMode && isTutorialStart) {
                if (gameCtrlStartBtn) gameCtrlStartBtn.style.display = 'none';
                controlButtonsArea.innerHTML = '';
            } else if (!isTutorialMode) {
                if (gameCtrlStartBtn) gameCtrlStartBtn.style.display = 'none';
                controlButtonsArea.innerHTML = '';
            }

            numPlayersSelect.disabled = true; startingChipsInputEl.disabled = true; bigBlindInputEl.disabled = true; aiDelayInputEl.disabled = true;

            await startNewHand();

            if (isTutorialMode && isTutorialStart && gamePhase === "PREFLOP" && tutorialMessages[tutorialStep]?.advanceAfterGameSetup) {
                console.log("Tutorial: Game initialized for tutorial, advancing to blind explanation (Step 2).");
                await sleep(300);
                advanceTutorial(true);
            }
        }

        async function startNewHand() {
            gameTableMainEl.style.display = 'grid'; actionsAreaMainEl.style.display = 'flex';
            if (!isTutorialMode) {
                controlButtonsArea.innerHTML = '';
                const oldMainStartButton = document.getElementById('start-game-button-main'); if(oldMainStartButton) oldMainStartButton.style.display = 'none';
                numPlayersSelect.disabled = true; startingChipsInputEl.disabled = true; bigBlindInputEl.disabled = true; aiDelayInputEl.disabled = true;
            }

            if (players.length === 0) {
                console.error("플레이어 정보 없이 핸드 시작 시도.");
                if (!isTutorialMode) {
                    gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none'; controlButtonsArea.innerHTML = `<button id="start-game-button-main">새 게임</button>`; document.getElementById('start-game-button-main').addEventListener('click', () => initializeNewGame(false)); numPlayersSelect.disabled = false; startingChipsInputEl.disabled = false; bigBlindInputEl.disabled = false; aiDelayInputEl.disabled = false;
                }
                return;
            }
            const activePlayersWithChips = players.filter(p => p.chips > 0);
            if (activePlayersWithChips.length <= 1 && players.length > 0 && !isTutorialMode) { await endCurrentHand(false); return; }

            gamePhase = "SETUP"; createDeck(); shuffleDeck(); communityCards = []; communityCardsDiv.innerHTML = ''; pot = 0; currentBet = 0; minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG; lastRaiserId = -1; currentHandActivePlayerIdsOrder = []; currentTurnInOrderIndex = -1;
            players.forEach(p => { p.cards = []; p.betInRound = 0; if (p.chips <= 0) p.isFolded = true; else p.isFolded = false; p.isAllIn = (p.chips === 0 && !p.isFolded); p.isDealer = false; p.isSB = false; p.isBB = false; p.handDetails = null; p.hasActedThisBettingRound = false; p.previousAction = null; p.raisesThisRoundCount = 0; const cardsDiv = document.getElementById(`cards-player-${p.id}`); if (cardsDiv) cardsDiv.innerHTML = ''; const currentHandDiv = document.getElementById(`current-hand-player-${p.id}`); if(currentHandDiv) currentHandDiv.textContent = ""; });

            let prevDealerOriginalIndex = dealerIndex;
            if (isTutorialMode) {
                dealerIndex = 0; 
            } else {
                if (dealerIndex === -1 || !players[dealerIndex] || players[dealerIndex].chips <= 0 || players[dealerIndex].isFolded) { dealerIndex = Math.floor(Math.random() * actualNumPlayersInCurrentGame); let initialPick = dealerIndex; while(!players[dealerIndex] || players[dealerIndex].chips <= 0 || players[dealerIndex].isFolded) { dealerIndex = (dealerIndex + 1) % actualNumPlayersInCurrentGame; if(dealerIndex === initialPick) { console.error("Cannot find a dealer."); if(!isTutorialMode) await endCurrentHand(false); return; } } }
                else { const activeForDealerMove = players.filter(p=>p.chips>0 && !p.isFolded); if (activeForDealerMove.length === 2) { const prevDealerPlayer = players[prevDealerOriginalIndex]; const nextDealerCand = activeForDealerMove.find(p => p.id !== prevDealerPlayer.id); dealerIndex = players.findIndex(p => p.id === (nextDealerCand ? nextDealerCand.id : activeForDealerMove[0].id)); } else if (activeForDealerMove.length > 2) { const baseOrderForDealer = VISUAL_ORDER_RULES[actualNumPlayersInCurrentGame] || VISUAL_ORDER_RULES[4].filter(id => activeForDealerMove.some(p => p.id === id)); let currentDealerVisualPos = baseOrderForDealer.indexOf(players[prevDealerOriginalIndex].id); if(currentDealerVisualPos === -1) currentDealerVisualPos = 0; let nextDealerId; for (let i = 1; i <= baseOrderForDealer.length; i++) { nextDealerId = baseOrderForDealer[(currentDealerVisualPos + i) % baseOrderForDealer.length]; const pCand = activeForDealerMove.find(p => p.id === nextDealerId); if (pCand) { dealerIndex = players.findIndex(p => p.id === nextDealerId); break; } } } else { console.error("Not enough active players for dealer."); if(!isTutorialMode) await endCurrentHand(false); return; } }
                if(dealerIndex === -1 || !players[dealerIndex]) { dealerIndex = players.findIndex(p => p.chips > 0 && !p.isFolded); if(dealerIndex === -1) { console.error("Critical: No valid dealer found."); if(!isTutorialMode) await endCurrentHand(false); return;} }
            }
            players[dealerIndex].isDealer = true; const currentDealerPlayerId = players[dealerIndex].id; displayMessage(`${players[dealerIndex].name}가 딜러입니다.`, "game-event");

            const activePlayersInHandList = players.filter(p => !p.isFolded && (p.chips > 0 || p.isAllIn) );
            const numActiveInHand = activePlayersInHandList.length; let sbPlayer = null, bbPlayer = null;

            if (numActiveInHand === 2) {
                sbPlayer = players[dealerIndex]; 
                sbPlayer.isSB = true;
                bbPlayer = activePlayersInHandList.find(p => p.id !== sbPlayer.id);
                if (bbPlayer) bbPlayer.isBB = true;
                else { console.error("HU: BB not found"); if(!isTutorialMode) await endCurrentHand(false); return;}
                currentHandActivePlayerIdsOrder = [sbPlayer.id, bbPlayer.id]; 
            }
            else if (numActiveInHand > 2) {
                const baseVisualOrder = VISUAL_ORDER_RULES[actualNumPlayersInCurrentGame] ? [...VISUAL_ORDER_RULES[actualNumPlayersInCurrentGame]] : [...VISUAL_ORDER_RULES[4]].filter(id => activePlayersInHandList.some(p => p.id === id));
                let dealerPosInVisual = baseVisualOrder.indexOf(currentDealerPlayerId);
                currentHandActivePlayerIdsOrder = []; 
                if(dealerPosInVisual === -1) { 
                    const activePlayerIdsOrdered = players.filter(p => activePlayersInHandList.includes(p)).map(p => p.id);
                    let currentDealerIndexInActive = activePlayerIdsOrdered.indexOf(currentDealerPlayerId);
                    if (currentDealerIndexInActive === -1) currentDealerIndexInActive = 0; 
                    for (let i = 0; i < activePlayerIdsOrdered.length; i++) {
                        currentHandActivePlayerIdsOrder.push(activePlayerIdsOrdered[(currentDealerIndexInActive + 1 + i) % activePlayerIdsOrdered.length]);
                    }
                } else {
                     for (let i = 0; i < baseVisualOrder.length; i++) {
                        const visualOrderIdx = (dealerPosInVisual + 1 + i) % baseVisualOrder.length;
                        const pIdInVisual = baseVisualOrder[visualOrderIdx];
                        if (activePlayersInHandList.some(p => p.id === pIdInVisual)) {
                            currentHandActivePlayerIdsOrder.push(pIdInVisual);
                        }
                    }
                }
                currentHandActivePlayerIdsOrder = currentHandActivePlayerIdsOrder.filter(id => activePlayersInHandList.some(p => p.id === id)).slice(0, numActiveInHand);
                if (currentHandActivePlayerIdsOrder.length >= 1) { sbPlayer = players.find(p => p.id === currentHandActivePlayerIdsOrder[0]); if (sbPlayer) sbPlayer.isSB = true; }
                if (currentHandActivePlayerIdsOrder.length >= 2) { bbPlayer = players.find(p => p.id === currentHandActivePlayerIdsOrder[1]); if (bbPlayer) bbPlayer.isBB = true; }
            }

            players.forEach(p => { if (currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && (p.chips > 0 || p.isAllIn) ) { p.positionCategory = getPlayerPositionCategory(p, currentDealerPlayerId, numActiveInHand, currentHandActivePlayerIdsOrder); } else { p.positionCategory = "Folded/Out"; } });
            if (sbPlayer) { const sbAmountToPost = Math.min(SMALL_BLIND_AMOUNT_CONFIG, sbPlayer.chips); sbPlayer.chips -= sbAmountToPost; sbPlayer.betInRound = sbAmountToPost; pot += sbAmountToPost; displayMessage(`${sbPlayer.name} (SB) ${formatNumberWithCommas(sbAmountToPost)}원 자동 베팅.`, sbPlayer.type === "human" ? "player-action" : "ai-action"); if (sbPlayer.chips === 0 && sbAmountToPost > 0) sbPlayer.isAllIn = true; }
            if (bbPlayer) { const bbAmountToPost = Math.min(BIG_BLIND_AMOUNT_CONFIG, bbPlayer.chips); bbPlayer.chips -= bbAmountToPost; bbPlayer.betInRound = bbAmountToPost; pot += bbAmountToPost; displayMessage(`${bbPlayer.name} (BB) ${formatNumberWithCommas(bbAmountToPost)}원 자동 베팅.`, bbPlayer.type === "human" ? "player-action" : "ai-action"); if (bbPlayer.chips === 0 && bbAmountToPost > 0) bbPlayer.isAllIn = true; }
            currentBet = BIG_BLIND_AMOUNT_CONFIG;

            for (let i = 0; i < 2; i++) { for (const playerIdToDeal of currentHandActivePlayerIdsOrder) { const p = players.find(pl => pl.id === playerIdToDeal); if (p && !p.isFolded) { const newCard = dealCardFromDeck(p.type === "ai" && !isTutorialMode && !isAdminMode); p.cards.push(newCard); renderPlayerCard(p, newCard, p.type === "ai" && !isTutorialMode && !isAdminMode); await sleep(isTutorialMode ? 50 : 100); } } }

            gamePhase = "PREFLOP";
            if (currentHandActivePlayerIdsOrder.length > 0) {
                let firstToActOrderIndex = 0; 
                if (numActiveInHand === 2) { 
                    firstToActOrderIndex = 0;
                } else if (numActiveInHand > 2) { 
                    firstToActOrderIndex = 2 % currentHandActivePlayerIdsOrder.length;
                }
                currentTurnInOrderIndex = firstToActOrderIndex;
                let initialSearchOrderIndex = currentTurnInOrderIndex; let foundFirst = false;
                for(let i=0; i<currentHandActivePlayerIdsOrder.length; i++){ const pId = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]; const pObj = players.find(p=>p.id === pId); if(pObj && !pObj.isFolded && !pObj.isAllIn && pObj.chips > 0) { foundFirst = true; break; } currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length; if(currentTurnInOrderIndex === initialSearchOrderIndex && i > 0) break; }
                if(foundFirst){ currentPlayerIndex = players.findIndex(p => p.id === currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]); } else { currentPlayerIndex = -1; }
            } else { currentPlayerIndex = -1; }
            lastRaiserId = bbPlayer ? bbPlayer.id : (sbPlayer ? sbPlayer.id : -1) ;
            updateOverallUI();

            const activeNonAllInPlayers = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            if (currentPlayerIndex === -1 || activeNonAllInPlayers.length === 0) { await advanceGamePhase(); }
            else if (activeNonAllInPlayers.length === 1 && players[currentPlayerIndex] && players[currentPlayerIndex].isAllIn) { await advanceGamePhase(); }
            else { await startBettingRound(); }
        }

        async function startBettingRound() {
            players.forEach(p => { if (!p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; if (!p.isFolded) p.raisesThisRoundCount = 0; });
            displayMessage(`--- ${gamePhase} 라운드 시작 ---`, "game-event");

            if (gamePhase !== "PREFLOP") {
                currentTurnInOrderIndex = 0; 
                let initialSearchOrderIndex = currentTurnInOrderIndex; let foundFirst = false;
                for(let i=0; i<currentHandActivePlayerIdsOrder.length; i++){
                    const pId = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
                    const pObj = players.find(p=>p.id === pId);
                    if(pObj && !pObj.isFolded && !pObj.isAllIn && pObj.chips > 0) { foundFirst = true; break; }
                    currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length;
                    if(currentTurnInOrderIndex === initialSearchOrderIndex && i > 0 && !foundFirst) { currentPlayerIndex = -1; break; }
                }
                if(foundFirst){ currentPlayerIndex = players.findIndex(p => p.id === currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]); }
                else { currentPlayerIndex = -1; }
                players.forEach(p => { if(!p.isFolded && !p.isAllIn) p.betInRound = 0; }); 
                currentBet = 0; minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG; lastRaiserId = -1;
            }

            const activeForBetting = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            const allInPlayersThisRound = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && p.isAllIn);

            if (currentPlayerIndex === -1 || (activeForBetting.length === 0 && allInPlayersThisRound.length > 0) ) {
                displayMessage("모든 잔여 플레이어가 올인 상태거나 액션할 플레이어 없음. 다음 단계로 진행.", "game-event");
                await sleep(isTutorialMode ? 200 : 1000); await advanceGamePhase(); return;
            } else if (activeForBetting.length <=1 ) {
                const nonAllInCanAct = activeForBetting; let bettingStillPossible = false;
                if (nonAllInCanAct.length === 1) {
                    const actor = nonAllInCanAct[0];
                    bettingStillPossible = (currentBet > 0 && actor.betInRound < currentBet && actor.chips > 0) ||
                                           (gamePhase === "PREFLOP" && actor.isBB && currentBet === BIG_BLIND_AMOUNT_CONFIG && !actor.hasActedThisBettingRound && (lastRaiserId === actor.id || lastRaiserId === -1 || players.find(p=>p.id===lastRaiserId)?.isAllIn ) );
                }
                if (!bettingStillPossible) {
                    const isOnlyOnePlayerLeftOverall = players.filter(p => !p.isFolded).length === 1;
                    if(!isOnlyOnePlayerLeftOverall && activeForBetting.length <=1){
                        displayMessage("베팅할 플레이어가 한 명 이하. 다음 단계로 진행.", "game-event");
                        await sleep(isTutorialMode ? 200 : 1000); await advanceGamePhase(); return;
                    }
                }
            }
            updateOverallUI();

            if (isTutorialMode) {
                const currentStepInfo = tutorialMessages[tutorialStep];
                if (currentStepInfo && currentStepInfo.advanceAfterBettingRoundStart && (gamePhase === "PREFLOP" || gamePhase === "FLOP" || gamePhase === "TURN" || gamePhase === "RIVER" )) { // 특정 라운드 시작 시점 체크
                     await sleep(100); advanceTutorial(true);
                } else if (currentStepInfo && currentStepInfo.advanceAfterFlopDealt && gamePhase === "FLOP" && communityCards.length >=3 ) {
                     await sleep(100); advanceTutorial(true);
                }
            }
            await processPlayerTurn();
        }

        async function processPlayerTurn() {
            if (isTutorialMode) tutorialActionLock = false; 

            if (currentPlayerIndex === -1 || currentTurnInOrderIndex === -1 || currentHandActivePlayerIdsOrder.length === 0) {
                console.warn("processPlayerTurn: No current player. Advancing phase."); await advanceGamePhase(); return;
            }
            const currentPlayerIdToAct = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
            const currentPlayerObject = players.find(p => p.id === currentPlayerIdToAct);
            if (!currentPlayerObject || currentPlayerObject.isFolded || currentPlayerObject.isAllIn) {
                console.warn(`processPlayerTurn: Player ${currentPlayerIdToAct} cannot act. Switching.`);
                await switchToNextPlayerOrEndRound(); return;
            }
            currentPlayerIndex = players.findIndex(p => p.id === currentPlayerIdToAct); 
            displayMessage(`${currentPlayerObject.name}의 턴. (포지션: ${currentPlayerObject.positionCategory}) 현재 베팅액: ${formatNumberWithCommas(currentBet)}원`, "system-message");
            updateOverallUI();

            if (isTutorialMode) {
                const currentStepData = tutorialMessages[tutorialStep];
                if (currentPlayerObject.type === 'human' && currentStepData.actionType === 'USER_ACTION' && currentStepData.requiredPlayerAction) {
                    tutorialActionLock = false; 
                } else if (currentPlayerObject.type === 'ai' && currentStepData.aiScriptedAction) {
                    tutorialActionLock = true; 
                }
                updateActionButtonsForHuman(); 
            }

            if (currentPlayerObject.type === "human") {
                // Human turn
            } else { 
                const delay = isTutorialMode ? (AI_ACTION_BASE_DELAY_MS / 2 + 200 + Math.random() * 200) : (AI_ACTION_BASE_DELAY_MS + 800 + Math.random() * 1000);
                await sleep(delay);
                await handleAIAction(currentPlayerObject);
            }
        }

        async function handleHumanAction(actionType) {
            if (isTutorialMode && tutorialActionLock) {
                displayMessage("잠시만 기다려주세요...", "tutorial-message");
                return;
            }

            const humanPlayer = players[currentPlayerIndex];
            if (!humanPlayer || humanPlayer.type !== "human" || humanPlayer.isFolded || humanPlayer.isAllIn) {
                console.warn("Human action: invalid player/state.");
                if (!isTutorialMode) await switchToNextPlayerOrEndRound();
                return;
            }

            let actionAllowedByTutorial = true;
            let proceedWithAction = true;

            if (isTutorialMode) {
                const currentStepData = tutorialMessages[tutorialStep];
                if (currentStepData.actionType === 'USER_ACTION' && currentStepData.requiredPlayerAction) {
                    if (actionType !== currentStepData.requiredPlayerAction) {
                        actionAllowedByTutorial = false;
                        let expectedActionName = "";
                        if(currentStepData.requiredPlayerAction === "CHECK_CALL") expectedActionName = currentBet - humanPlayer.betInRound > 0 ? "콜" : "체크";
                        else if(currentStepData.requiredPlayerAction === "BET_RAISE") expectedActionName = currentBet > 0 ? "레이즈" : "벳";
                        else if(currentStepData.requiredPlayerAction === "FOLD") expectedActionName = "폴드";

                        tutorialText.innerHTML = `<strong>잘못된 행동입니다!</strong><br>튜토리얼 안내에 따라 <strong>'${expectedActionName}'</strong> 액션을 해주세요.<br><br>현재 지시: ${parseTutorialMessage(currentStepData.text)}`;
                        proceedWithAction = false;
                    } else {
                        if (actionType === 'BET_RAISE' && currentStepData.expectedBetAmount) {
                            const enteredAmount = parseInt(raiseInput.value);
                            if (enteredAmount !== currentStepData.expectedBetAmount) {
                                tutorialText.innerHTML = `<strong>금액이 다릅니다!</strong><br>${formatNumberWithCommas(currentStepData.expectedBetAmount)}원으로 설정하고 '${currentBet > 0 ? "레이즈" : "벳"}' 하세요.<br><br>현재 지시: ${parseTutorialMessage(currentStepData.text)}`;
                                proceedWithAction = false;
                            }
                        }
                    }
                }
                if (proceedWithAction) tutorialActionLock = true; 
            }

            if (!proceedWithAction) {
                humanPlayer.hasActedThisBettingRound = false; 
                updateActionButtonsForHuman(); 
                return;
            }

            humanPlayer.hasActedThisBettingRound = true;
            humanPlayer.previousAction = actionType; let actualBetMadeThisAction = 0;
            switch (actionType) {
                case 'FOLD': humanPlayer.isFolded = true; showEnhancedFeedback(humanPlayer.id, "폴드...", "feedback-fold"); displayMessage(`${humanPlayer.name} 폴드.`, "player-action"); break;
                case 'CHECK_CALL':
                    const amountToCall = currentBet - humanPlayer.betInRound;
                    if (amountToCall > 0) {
                        actualBetMadeThisAction = Math.min(amountToCall, humanPlayer.chips);
                        humanPlayer.chips -= actualBetMadeThisAction; humanPlayer.betInRound += actualBetMadeThisAction; pot += actualBetMadeThisAction;
                        showEnhancedFeedback(humanPlayer.id, "콜!", "feedback-call"); displayMessage(`${humanPlayer.name} ${formatNumberWithCommas(actualBetMadeThisAction)}원 콜 (총 ${formatNumberWithCommas(humanPlayer.betInRound)}원).`, "player-action");
                        if (humanPlayer.chips === 0 && actualBetMadeThisAction > 0) humanPlayer.isAllIn = true;
                    } else {
                        showEnhancedFeedback(humanPlayer.id, "체크", "feedback-check"); displayMessage(`${humanPlayer.name} 체크.`, "player-action");
                    }
                    break;
                case 'BET_RAISE':
                    let desiredTotalBet = parseInt(raiseInput.value);
                    if (isNaN(desiredTotalBet) || desiredTotalBet < 0) { displayMessage("유효한 금액 입력.", "system-message"); humanPlayer.hasActedThisBettingRound = false; tutorialActionLock = false; return; }
                    if (desiredTotalBet > humanPlayer.chips + humanPlayer.betInRound) desiredTotalBet = humanPlayer.chips + humanPlayer.betInRound;
                    actualBetMadeThisAction = desiredTotalBet - humanPlayer.betInRound;
                    if (actualBetMadeThisAction < 0) { displayMessage("잘못된 베팅 금액.", "system-message"); humanPlayer.hasActedThisBettingRound = false; tutorialActionLock = false; return; }
                    let feedbackText = ""; let feedbackClass = "";
                    if (currentBet === 0) { 
                        if (desiredTotalBet < minRaiseAmount && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) {
                            displayMessage(`최소 벳: ${formatNumberWithCommas(minRaiseAmount)}원.`, "system-message");
                            humanPlayer.hasActedThisBettingRound = false; tutorialActionLock = false; return;
                        }
                        feedbackText = "벳!"; feedbackClass = "feedback-bet";
                    } else { 
                        if (desiredTotalBet < currentBet + minRaiseAmount && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) {
                            displayMessage(`최소 레이즈 총액: ${formatNumberWithCommas(currentBet + minRaiseAmount)}원.`, "system-message");
                            humanPlayer.hasActedThisBettingRound = false; tutorialActionLock = false; return;
                        }
                        if (desiredTotalBet <= currentBet && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) {
                             displayMessage("레이즈는 현재 베팅보다 커야 함.", "system-message");
                             humanPlayer.hasActedThisBettingRound = false; tutorialActionLock = false; return;
                        }
                        feedbackText = "레이즈!"; feedbackClass = "feedback-raise";
                    }
                    humanPlayer.chips -= actualBetMadeThisAction; humanPlayer.betInRound += actualBetMadeThisAction; pot += actualBetMadeThisAction;
                    showEnhancedFeedback(humanPlayer.id, feedbackText, feedbackClass);
                    displayMessage(`${humanPlayer.name} ${formatNumberWithCommas(actualBetMadeThisAction)}원 ${currentBet === 0 ? '벳' : '레이즈'} (총 ${formatNumberWithCommas(humanPlayer.betInRound)}원).`, "player-action");
                    if (humanPlayer.chips === 0 && actualBetMadeThisAction > 0) humanPlayer.isAllIn = true;
                    if (humanPlayer.betInRound > currentBet) {
                        minRaiseAmount = humanPlayer.betInRound - currentBet; currentBet = humanPlayer.betInRound; lastRaiserId = humanPlayer.id;
                        players.forEach(p => { if (p.id !== humanPlayer.id && !p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
                    }
                    break;
            }
            updateOverallUI();
            if (isTutorialMode && actionAllowedByTutorial) {
                await sleep(100); 
                advanceTutorial(true); 
            }
            await switchToNextPlayerOrEndRound();
        }

        async function handleAIAction(aiPlayer) {
            if (aiPlayer.isFolded || aiPlayer.isAllIn) {
                await switchToNextPlayerOrEndRound(); return;
            }
            showAIActionEffect();
            aiPlayer.hasActedThisBettingRound = true;
            let decisionType = "FOLD"; let aiActionAmount = 0; let actualChipsToCommit = 0;
            let isBluffing = false;

            if (isTutorialMode) {
                const currentStepData = tutorialMessages[tutorialStep];
                if (currentStepData.aiScriptedAction) {
                    decisionType = currentStepData.aiScriptedAction.type;
                    if (decisionType === 'BET_RAISE' && currentStepData.aiScriptedAction.amount) {
                        aiActionAmount = currentStepData.aiScriptedAction.amount; 
                    } else if (decisionType === 'CHECK_CALL') {
                        aiActionAmount = currentBet - aiPlayer.betInRound; 
                        if (aiActionAmount < 0) aiActionAmount = 0;
                    }
                } else { 
                    if (currentBet - aiPlayer.betInRound <= 0) {
                        decisionType = "CHECK_CALL"; 
                        aiActionAmount = 0;
                    } else if ((currentBet - aiPlayer.betInRound) <= aiPlayer.chips / 5) { 
                        decisionType = "CHECK_CALL";
                        aiActionAmount = currentBet - aiPlayer.betInRound;
                    } else {
                        decisionType = "FOLD"; 
                    }
                }
                console.log(`Tutorial AI (${aiPlayer.name}) action: ${decisionType}, amount: ${aiActionAmount}`);
            } else {
                let amountToCall = currentBet - aiPlayer.betInRound;
                const holeCardStrength = evaluateHoleCards(aiPlayer.cards); const combinedHand = [...aiPlayer.cards, ...communityCards];
                const currentMadeHandDetails = getHandDetails(combinedHand); const drawPotential = evaluateDrawPotential(communityCards, aiPlayer.cards);
                const boardInfo = analyzeBoardTexture(communityCards); let effectiveHandStrength = currentMadeHandDetails.strength / 9;
                if (drawPotential.outs > 0) effectiveHandStrength += drawPotential.outs * 0.02 + Math.random() * 0.03;
                const activeOpponents = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && p.id !== aiPlayer.id && !p.isFolded && !p.isAllIn && p.chips > 0);
                const aggressionMod = aiPlayer.aggressionFactor; const tightnessMod = aiPlayer.tightnessFactor;
                const potOdds = calculatePotOdds(amountToCall, pot + currentBet);
                if (gamePhase === "PREFLOP") {
                    let openRaiseMultiplier = 2.2 + (1.0 / tightnessMod) + (aggressionMod - 0.9);
                    if (aiPlayer.positionCategory === "Early" || aiPlayer.positionCategory === "UTG" || aiPlayer.positionCategory === "SB_Dealer") { openRaiseMultiplier = Math.max(2.5, openRaiseMultiplier * 1.05); }
                    if (activeOpponents.length >= 2) { openRaiseMultiplier *= 0.85; } else if (activeOpponents.length === 1) { openRaiseMultiplier *= 0.95; }
                    let openRaiseSize = Math.floor(BIG_BLIND_AMOUNT_CONFIG * openRaiseMultiplier); openRaiseSize = Math.max(BIG_BLIND_AMOUNT_CONFIG * 2, openRaiseSize);
                    let callThreshold = 0.42 * tightnessMod; let raiseThreshold = 0.60 * tightnessMod * aggressionMod;
                    if (activeOpponents.length >= 2) { raiseThreshold *= 1.15; } else if (activeOpponents.length === 1) { raiseThreshold *= 1.05; }
                    const isFoldedToSBvsBB = aiPlayer.isSB && currentBet === BIG_BLIND_AMOUNT_CONFIG && activeOpponents.length === 1 && activeOpponents[0].isBB;
                    if (amountToCall === 0) {
                        if (isFoldedToSBvsBB) { let sbStealRaiseThreshold = 0.45 / tightnessMod * aggressionMod; let sbCompleteCallThreshold = 0.20 / tightnessMod; if (holeCardStrength > sbStealRaiseThreshold || (holeCardStrength > 0.33 && Math.random() < 0.35 * aggressionMod)) { decisionType = "BET_RAISE"; aiActionAmount = Math.floor(BIG_BLIND_AMOUNT_CONFIG * (2.2 + aggressionMod * 0.8 + Math.random() * 0.5)); aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; } else if (holeCardStrength > sbCompleteCallThreshold && ((aiPlayer.cards[0].suit === aiPlayer.cards[1].suit) || Math.abs(aiPlayer.cards[0].value - aiPlayer.cards[1].value) <= 4)) { decisionType = "CHECK_CALL"; aiActionAmount = BIG_BLIND_AMOUNT_CONFIG - aiPlayer.betInRound; if (aiActionAmount < 0) aiActionAmount = 0; } else { decisionType = "FOLD"; } }
                        else if (aiPlayer.isBB && currentBet === BIG_BLIND_AMOUNT_CONFIG && !players.some(p => p.id !== aiPlayer.id && p.betInRound > BIG_BLIND_AMOUNT_CONFIG && p.hasActedThisBettingRound && currentHandActivePlayerIdsOrder.indexOf(p.id) < currentHandActivePlayerIdsOrder.indexOf(aiPlayer.id) && !p.isFolded && !p.isAllIn)) { decisionType = "CHECK_CALL"; aiActionAmount = 0; }
                        else if (holeCardStrength > raiseThreshold) { decisionType = "BET_RAISE"; aiActionAmount = openRaiseSize; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; }
                        else if (holeCardStrength > (callThreshold * 0.70) && !aiPlayer.isSB && (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer") && Math.random() < (0.20 / tightnessMod)) { decisionType = "CHECK_CALL"; aiActionAmount = BIG_BLIND_AMOUNT_CONFIG - aiPlayer.betInRound; if(aiActionAmount < 0) aiActionAmount = 0; if(currentBet === 0 && aiPlayer.betInRound === 0) aiActionAmount = BIG_BLIND_AMOUNT_CONFIG; }
                        else { decisionType = "FOLD"; }
                    } else {
                        let threeBetThreshold = (0.75 / tightnessMod) * aggressionMod; let threeBetMultiplier = (1.7 + aggressionMod * 0.5);
                        if (activeOpponents.length >= 2) { threeBetThreshold *= 1.20; threeBetMultiplier *= 0.8;  } else if (activeOpponents.length === 1) { threeBetThreshold *= 1.10; threeBetMultiplier *= 0.9; }
                        let threeBetTargetAdditional = Math.floor((currentBet * threeBetMultiplier) + pot * 0.05); threeBetTargetAdditional = Math.max(minRaiseAmount, threeBetTargetAdditional);
                        let allowRaise = true;
                        if(activeOpponents.length === 1 && aiPlayer.raisesThisRoundCount >=1 && holeCardStrength < 0.80){ allowRaise = false; }
                        if (currentBet >= aiPlayer.chips + aiPlayer.betInRound) { decisionType = (holeCardStrength > (callThreshold * 0.80 / tightnessMod)) ? "CHECK_CALL" : "FOLD"; if (decisionType === "CHECK_CALL") aiActionAmount = amountToCall; }
                        else if (allowRaise && holeCardStrength > threeBetThreshold && amountToCall < aiPlayer.chips / 2.5) { decisionType = "BET_RAISE"; aiActionAmount = threeBetTargetAdditional; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; }
                        else if (holeCardStrength > callThreshold || (holeCardStrength > 0.22 && potOdds < 0.42 && activeOpponents.length <= 1) || (aiPlayer.isBB && potOdds < 0.48 && holeCardStrength > 0.18)) { decisionType = "CHECK_CALL"; aiActionAmount = amountToCall; }
                        else {
                            let bluff3BetChance = 0.12 * aggressionMod; if (activeOpponents.length >= 2) { bluff3BetChance *= 0.5; } else if (activeOpponents.length === 1) { bluff3BetChance *= 0.75;}
                            const lastRaiserPlayerObj = players.find(p => p.id === lastRaiserId);
                            if (allowRaise && lastRaiserPlayerObj && (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer" || aiPlayer.isBB) && (lastRaiserPlayerObj.positionCategory.includes("Early") || lastRaiserPlayerObj.positionCategory === "UTG" || lastRaiserPlayerObj.positionCategory.includes("Middle")) && Math.random() < bluff3BetChance && amountToCall < aiPlayer.chips / 2.8) { decisionType = "BET_RAISE"; aiActionAmount = Math.floor(threeBetTargetAdditional * (0.85 + Math.random() * 0.2)); isBluffing = true; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; }
                            else { decisionType = "FOLD"; }
                        }
                    }
                } else {
                    let valueBetStrength = 0.52 / tightnessMod; let semiBluffStrength = 0.28 / tightnessMod; let callStrength = 0.22 / tightnessMod; let checkRaiseStrength = 0.65 / tightnessMod * aggressionMod;
                    if (gamePhase === "FLOP" && lastRaiserId === aiPlayer.id && amountToCall === 0) { let cbetProb = (0.55 + 0.25 * aggressionMod); if (boardInfo.type === "dry_uncoordinated") cbetProb = Math.min(0.95, cbetProb * 1.3); else if (boardInfo.isWet) cbetProb *= 0.7; if (activeOpponents.length === 1) { if (boardInfo.highCardValue >= RANK_VALUES.Q && !boardInfo.isWet) cbetProb = Math.min(0.95, cbetProb * 1.15); } else if (activeOpponents.length > 1) { cbetProb *= (1 / (1 + 0.50 * (activeOpponents.length - 1))); } if (effectiveHandStrength > 0.45 || (drawPotential.outs >= 7 && Math.random() < 0.7) || Math.random() < cbetProb) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; let cbetSizeRatio = 0.35 + Math.random() * 0.30 * aggressionMod; if (boardInfo.isWet) cbetSizeRatio = Math.min(0.75, cbetSizeRatio * 1.2); if (activeOpponents.length > 1) cbetSizeRatio *= 0.8; aiActionAmount = Math.floor(pot * cbetSizeRatio); if (effectiveHandStrength < 0.4 && drawPotential.outs < 5 && Math.random() < cbetProb) isBluffing = true; } else { decisionType = "CHECK_CALL"; } }
                    else if (amountToCall === 0 && (gamePhase === "TURN" || gamePhase === "RIVER") && ((lastRaiserId !== aiPlayer.id && players.find(p=>p.id===lastRaiserId)?.previousAction === 'CHECK_CALL' && players.find(p=>p.id===lastRaiserId)?.betInRound === 0) || (lastRaiserId === -1 && players.filter(p=>currentHandActivePlayerIdsOrder.includes(p.id)).every(p => p.isFolded || p.isAllIn || (p.hasActedThisBettingRound && p.betInRound === 0) || p.id === aiPlayer.id)))) { let probeBetProb = 0.38 * aggressionMod; if(boardInfo.type === "dry_uncoordinated" || (boardInfo.type === "paired" && !boardInfo.isWet) ) probeBetProb = Math.min(0.8, probeBetProb * 1.25); if (activeOpponents.length > 0) { probeBetProb *= (1 / (1 + 0.3 * activeOpponents.length)); } if (effectiveHandStrength > 0.42 || (drawPotential.outs >= 5 && Math.random() < 0.6) || Math.random() < probeBetProb) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; let probeBetSizeRatio = 0.38 + Math.random() * 0.28 * aggressionMod; if (activeOpponents.length > 0) probeBetSizeRatio *= 0.85; aiActionAmount = Math.floor(pot * probeBetSizeRatio); if (effectiveHandStrength < 0.38 && drawPotential.outs < 4 && Math.random() < probeBetProb) isBluffing = true; } else { decisionType = "CHECK_CALL"; } }
                    else if (amountToCall === 0) { if (effectiveHandStrength > valueBetStrength) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; let valueBetSizeRatio = 0.48 + effectiveHandStrength * 0.30 * aggressionMod; if (boardInfo.isWet) valueBetSizeRatio = Math.min(0.8, valueBetSizeRatio * 1.15); if (activeOpponents.length > 1) valueBetSizeRatio *= 0.8; aiActionAmount = Math.floor(pot * valueBetSizeRatio); } else if (effectiveHandStrength > semiBluffStrength && (drawPotential.outs >= 5 || Math.random() < (0.33 * aggressionMod))) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; let semiBluffBetSizeRatio = 0.30 + Math.random() * 0.3 * aggressionMod; if (activeOpponents.length > 1) semiBluffBetSizeRatio *= 0.75; aiActionAmount = Math.floor(pot * semiBluffBetSizeRatio); if (effectiveHandStrength < 0.38 && drawPotential.outs < 8) isBluffing = true; } else { decisionType = "CHECK_CALL"; } }
                    else {
                        let allowRaise = true;
                        if (activeOpponents.length === 1 && aiPlayer.raisesThisRoundCount >= 1 && effectiveHandStrength < 0.85) { allowRaise = false; }
                        let checkRaiseProbMod = 1.0; if (activeOpponents.length >= 1) { checkRaiseProbMod = 1 / (1 + 0.3 * activeOpponents.length); }
                        if (allowRaise && (aiPlayer.positionCategory.includes("Early") || aiPlayer.positionCategory === "SB" || aiPlayer.positionCategory === "BB") && !aiPlayer.hasActedThisBettingRound && effectiveHandStrength > checkRaiseStrength && amountToCall < pot * 0.75 && Math.random() < (0.18 * aggressionMod * checkRaiseProbMod) && (!boardInfo.isWet || drawPotential.outs > 7)) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; let checkRaiseSizeMultiplier = 1.8 + aggressionMod * 0.8; if (activeOpponents.length >= 1) checkRaiseSizeMultiplier *= (0.85 / (1 + 0.05 * activeOpponents.length)); aiActionAmount = Math.floor(amountToCall * checkRaiseSizeMultiplier + pot * 0.2); if(effectiveHandStrength < (checkRaiseStrength * 0.8) && drawPotential.outs < 5) isBluffing = true; }
                        else if (currentBet >= aiPlayer.chips + aiPlayer.betInRound) { decisionType = (effectiveHandStrength > (callStrength * 0.85) + (drawPotential.outs * 0.018)) ? "CHECK_CALL" : "FOLD"; if (decisionType === "CHECK_CALL") aiActionAmount = amountToCall; }
                        else if (allowRaise && effectiveHandStrength > (valueBetStrength * 1.1) && amountToCall < aiPlayer.chips / 1.4) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; let valueRaiseMultiplier = 1.7 + aggressionMod * 0.75; if (activeOpponents.length >= 1) valueRaiseMultiplier *= (0.9 / (1 + 0.1 * activeOpponents.length)); if (activeOpponents.length === 1) valueRaiseMultiplier *= 0.9; aiActionAmount = Math.floor(amountToCall * valueRaiseMultiplier + pot * 0.22); }
                        else if (effectiveHandStrength > callStrength || (drawPotential.outs >= 8 && potOdds < 0.48) || (drawPotential.outs >=5 && potOdds < 0.40)) { decisionType = "CHECK_CALL"; aiActionAmount = amountToCall; }
                        else if (allowRaise && drawPotential.outs >= 7 && potOdds < (0.35 / tightnessMod) && Math.random() < (0.35 * aggressionMod) && !boardInfo.isPaired && gamePhase !== "RIVER") { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; let semiBluffRaiseMultiplier = 1.6 + aggressionMod * 0.6; if (activeOpponents.length >= 1) semiBluffRaiseMultiplier *= (0.8 / (1 + 0.1 * activeOpponents.length)); if (activeOpponents.length === 1) semiBluffRaiseMultiplier *= 0.9; aiActionAmount = Math.floor(amountToCall * semiBluffRaiseMultiplier + pot * 0.15); isBluffing = true; }
                        else { const spr = aiPlayer.chips > 0 ? pot / aiPlayer.chips : 100; if (spr < 1.5 && effectiveHandStrength > 0.12 && potOdds < 0.65) { decisionType = "CHECK_CALL"; aiActionAmount = amountToCall; } else { decisionType = "FOLD"; } }
                    }
                }
                if (decisionType === "FOLD" || (decisionType === "CHECK_CALL" && amountToCall === 0 && effectiveHandStrength < 0.35)) { let currentBluffChance = BLUFF_PROBABILITY_BASE * aggressionMod * (boardInfo.isWet ? 0.8 : 1.25); if (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer" || aiPlayer.positionCategory === "SB_Dealer") currentBluffChance *= 1.4; if (gamePhase === "RIVER") { const commSuitCounts = {}; communityCards.forEach(c => commSuitCounts[c.suit] = (commSuitCounts[c.suit] || 0) + 1); const flushPossible = Math.max(...Object.values(commSuitCounts).map(Number), 0); if (flushPossible === 4 && currentMadeHandDetails.strength < HAND_STRENGTH.FLUSH) { currentBluffChance *= 1.8; } else if (flushPossible === 3 && currentMadeHandDetails.strength < HAND_STRENGTH.FLUSH && drawPotential.type.includes("flush")) { currentBluffChance *= 1.6; } if (currentMadeHandDetails.strength < HAND_STRENGTH.ONE_PAIR && !boardInfo.isPaired && (boardInfo.type === "dry_uncoordinated" || boardInfo.highCardValue < RANK_VALUES["10"])) { currentBluffChance *= 1.6; } } if (activeOpponents.every(opp => opp.previousAction === 'CHECK_CALL' && opp.betInRound === 0 && opp.chips > 0)) { currentBluffChance *= 1.75; } const lastRaiserObjBluff = players.find(p=>p.id === lastRaiserId); if (lastRaiserObjBluff && lastRaiserObjBluff.previousAction === "CHECK_CALL" && lastRaiserObjBluff.betInRound === 0) { currentBluffChance *= 1.35; } if (activeOpponents.length >= 2) { currentBluffChance *= 0.4; } else if (activeOpponents.length === 1) { currentBluffChance *= 0.7; } if (Math.random() < currentBluffChance && amountToCall < aiPlayer.chips * 0.65) { isBluffing = true; decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount = (aiPlayer.raisesThisRoundCount || 0) + 1; let bluffSizeBase = (gamePhase === "RIVER") ? 0.60 : 0.50; let bluffRatio = bluffSizeBase + Math.random() * 0.35 * aggressionMod; if (activeOpponents.length >= 2) { bluffRatio *= 0.7; } else if (activeOpponents.length === 1) { bluffRatio *= 0.85; } aiActionAmount = Math.floor(pot * bluffRatio); } }
            }

            aiActionAmount = Math.max(0, Math.floor(aiActionAmount));
            if (decisionType === "BET_RAISE") {
                let intendedAddBet = aiActionAmount; 
                let intendedTotalAfterAIAction = aiPlayer.betInRound + intendedAddBet;
                if (currentBet === 0) { 
                    if (intendedTotalAfterAIAction < minRaiseAmount && intendedTotalAfterAIAction < aiPlayer.chips + aiPlayer.betInRound) {
                        if (!isTutorialMode && effectiveHandStrength < 0.3 && !isBluffing) { 
                            decisionType = "CHECK_CALL"; actualChipsToCommit = 0;
                        } else { 
                            actualChipsToCommit = Math.min(aiPlayer.chips, minRaiseAmount - aiPlayer.betInRound);
                            if (actualChipsToCommit < 0) actualChipsToCommit = 0;
                            if (aiPlayer.chips <= minRaiseAmount - aiPlayer.betInRound) actualChipsToCommit = aiPlayer.chips;
                            else if (aiPlayer.betInRound + actualChipsToCommit < minRaiseAmount && !isTutorialMode) {
                                decisionType = "CHECK_CALL"; actualChipsToCommit = 0;
                            }
                        }
                    } else { 
                        actualChipsToCommit = Math.min(aiPlayer.chips, intendedAddBet);
                    }
                } else { 
                    if (intendedTotalAfterAIAction < currentBet + minRaiseAmount && intendedTotalAfterAIAction < aiPlayer.chips + aiPlayer.betInRound) {
                        const amountToCallForAI = currentBet - aiPlayer.betInRound;
                        if (amountToCallForAI <= aiPlayer.chips && amountToCallForAI >= 0) { 
                            decisionType = "CHECK_CALL"; actualChipsToCommit = amountToCallForAI;
                        } else { 
                            decisionType = "FOLD"; actualChipsToCommit = 0;
                        }
                    } else if (intendedTotalAfterAIAction === currentBet) { 
                        decisionType = "CHECK_CALL"; actualChipsToCommit = currentBet - aiPlayer.betInRound;
                         if (actualChipsToCommit < 0) actualChipsToCommit = 0;
                         actualChipsToCommit = Math.min(aiPlayer.chips, actualChipsToCommit);
                    } else { 
                        actualChipsToCommit = Math.min(aiPlayer.chips, intendedAddBet);
                    }
                }
            } else if (decisionType === "CHECK_CALL") {
                actualChipsToCommit = Math.min(aiPlayer.chips, currentBet - aiPlayer.betInRound);
                if (actualChipsToCommit < 0) actualChipsToCommit = 0; 
            } else { 
                actualChipsToCommit = 0;
            }

            aiPlayer.previousAction = decisionType; let feedbackText = ""; let feedbackClass = "";
            switch (decisionType) {
                case 'FOLD':
                    if (currentBet - aiPlayer.betInRound > 0 || (isTutorialMode && currentBet > 0) ) { 
                        aiPlayer.isFolded = true; feedbackText = "폴드..."; feedbackClass = "feedback-fold";
                        displayMessage(`${aiPlayer.name} ${isTutorialMode ? "(튜토리얼 AI) " : ""}폴드.`, "ai-action");
                    } else { 
                        decisionType = "CHECK_CALL"; 
                        aiPlayer.previousAction = "CHECK_CALL";
                        feedbackText = "체크"; feedbackClass = "feedback-check";
                        displayMessage(`${aiPlayer.name} ${isTutorialMode ? "(튜토리얼 AI) " : ""}체크.`, "ai-action");
                        actualChipsToCommit = 0;
                    }
                    break;
                case 'CHECK_CALL':
                    const amountToCallForAICheckCall = currentBet - aiPlayer.betInRound;
                    if (amountToCallForAICheckCall > 0) { feedbackText = "콜!"; feedbackClass = "feedback-call"; }
                    else { feedbackText = "체크"; feedbackClass = "feedback-check"; actualChipsToCommit = 0; } 
                    aiPlayer.chips -= actualChipsToCommit; aiPlayer.betInRound += actualChipsToCommit; pot += actualChipsToCommit;
                    displayMessage(`${aiPlayer.name} ${isTutorialMode ? "(튜토리얼 AI) " : ""}${feedbackText.replace("!", "")} (총 ${formatNumberWithCommas(aiPlayer.betInRound)}원).`, "ai-action");
                    if (aiPlayer.chips <= 0 && actualChipsToCommit >= 0 && !(aiPlayer.chips === 0 && actualChipsToCommit === 0)) {
                        aiPlayer.isAllIn = true; if (aiPlayer.chips < 0) aiPlayer.chips = 0;
                    }
                    break;
                case 'BET_RAISE':
                    if (actualChipsToCommit <= 0 && !(aiPlayer.chips ===0 && aiPlayer.betInRound > 0 && currentBet === 0) ) { 
                        feedbackText = "체크"; feedbackClass = "feedback-check";
                        displayMessage(`${aiPlayer.name} ${isTutorialMode ? "(튜토리얼 AI) " : ""}체크 (내부 조정).`, "ai-action");
                        decisionType = "CHECK_CALL"; 
                        aiPlayer.previousAction = "CHECK_CALL";
                    } else {
                        if (currentBet === 0) { feedbackText = "벳!"; feedbackClass = "feedback-bet"; }
                        else { feedbackText = "레이즈!"; feedbackClass = "feedback-raise"; }
                        aiPlayer.chips -= actualChipsToCommit; aiPlayer.betInRound += actualChipsToCommit; pot += actualChipsToCommit;
                        displayMessage(`${aiPlayer.name} ${isTutorialMode ? "(튜토리얼 AI) " : ""}${formatNumberWithCommas(actualChipsToCommit)}원 ${currentBet === 0 ? '벳' : '레이즈'} (총 ${formatNumberWithCommas(aiPlayer.betInRound)}원).`, "ai-action");
                        if (aiPlayer.chips <= 0 && actualChipsToCommit > 0) {
                            aiPlayer.isAllIn = true; if (aiPlayer.chips < 0) aiPlayer.chips = 0;
                        }
                        if (aiPlayer.betInRound > currentBet) {
                            minRaiseAmount = Math.max(BIG_BLIND_AMOUNT_CONFIG, aiPlayer.betInRound - currentBet); currentBet = aiPlayer.betInRound; lastRaiserId = aiPlayer.id;
                            players.forEach(p => { if (p.id !== aiPlayer.id && !p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
                        }
                    }
                    break;
            }
            if (feedbackText && !aiPlayer.isFolded) { showEnhancedFeedback(aiPlayer.id, feedbackText, feedbackClass); }
            else if (aiPlayer.isFolded && feedbackText === "폴드...") { showEnhancedFeedback(aiPlayer.id, feedbackText, feedbackClass); }
            updateOverallUI();

            if (isTutorialMode) {
                const currentStepData = tutorialMessages[tutorialStep];
                if (currentStepData.actionType === "CLICK_NEXT_BUTTON" || (currentStepData.aiScriptedAction && !currentStepData.waitForPlayerResponseAfterAI)) {
                    await sleep(200); 
                    advanceTutorial(true);
                } else {
                    tutorialActionLock = false; 
                    updateActionButtonsForHuman();
                }
            }
            await switchToNextPlayerOrEndRound();
        }

        async function switchToNextPlayerOrEndRound() {
            const unfoldedPlayersStillInHand = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded);
            if (unfoldedPlayersStillInHand.length <= 1) {
                if (unfoldedPlayersStillInHand.length === 1) {
                    const winner = unfoldedPlayersStillInHand[0];
                    displayMessage(`${winner.name} 승리! 다른 플레이어 폴드. (팟: ${formatNumberWithCommas(pot)}원)`, "game-event");
                    winner.chips += pot;
                    pot = 0;
                    if (winner.type === 'human') { showEnhancedFeedback(winner.id, "승리!", "feedback-win"); }
                } else {
                    displayMessage("모든 플레이어가 폴드했습니다. 남은 팟은 다음 핸드로 이월되지 않습니다.", "game-event");
                    pot = 0;
                }
                await endCurrentHand(false); return;
            }

            let bettingOver = true;
            const activePlayersWhoCanBet = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            if (activePlayersWhoCanBet.length === 0 && unfoldedPlayersStillInHand.length > 0) {
                bettingOver = true; 
            } else if (activePlayersWhoCanBet.length > 0) {
                bettingOver = activePlayersWhoCanBet.every(p => p.hasActedThisBettingRound && (p.betInRound === currentBet || p.chips === 0));
                if (bettingOver && gamePhase === "PREFLOP" && currentBet === BIG_BLIND_AMOUNT_CONFIG) {
                    const bbPlayer = players.find(p => p.isBB && currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
                    if (bbPlayer && !bbPlayer.hasActedThisBettingRound) {
                        const isOnlyBbLeftToActOrNoRaise = players.filter(plr => currentHandActivePlayerIdsOrder.includes(plr.id) && !plr.isFolded && !plr.isAllIn && plr.id !== bbPlayer.id)
                                                              .every(plr => plr.hasActedThisBettingRound && plr.betInRound <= BIG_BLIND_AMOUNT_CONFIG);
                        if (isOnlyBbLeftToActOrNoRaise) {
                             bettingOver = false;
                        }
                    }
                }
            } else { 
                bettingOver = true;
            }

            if (bettingOver) {
                await advanceGamePhase();
            } else {
                let nextPlayerFound = false;
                let initialSearchOrderIndex = currentTurnInOrderIndex; 
                for (let i = 0; i < currentHandActivePlayerIdsOrder.length; i++) {
                    currentTurnInOrderIndex = (initialSearchOrderIndex + 1 + i) % currentHandActivePlayerIdsOrder.length; 
                    const nextPlayerIdToAct = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
                    const nextPlayer = players.find(p => p.id === nextPlayerIdToAct);
                    if (nextPlayer && !nextPlayer.isFolded && !nextPlayer.isAllIn && nextPlayer.chips > 0) {
                        if (!nextPlayer.hasActedThisBettingRound || (nextPlayer.betInRound < currentBet && nextPlayer.chips > 0)) {
                            currentPlayerIndex = players.findIndex(p => p.id === nextPlayerIdToAct);
                            nextPlayerFound = true;
                            break;
                        }
                    }
                }
                if (nextPlayerFound) {
                    await processPlayerTurn();
                } else {
                    console.warn("SwitchToNext: No specific next player found, but bettingOver is false. Advancing phase.");
                    await advanceGamePhase();
                }
            }
        }
        async function advanceGamePhase() {
            displayMessage(`--- ${gamePhase} 베팅 종료 ---`, "game-event");
            const activePlayersForShowdown = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded);
            const playersCanStillBet = activePlayersForShowdown.filter(p => !p.isAllIn && p.chips > 0);
            const playersAllInThisRound = activePlayersForShowdown.filter(p => p.isAllIn);
            let runOutBoard = false;
            if (activePlayersForShowdown.length > 0) {
                if (playersCanStillBet.length === 0 && playersAllInThisRound.length >= 1) { 
                    runOutBoard = true;
                } else if (playersCanStillBet.length === 1 && playersAllInThisRound.length >= 1) { 
                    const soleBettor = playersCanStillBet[0];
                    let allAllInsCoveredOrBettorCannotBetMore = true;
                    for (const pAllIn of playersAllInThisRound) {
                        if (soleBettor.betInRound < pAllIn.betInRound && soleBettor.chips > 0) {
                             allAllInsCoveredOrBettorCannotBetMore = false; break;
                        }
                    }
                    if (allAllInsCoveredOrBettorCannotBetMore) runOutBoard = true;
                }
            }

            if ( runOutBoard && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND") {
                displayMessage("올인 상황 또는 베팅 가능한 플레이어가 한명 이하. 남은 카드 공개.", "game-event");
                await revealAllAICards();
                const phasesToDeal = [];
                if (gamePhase === "PREFLOP" && communityCards.length < 3) phasesToDeal.push("FLOP");
                if ((gamePhase === "PREFLOP" || gamePhase === "FLOP") && communityCards.length < 4) phasesToDeal.push("TURN");
                if ((gamePhase === "PREFLOP" || gamePhase === "FLOP" || gamePhase === "TURN") && communityCards.length < 5) phasesToDeal.push("RIVER");
                for (const phase of phasesToDeal) {
                    if (communityCards.length < 5) { 
                         await dealCommunityCardsForPhase(phase, true); 
                    }
                }
                gamePhase = "SHOWDOWN";
            }

            if (gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND") {
                switch (gamePhase) {
                    case "PREFLOP": gamePhase = "FLOP"; await dealCommunityCardsForPhase("FLOP"); break;
                    case "FLOP": gamePhase = "TURN"; await dealCommunityCardsForPhase("TURN"); break;
                    case "TURN": gamePhase = "RIVER"; await dealCommunityCardsForPhase("RIVER"); break;
                    case "RIVER": gamePhase = "SHOWDOWN"; break;
                }
            }
            updateOverallUI();

            if (isTutorialMode) {
                const currentStepData = tutorialMessages[tutorialStep];
                if (currentStepData && currentStepData.advanceConditionMet && currentStepData.advanceConditionMet()) {
                    await sleep(100); advanceTutorial(true);
                } else if (currentStepData && currentStepData.advanceAfterFlopDealt && gamePhase === "FLOP" && communityCards.length >=3){
                    await sleep(100); advanceTutorial(true);
                }
            }

            if (gamePhase === "SHOWDOWN") {
                await determineWinner();
            } else if (gamePhase !== "END_HAND") {
                players.forEach(p => { if(!p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
                await startBettingRound();
            }
        }
        async function dealCommunityCardsForPhase(phaseToDeal, isRunOut = false) {
            if (!isRunOut) displayMessage(`--- ${phaseToDeal} 카드 공개 ---`, "game-event");
            if (communityCards.length < 5) burnCard(); 
            if (phaseToDeal === "FLOP" && communityCards.length < 3) {
                for (let i=0; i<3; i++) if(communityCards.length < 5) await dealAnimatedCommunityCard(dealCardFromDeck(false));
            } else if (phaseToDeal === "TURN" && communityCards.length < 4) {
                if(communityCards.length < 5) await dealAnimatedCommunityCard(dealCardFromDeck(false));
            } else if (phaseToDeal === "RIVER" && communityCards.length < 5) {
                if(communityCards.length < 5) await dealAnimatedCommunityCard(dealCardFromDeck(false));
            }
            if (!isRunOut) await sleep(isTutorialMode ? 200 : 500);
        }
        async function revealAllAICards() {
            for (const p of players) {
                if (p.type === 'ai' && !p.isFolded) {
                    for (const card of p.cards) {
                        if (card.hidden || (isTutorialMode && !card.revealed)) { 
                            revealHiddenCard(p, card);
                            await sleep(isTutorialMode ? 50 : 200);
                        }
                    }
                }
            }
            await sleep(isTutorialMode ? 100 : 400);
        }

        async function endCurrentHand(showdownOccurred) {
            gamePhase = "END_HAND";
            updateOverallUI(); 
            initialPlayerChipsBeforeHand = {}; players.forEach(p => initialPlayerChipsBeforeHand[p.id] = p.chips);
            initialNumPlayersForNextHandLogic = actualNumPlayersInCurrentGame; 

            if (!isTutorialMode) {
                numPlayersSelect.disabled = false;
                startingChipsInputEl.disabled = false;
                bigBlindInputEl.disabled = false;
                aiDelayInputEl.disabled = false;
                const activePlayersWithChips = players.filter(p => p.chips > 0);
                const humanPlayer = players.find(p => p.type === 'human');
                if (activePlayersWithChips.length <= 1) {
                    const winner = activePlayersWithChips.length > 0 ? activePlayersWithChips[0] : (players.length > 0 ? players.find(p => p.isAllIn && !p.isFolded && p.chips > 0) : null); 
                    displayMessage(winner ? `${winner.name} 최종 승리!` : "게임 종료 - 최종 승자 없음", "game-event");
                    if (winner && winner.type === 'human') { showEnhancedFeedback(winner.id, "최종 승리!", "feedback-win"); }
                    else if (humanPlayer && humanPlayer.chips <= 0 && !activePlayersWithChips.some(ap => ap.id === humanPlayer.id)) { showEnhancedFeedback(humanPlayer.id, "최종 패배ㅠㅠ", "feedback-lose"); }
                    controlButtonsArea.innerHTML = `<button id="start-game-button-main-end">새 게임</button><button id="continue-game-button">이어하기</button>`;
                    document.getElementById('start-game-button-main-end').addEventListener('click', () => { gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none'; initializeNewGame(false); });
                    const continueBtn = document.getElementById('continue-game-button');
                    if (players.length === 0 || players.filter(p=>p.chips > 0).length <=1) {
                         continueBtn.disabled = true; continueBtn.title = "이어하기 불가능: 칩을 가진 플레이어가 1명 이하입니다.";
                    } else {
                        continueBtn.disabled = (parseInt(numPlayersSelect.value) !== initialNumPlayersForNextHandLogic);
                        continueBtn.title = continueBtn.disabled ? "이어하기 불가능: 이전 게임과 인원수가 다릅니다." : "이전 칩 상태로 이어하기";
                    }
                    continueBtn.addEventListener('click', () => {
                        if (parseInt(numPlayersSelect.value) === initialNumPlayersForNextHandLogic && !(players.length === 0 || players.filter(p=>p.chips > 0).length <=1) ) {
                            players.forEach(p => {
                                p.chips = initialPlayerChipsBeforeHand[p.id] !== undefined ? initialPlayerChipsBeforeHand[p.id] : STARTING_CHIPS_CONFIG; 
                                if(p.chips > 0) p.isFolded = false; else p.isFolded = true;
                            });
                            actualNumPlayersInCurrentGame = initialNumPlayersForNextHandLogic; 
                            startNewHand();
                        } else { gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none'; initializeNewGame(false); }
                    });
                } else {
                    controlButtonsArea.innerHTML = `<button id="next-hand-button">다음 핸드</button><button id="start-game-button-main-mid" style="margin-left: 10px;">새 게임</button>`;
                    const nextHandBtn = document.getElementById('next-hand-button');
                    if (nextHandBtn) {
                        nextHandBtn.disabled = (parseInt(numPlayersSelect.value) !== initialNumPlayersForNextHandLogic);
                        nextHandBtn.title = nextHandBtn.disabled ? "다음 핸드 불가능: 이전 게임과 인원수가 다릅니다." : "다음 핸드 시작";
                        nextHandBtn.addEventListener('click', startNewHand);
                    }
                    document.getElementById('start-game-button-main-mid').addEventListener('click', () => { gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none'; initializeNewGame(false); });
                    startingChipsInputEl.disabled = true; bigBlindInputEl.disabled = true; aiDelayInputEl.disabled = true;
                }
            } else { 
                if (tutorialStep < tutorialMessages.length -1 && !tutorialMessages[tutorialStep].title.includes("완료")) { 
                     // 핸드 종료 후 다음 튜토리얼 단계가 있다면 여기서 advanceTutorial 호출 고려
                     // 예: advanceTutorial(); 
                } else if (tutorialStep >= tutorialMessages.length -1 || tutorialMessages[tutorialStep].title.includes("완료")) { 
                     displayTutorialStep(); // 완료 메시지 표시
                }
            }
            checkCallButton.disabled = true; betRaiseButton.disabled = true; raiseInput.disabled = true; foldButton.disabled = true;
        }

        function evaluateHoleCards(holeCards) { if (!holeCards || holeCards.length < 2) return 0; const [c1, c2] = holeCards; let score = (c1.value + c2.value) / 28; if (c1.rank === c2.rank) score += 0.35; if (c1.suit === c2.suit) score += 0.15; if (Math.abs(c1.value - c2.value) === 1 || (c1.value === RANK_VALUES.A && c2.value === RANK_VALUES["2"]) || (c2.value === RANK_VALUES.A && c1.value === RANK_VALUES["2"]) || (Math.abs(c1.value - c2.value) === 12 && (c1.value === RANK_VALUES.A || c2.value === RANK_VALUES.A))) { score += 0.1; } if (Math.abs(c1.value - c2.value) <= 4 && Math.abs(c1.value - c2.value) > 1) score += 0.05; return Math.min(1, score); }
        function evaluateDrawPotential(allCommunityCards, holeCards) { let outs = 0; let drawType = "none"; const revealedCommunityCards = allCommunityCards.filter(c => c.revealed !== false); const combinedCardsForDraw = [...holeCards, ...revealedCommunityCards]; if (combinedCardsForDraw.length < 4 || !holeCards || holeCards.length < 2) return { outs: 0, type: "none", hasFlushDraw: false, hasStraightDraw: false }; let hasFlushDraw = false; let hasStraightDraw = false; const suitCounts = {}; combinedCardsForDraw.forEach(c => suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1); for (const suit in suitCounts) { if (suitCounts[suit] === 4 && (holeCards[0].suit === suit || holeCards[1].suit === suit)) { outs += (13 - 4); drawType = drawType === "none" ? "flush" : "combo"; hasFlushDraw = true; break; } } const uniqueRanks = [...new Set(combinedCardsForDraw.map(c => c.value))].sort((a, b) => a - b); if (uniqueRanks.length >= 3) { for (let i = 0; i <= uniqueRanks.length - 4; i++) { const sub = uniqueRanks.slice(i, i + 4); if (sub[3] - sub[0] === 3) { const usesHoleCard = sub.some(r => holeCards.some(hc => hc.value === r)); if(usesHoleCard){ let tempOuts = 8; if (sub[0] === RANK_VALUES["2"]) tempOuts = 4; if (sub[3] === RANK_VALUES.A) tempOuts = 4; if (drawType === "flush" || drawType === "combo") tempOuts = Math.max(1, tempOuts - 2); outs += tempOuts; drawType = (drawType === "flush" || drawType === "combo_straight_gutshot") ? "combo_OESD_flush" : (drawType === "none" ? "straight_OESD" : "combo_OESD"); hasStraightDraw = true; break; } } } if (!hasStraightDraw && uniqueRanks.length >= 4) { for (let i = 0; i <= uniqueRanks.length - 4; i++) { const sub = uniqueRanks.slice(i, i + 4); const usesHoleCard = sub.some(r => holeCards.some(hc => hc.value === r)); if(!usesHoleCard) continue; if ((sub[3] - sub[0] === 4 && ( (sub[1]-sub[0] > 1 && sub[2]-sub[1]===1 && sub[3]-sub[2]===1) || (sub[1]-sub[0] ===1 && sub[2]-sub[1]>1 && sub[3]-sub[2]===1) || (sub[1]-sub[0] ===1 && sub[2]-sub[1]===1 && sub[3]-sub[2]>1) ))) { let tempOuts = 4; if (drawType === "flush" || drawType === "combo_OESD_flush") tempOuts = Math.max(1, tempOuts - 1); outs += tempOuts; drawType = (drawType === "flush" || drawType === "combo_OESD_flush") ? "combo_gutshot_flush" : (drawType === "none" ? "straight_gutshot" : "combo_gutshot"); hasStraightDraw = true; break;} } } const hasAce = uniqueRanks.includes(RANK_VALUES.A); const has2 = uniqueRanks.includes(RANK_VALUES["2"]); const has3 = uniqueRanks.includes(RANK_VALUES["3"]); const has4 = uniqueRanks.includes(RANK_VALUES["4"]); const has5 = uniqueRanks.includes(RANK_VALUES["5"]); if (hasAce && has2 && has3 && has4 && !has5 && (holeCards.some(hc=>[RANK_VALUES.A,2,3,4].includes(hc.value))) && !isStraightFiveHigh(uniqueRanks) && !hasStraightDraw) { outs +=4; drawType= drawType.includes("flush") ? "combo_gutshot_flush" : "straight_gutshot"; hasStraightDraw = true; } else if (has2 && has3 && has4 && has5 && !hasAce && (holeCards.some(hc=>[2,3,4,5].includes(hc.value))) && !isStraightFiveHigh(uniqueRanks) && !hasStraightDraw) { outs +=4; drawType= drawType.includes("flush") ? "combo_gutshot_flush" : "straight_gutshot"; hasStraightDraw = true; } } function isStraightFiveHigh(ranksArray) { return ranksArray.includes(RANK_VALUES.A)&&ranksArray.includes(RANK_VALUES["2"])&&ranksArray.includes(RANK_VALUES["3"])&&ranksArray.includes(RANK_VALUES["4"])&&ranksArray.includes(RANK_VALUES["5"]); } return { outs: Math.min(outs, 17), type: drawType, hasFlushDraw, hasStraightDraw }; }
        function getCombinations(arr, k) { if (k === 0) return [[]]; if (!arr || arr.length < k) return []; if (arr.length === k) return [arr]; if (k === 1) return arr.map(e => [e]); const first = arr[0]; const woFirst = getCombinations(arr.slice(1), k - 1); const wFirst = woFirst.map(c => [first, ...c]); const fRest = getCombinations(arr.slice(1), k); return [...wFirst, ...fRest]; }
        function getHandDetails(sevenCards) { if (!sevenCards || sevenCards.length < 5) { return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: [0], handName: "카드 부족", bestHand: [] };} const all5CardCombinations = getCombinations(sevenCards, 5); if (!all5CardCombinations || all5CardCombinations.length === 0) { return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: [0], handName: "조합 생성 실패", bestHand: [] };} let bestHandFound = { strength: -1, rankValues: [0], handName: "N/A", bestHand: [] }; for (const fiveCardArr of all5CardCombinations) { const currentEval = evaluateSingleHand(fiveCardArr); if (currentEval.strength > bestHandFound.strength) { bestHandFound = currentEval; } else if (currentEval.strength === bestHandFound.strength) { for (let i = 0; i < currentEval.rankValues.length; i++) { if (currentEval.rankValues[i] > bestHandFound.rankValues[i]) { bestHandFound = currentEval; break; } if (currentEval.rankValues[i] < bestHandFound.rankValues[i]) { break; }}}} return bestHandFound; }
        function evaluateSingleHand(fiveCards) { const ranks = fiveCards.map(c => c.value).sort((a, b) => b - a); const suits = fiveCards.map(c => c.suit); const isFlush = suits.every(s => s === suits[0]); const rankCounts = {}; ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1); let isStraight = false; const uniqueRanksForStraight = [...new Set(ranks)].sort((a,b) => b-a); if (uniqueRanksForStraight.length === 5 && uniqueRanksForStraight[0] - uniqueRanksForStraight[4] === 4) { isStraight = true; } let aceLowStraightRanks = null; if (uniqueRanksForStraight.length === 5 && uniqueRanksForStraight[0] === RANK_VALUES.A && uniqueRanksForStraight[1] === RANK_VALUES["5"] && uniqueRanksForStraight[2] === RANK_VALUES["4"] && uniqueRanksForStraight[3] === RANK_VALUES["3"] && uniqueRanksForStraight[4] === RANK_VALUES["2"]) { isStraight = true; aceLowStraightRanks = [RANK_VALUES["5"], RANK_VALUES["4"], RANK_VALUES["3"], RANK_VALUES["2"], RANK_VALUES.A_LOW]; } const finalRanksForComparison = aceLowStraightRanks ? aceLowStraightRanks : ranks.slice(0,5); if (isStraight && isFlush) { const isRoyal = ranks[0]===RANK_VALUES.A && ranks[1]===RANK_VALUES.K && ranks[2]===RANK_VALUES.Q && ranks[3]===RANK_VALUES.J && ranks[4]===RANK_VALUES["10"]; if(isRoyal) return { strength: HAND_STRENGTH.ROYAL_FLUSH, rankValues: ranks.slice(0,5), handName: "로열 플러쉬", bestHand: fiveCards }; return { strength: HAND_STRENGTH.STRAIGHT_FLUSH, rankValues: finalRanksForComparison, handName: "스트레이트 플러쉬", bestHand: fiveCards }; } const counts = Object.values(rankCounts); if (counts.includes(4)) { const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4)); const kicker = ranks.find(r => r !== quadRank); return { strength: HAND_STRENGTH.FOUR_OF_A_KIND, rankValues: [quadRank, kicker].filter(v=>v!==undefined), handName: "포카드", bestHand: fiveCards };} if (counts.includes(3) && counts.includes(2)) { const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3)); const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2)); return { strength: HAND_STRENGTH.FULL_HOUSE, rankValues: [tripRank, pairRank].sort((a,b)=>b-a), handName: "풀하우스", bestHand: fiveCards };} if (isFlush) { return { strength: HAND_STRENGTH.FLUSH, rankValues: ranks.slice(0,5), handName: "플러쉬", bestHand: fiveCards };} if (isStraight) { return { strength: HAND_STRENGTH.STRAIGHT, rankValues: finalRanksForComparison, handName: "스트레이트", bestHand: fiveCards };} if (counts.includes(3)) { const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3)); const kickers = ranks.filter(r => r !== tripRank).sort((a,b)=>b-a).slice(0,2); return { strength: HAND_STRENGTH.THREE_OF_A_KIND, rankValues: [tripRank, ...kickers], handName: "쓰리 오브 어 카인드", bestHand: fiveCards };} const numPairs = counts.filter(c => c === 2).length; if (numPairs === 2) { const pairRanksVal = []; for(const r in rankCounts) { if(rankCounts[r]===2) pairRanksVal.push(parseInt(r));} pairRanksVal.sort((a,b)=>b-a); const kicker = ranks.find(r=> !pairRanksVal.includes(r)); return { strength: HAND_STRENGTH.TWO_PAIR, rankValues: [...pairRanksVal, kicker].filter(v=>v!==undefined), handName: "투 페어", bestHand: fiveCards };} if (numPairs === 1) { const pairRankVal = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2)); const kickers = ranks.filter(r => r !== pairRankVal).sort((a,b)=>b-a).slice(0,3); return { strength: HAND_STRENGTH.ONE_PAIR, rankValues: [pairRankVal, ...kickers], handName: "원 페어", bestHand: fiveCards };} return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: ranks.slice(0,5), handName: "하이 카드", bestHand: fiveCards }; }

        async function determineWinner() {
            displayMessage("--- 쇼다운 ---", "game-event");
            await revealAllAICards();
            console.log("[DEBUG] determineWinner 시작. 현재 pot:", formatNumberWithCommas(pot), "raw pot:", pot);
            let eligiblePlayers = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && p.cards && p.cards.length > 0);
            console.log("[DEBUG] Eligible Players for Showdown:", eligiblePlayers.map(p => ({name: p.name, chips: formatNumberWithCommas(p.chips), betInRound: p.betInRound }) ));

            if (eligiblePlayers.length === 0) {
                displayMessage("쇼다운 할 플레이어가 없습니다.", "game-event");
                await endCurrentHand(true); return;
            }
            if (eligiblePlayers.length === 1) { 
                const soleWinner = eligiblePlayers[0];
                displayMessage(`${soleWinner.name}이(가) 단독으로 남아 팟 ${formatNumberWithCommas(pot)}원 획득.`, "game-event");
                soleWinner.chips = Math.max(0, soleWinner.chips + pot); // 칩 음수 방지
                pot = 0;
                if (soleWinner.type === 'human') showEnhancedFeedback(soleWinner.id, "승리!", "feedback-win");
                updateOverallUI();
                await endCurrentHand(true); return;
            }

            eligiblePlayers.forEach(p => {
                p.handDetails = getHandDetails([...p.cards, ...communityCards]);
                displayMessage(`${p.name}: ${p.handDetails.handName} (${p.handDetails.bestHand.map(c=>c.rank+c.suit).join(',')})`, "system-message");
            });
            eligiblePlayers.sort((a, b) => {
                if (b.handDetails.strength !== a.handDetails.strength) return b.handDetails.strength - a.handDetails.strength;
                for (let i = 0; i < a.handDetails.rankValues.length; i++) {
                    if (b.handDetails.rankValues[i] !== a.handDetails.rankValues[i]) return b.handDetails.rankValues[i] - a.handDetails.rankValues[i];
                }
                return 0; 
            });

            const bestHandStrength = eligiblePlayers[0].handDetails.strength;
            const bestHandValues = eligiblePlayers[0].handDetails.rankValues;
            const potentialWinners = eligiblePlayers.filter(p =>
                p.handDetails.strength === bestHandStrength &&
                p.handDetails.rankValues.every((val, index) => val === bestHandValues[index])
            );
            console.log("[DEBUG] Potential Winners (after sort):", potentialWinners.map(w => ({name: w.name, hand: w.handDetails.handName, chipsBefore: formatNumberWithCommas(w.chips), betInRound: w.betInRound }) ));

            let remainingPot = pot;
            const awardedPlayers = new Set(); 
            const sortedPlayersByBet = players
                .filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded) // 쇼다운 참여자만 고려
                .sort((a, b) => a.betInRound - b.betInRound); // 총 베팅액 기준 정렬 (올인 금액 적은 순)

            let lastBetLevel = 0;
            for (const playerAtBetLevel of sortedPlayersByBet) {
                if (remainingPot <= 0) break;
                if (playerAtBetLevel.betInRound <= lastBetLevel) continue; 

                const currentBetLevelCap = playerAtBetLevel.betInRound; // 현재 플레이어가 기여한 최대 금액
                let sidePot = 0;
                let contributorsToThisSidePot = []; // 이 사이드팟에 대한 자격이 있는 플레이어 (폴드 안한)

                players.forEach(p => {
                    if (currentHandActivePlayerIdsOrder.includes(p.id)) { // 핸드에 참여한 모든 플레이어 대상
                        // 각 플레이어가 이 레벨의 팟에 기여한 금액 계산
                        const effectiveContribution = Math.min(p.betInRound, currentBetLevelCap);
                        const contributionToThisPot = Math.max(0, effectiveContribution - lastBetLevel);
                        
                        if (contributionToThisPot > 0) {
                            sidePot += contributionToThisPot;
                            if (!p.isFolded) { // 폴드하지 않은 플레이어만 승자 후보
                                contributorsToThisSidePot.push(p);
                            }
                        }
                    }
                });
                
                if (sidePot > 0 && contributorsToThisSidePot.length > 0) {
                    console.log(`[DEBUG] Side Pot for bet level up to ${currentBetLevelCap} (contrib from ${lastBetLevel}): ${formatNumberWithCommas(sidePot)}. Eligible winners in this pot: ${contributorsToThisSidePot.map(p=>p.name)}`);
                    const winnersOfThisSidePot = potentialWinners.filter(pw => contributorsToThisSidePot.some(c => c.id === pw.id));
                    if (winnersOfThisSidePot.length > 0) {
                        const potShare = Math.floor(sidePot / winnersOfThisSidePot.length);
                        const oddChips = sidePot % winnersOfThisSidePot.length;
                        console.log(`[DEBUG] Winners of this side pot: ${winnersOfThisSidePot.map(w=>w.name)}. Share: ${formatNumberWithCommas(potShare)}`);
                        winnersOfThisSidePot.forEach((winner, index) => {
                            const chipsBeforeWin = winner.chips;
                            let winAmount = potShare;
                            if (index === 0 && oddChips > 0) { 
                                winAmount += oddChips;
                            }
                            winner.chips = Math.max(0, winner.chips + winAmount); // 칩 음수 방지
                            displayMessage(`${winner.name} 승리! 팟 ${formatNumberWithCommas(winAmount)}원 획득. (핸드: ${winner.handDetails.handName})`, "game-event");
                            console.log(`[DEBUG] ${winner.name} gets ${formatNumberWithCommas(winAmount)}. Chips: ${formatNumberWithCommas(chipsBeforeWin)} -> ${formatNumberWithCommas(winner.chips)}`);
                            awardedPlayers.add(winner.id);
                            if (winner.type === 'human') showEnhancedFeedback(winner.id, "승리!", "feedback-win");
                        });
                        remainingPot -= sidePot; 
                    } else {
                         console.warn("[DEBUG] No winners for a side pot. Pot remains.");
                    }
                }
                lastBetLevel = currentBetLevelCap;
            }

            if (remainingPot > 0) { 
                console.warn(`[DEBUG] Pot of ${formatNumberWithCommas(remainingPot)} remaining. Awarding to first potential winner(s).`);
                if (potentialWinners.length > 0) {
                    const potShareRemaining = Math.floor(remainingPot / potentialWinners.length);
                    const oddChipsRemaining = remainingPot % potentialWinners.length;
                    potentialWinners.forEach((winner, index) => {
                        let winAmount = potShareRemaining;
                        if (index === 0 && oddChipsRemaining > 0) winAmount += oddChipsRemaining;
                        winner.chips = Math.max(0, winner.chips + winAmount);
                        displayMessage(`${winner.name}에게 남은 팟 ${formatNumberWithCommas(winAmount)}원 추가 분배.`, "game-event");
                    });
                    remainingPot = 0;
                }
            }
            pot = 0; 

            const humanPlayer = players.find(p => p.type === 'human');
            if (humanPlayer && !awardedPlayers.has(humanPlayer.id) && eligiblePlayers.some(ep => ep.id === humanPlayer.id && !ep.isFolded)) {
                showEnhancedFeedback(humanPlayer.id, "패배ㅠㅠ...", "feedback-lose");
            }
            players.forEach(p => { if (p.chips < 0) p.chips = 0; });
            updateOverallUI();
            await endCurrentHand(true);
        }

        document.addEventListener('DOMContentLoaded', () => {
            populatePokerHandExamples();
            if (sbBbDisplayAreaEl) sbBbDisplayAreaEl.textContent = `SB: ${formatNumberWithCommas(SMALL_BLIND_AMOUNT_CONFIG)} / BB: ${formatNumberWithCommas(BIG_BLIND_AMOUNT_CONFIG)}`;
            if (potDisplayBottomRightEl) potDisplayBottomRightEl.textContent = `팟: ${formatNumberWithCommas(0)}원`;
            gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none';

            tutorialButton.addEventListener('click', startTutorial);
            tutorialCloseButton.addEventListener('click', () => endTutorial(true)); 
            tutorialNextButton.addEventListener('click', async () => {
                 if (isTutorialMode && tutorialMessages[tutorialStep]?.actionType === "CLICK_NEXT_BUTTON") {
                    const currentStep = tutorialMessages[tutorialStep];
                    advanceTutorial(); 
                 }
            });
            tutorialSkipStepButton.addEventListener('click', () => { 
                if (isTutorialMode && isAdminMode) {
                    displayMessage("관리자 권한으로 튜토리얼 지시를 건너뜁니다.", "admin-message");
                    tutorialActionLock = false; 
                    advanceTutorial(true); 
                }
            });
        });

        mainStartGameButton.addEventListener('click', () => {
            if (!isTutorialMode) { 
                initializeNewGame(false); 
            } else {
                 displayMessage("튜토리얼 진행 중입니다. 튜토리얼 안내창의 지시를 따라주세요.", "tutorial-message");
            }
        });

        checkCallButton.addEventListener('click', () => handleHumanAction('CHECK_CALL'));
        betRaiseButton.addEventListener('click', () => handleHumanAction('BET_RAISE'));
        foldButton.addEventListener('click', () => handleHumanAction('FOLD'));
        pokerHandsInfoBtn.addEventListener('mouseover', () => { pokerHandsGuideDiv.style.display = 'block'; });
        pokerHandsInfoBtn.addEventListener('mouseout', () => { pokerHandsGuideDiv.style.display = 'none'; });
        document.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); if (key === KONAMI_CODE[konamiCodePosition].toLowerCase()) { konamiCodePosition++; if (konamiCodePosition === KONAMI_CODE.length) { isAdminMode = !isAdminMode; displayMessage(`사기꾼 기능 ${isAdminMode ? "활성화" : "비활성화"} 되었습니다!`, "admin-message"); konamiCodePosition = 0; if (gamePhase !== "" && gamePhase !== "SETUP") updateOverallUI(); if(isTutorialMode) displayTutorialStep(); } } else { konamiCodePosition = 0; } });

        numPlayersSelect.addEventListener('change', () => {
            if (isTutorialMode) {
                numPlayersSelect.value = actualNumPlayersInCurrentGame.toString(); 
                return;
            }
            const selectedNumPlayers = parseInt(numPlayersSelect.value);
            const nextHandButton = document.getElementById('next-hand-button');
            const continueButton = document.getElementById('continue-game-button');
            if (gamePhase === "END_HAND") {
                if (selectedNumPlayers !== initialNumPlayersForNextHandLogic) {
                    if (nextHandButton) { nextHandButton.disabled = true; nextHandButton.title = "다음 핸드 불가능: 이전 게임과 인원수가 다릅니다."; }
                    if (continueButton) { continueButton.disabled = true; continueButton.title = "이어하기 불가능: 이전 게임과 인원수가 다릅니다."; }
                } else {
                    if (nextHandButton && players.filter(p=>p.chips > 0).length > 1) { nextHandButton.disabled = false; nextHandButton.title = "다음 핸드 시작"; }
                    if (continueButton && players.filter(p=>p.chips > 0).length > 1) { continueButton.disabled = false; continueButton.title = "이전 칩 상태로 이어하기"; }
                }
            }
        });
        for(let i=0; i<=3; i++) { const slot = getPlayerSlotElement(i); if(slot) slot.style.display = "none"; }
    </script>
</body>
</html>
