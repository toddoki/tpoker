<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>텍사스 홀덤 (최종 통합본) - v8.1 UI/UX & Responsive</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            background-color: #2c3e50;
            margin: 0;
            padding: 10px;
            color: #ecf0f1;
            height: 100vh;
            box-sizing: border-box;
            position: relative;
            overflow-x: hidden; /* 가로 스크롤 방지 */
        }

        .poker-hands-button {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background-color: #e67e22;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000; /* 다른 요소들보다 위에 오도록 */
        }

        .poker-hands-guide {
            display: none;
            position: fixed;
            top: 45px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 999; /* 버튼보다는 아래, 다른 게임 요소보다는 위 */
            width: 450px;
            max-width: 90vw;
            font-size: 0.9em;
        }
        .poker-hands-guide h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        .poker-hands-guide ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid; /* 그리드 레이아웃 사용 */
            grid-template-columns: repeat(2, 1fr); /* 동일한 너비의 2개의 열 생성 */
            gap: 10px; /* 열과 행 사이의 간격 */
        }

        .poker-hands-guide li {
            margin-bottom: 5px;
            padding: 8px; /* 각 항목에 약간의 패딩 추가 */
            background-color: rgba(0,0,0,0.03); /* 항목 배경 구분 */
            border-radius: 4px;
            display: flex; /* 내부 요소 정렬을 위해 flex 사용 */
            flex-direction: column; /* 내부 요소를 수직으로 쌓음 */
            justify-content: space-between; /* 공간 균등 배분 (설명과 카드 예시 사이) */
            min-height: 100px; /* 최소 높이 확보 (내용 적을 때 대비) */
        }

        /* 기존 .poker-hands-guide li { margin-bottom: 5px; }는 위의 내용으로 대체되거나,
           위의 .poker-hands-guide li 규칙에 margin-bottom이 포함되어 있으므로 중복될 수 있습니다.
           하나만 남기도록 정리해주세요. */

        /* 예시 카드 컨테이너의 상단 마진을 조금 줄여서 항목 내 공간 확보 */

        .current-hand-display {
            font-size: 0.8em;
            color: #f1c40f;
            margin-top: 5px;
            font-weight: bold;
        }

        .game-container {
            display: flex;
            width: 100%;
            height: calc(100vh - 20px); /* 전체 높이에서 body padding 고려 */
        }

        .main-game-area {
            flex-grow: 1;
            flex-basis: 68%; /* 테이블 영역 비율 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* 테이블 수직 중앙 정렬 */
            height: 100%;
            padding-right: 5px; /* 로그창과의 간격 */
            box-sizing: border-box;
        }

        .game-table {
            background-color: #006400;
            border-radius: 150px;
            padding: 15px;
            border: 5px solid #8B4513;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: auto auto auto;
            align-items: center;
            justify-items: center;
            width: 95%; /* 화면 너비에 따라 유동적으로 */
            max-width: 900px;
            position: relative;
            gap: 5px;
        }

        .ai-action-effect {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 150px; box-shadow: 0 0 30px 10px gold;
            opacity: 0; transition: opacity 0.3s ease-out;
            pointer-events: none; z-index: 10;
        }
        .ai-action-effect.active { opacity: 0.8; }

        .player-slot {
            border: 1px solid #4a6278;
            border-radius: 10px;
            padding: 5px;
            background-color: rgba(0,0,0,0.2);
            min-width: 150px;
            min-height: 115px;
            text-align: center;
            position: relative; /* 강화된 피드백 텍스트의 기준점 */
        }
        .player-slot.acting { box-shadow: 0 0 15px 5px gold; }
        .player-slot.folded { opacity: 0.5; background-color: rgba(100,100,100,0.3); }

        /* 강화된 액션/결과 피드백 */
        .enhanced-feedback {
            position: absolute;
            top: 50%; /* 슬롯의 세로 중앙 */
            left: calc(100% + 10px); /* 슬롯의 오른쪽 경계에서 10px 더 오른쪽으로 */
            transform: translateY(-50%) scale(0.8); /* 세로 중앙 정렬, 초기 크기 */
            font-size: 1.8em;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.7s ease-out, transform 0.7s ease-out, font-size 0.7s ease-out;
            z-index: 100;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: rgba(0,0,0,0.1);
        }
        .enhanced-feedback.show {
            opacity: 1;
            transform: translateY(-50%) scale(1.1); /* 등장 시 크기 변화 */
            font-size: 2.2em;
        }
        .enhanced-feedback.fade-out {
            opacity: 0;
            transform: translateY(-50%) translateX(10px) scale(0.7); /* 사라질 때 오른쪽으로 살짝 이동하며 작아짐 */
            font-size: 1.5em;
        }
        .feedback-raise { color: #e74c3c; border: 2px solid #c0392b; }
        .feedback-call { color: #2ecc71; border: 2px solid #27ae60; }
        .feedback-bet { color: #f39c12; border: 2px solid #e67e22; }
        .feedback-check { color: #3498db; border: 2px solid #2980b9; }
        .feedback-fold { color: #95a5a6; border: 2px solid #7f8c8d; }
        .feedback-win { color: #f1c40f; border: 2px solid #f39c12; font-size: 2.5em !important; } /* 승리는 더 크게 */
        .feedback-lose { color: #7f8c8d; border: 2px solid #34495e; font-style: italic; }


        #player-slot-0 { grid-column: 2 / 3; grid-row: 3 / 4; align-self: end; }
        #player-slot-1 { grid-column: 2 / 3; grid-row: 1 / 2; align-self: start; }
        #player-slot-2 { grid-column: 1 / 2; grid-row: 2 / 3; justify-self: start; }
        #player-slot-3 { grid-column: 3 / 4; grid-row: 2 / 3; justify-self: end; }

        .community-cards-area {
            grid-column: 2 / 3; grid-row: 2 / 3;
            text-align: center; width: 100%;
        }

        .cards-container { display: flex; justify-content: center; gap: 5px; margin-top: 5px; perspective: 1000px; }
        .card {
            width: 50px; height: 75px; border: 1px solid #000; border-radius: 4px;
            font-size: 14px; font-weight: bold; background-color: white;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3); position: relative;
            transform-style: preserve-3d; transition: transform 0.6s, opacity 0.3s;
            opacity: 0;
        }
        .card.hidden .card-front { transform: rotateY(180deg); }
        .card.hidden .card-back { transform: rotateY(0deg); }
        .card.is-dealt { opacity: 1; }
        .card.is-flipping .card-front { transform: rotateY(0deg); }
        .card.is-flipping .card-back { transform: rotateY(-180deg); }

        .card-face {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            display: flex; flex-direction: column; justify-content: space-around;
            align-items: center; border-radius: 4px;
        }
        .card-front { background-color: white; transform: rotateY(0deg); }
        .card-back {
            background-color: #6c757d;
            background-image: repeating-linear-gradient(45deg, #5a6268, #5a6268 6px, #6c757d 6px, #6c757d 12px);
            transform: rotateY(180deg);
        }
        .card .rank { font-size: 18px; } .card .suit { font-size: 16px; }
        .suit-♠, .suit-♣ { color: black; } .suit-♥, .suit-♦ { color: red; }

        .chips-display, .dealer-chip-ui, .blind-chip-ui {
            background-color: #f5f5dc; padding: 5px 10px; border-radius: 15px;
            font-size: 13px; border: 1px solid #d2b48c; margin-top: 3px;
            display: inline-block; color: #333;
        }
        .dealer-chip-ui { background-color: #FFD700; color: black; font-weight: bold; padding: 3px 6px; font-size: 9px; margin-left: 5px; }
        .blind-chip-ui { background-color: #7f8c8d; color: white; font-weight: bold; padding: 3px 6px; font-size: 9px; margin-left: 3px;}

        .player-name-display { font-weight: bold; color: white; margin-bottom: 3px; }

        .actions-area {
            grid-column: 1 / 4; grid-row: 4 / 5; margin: 10px 0; display: flex;
            gap: 8px; flex-wrap: wrap; justify-content: center;
        }
        .actions-area button, .game-controls button {
            padding: 8px 12px; font-size: 14px; cursor: pointer;
            background-color: #4CAF50; color: white; border: none;
            border-radius: 5px; transition: background-color 0.3s;
        }
        .actions-area button:hover, .game-controls button:hover { background-color: #45a049; }
        .actions-area button:disabled { background-color: #7f8c8d; cursor: not-allowed; }
        #raise-input { padding: 8px; font-size: 14px; width: 80px; border-radius: 5px; border: 1px solid #ccc; }

        .bet-amount-display {
            background-color: rgba(0,0,0,0.7); color: white; padding: 2px 6px;
            border-radius: 5px; font-size: 11px; margin-top: 3px; display: inline-block;
        }

        .right-panel {
            flex-basis: 32%; /* 로그창 영역 비율 */
            min-width: 280px; /* 최소 너비 보장 */
            height: calc(100vh - 20px);
            margin-left: 5px; /* 테이블과의 간격 */
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .chat-area {
            flex-grow: 1;
            background-color: #34495e; padding: 10px;
            border-radius: 8px; box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; box-sizing: border-box;
            min-height: 200px;
        }
        .chat-area h3 { margin-top: 0; color: #ecf0f1; text-align: center; border-bottom: 1px solid #7f8c8d; padding-bottom: 5px; }
        .message-log { flex-grow: 1; overflow-y: auto; font-size: 0.9em; line-height: 1.4; }
        .message-log p { margin: 5px 0; padding: 3px; border-bottom: 1px dashed #4a6278; }
        .message-log p:last-child { border-bottom: none; }
        .message-log .player-action { color: #2ecc71; } .message-log .ai-action { color: #e74c3c; }
        .message-log .game-event { color: #f1c40f; } .message-log .system-message { color: #bdc3c7; }
        .admin-message { color: #e67e22; font-weight: bold;}

        .game-info-bottom-right {
            padding: 10px;
            background-color: #1e2b37;
            border-radius: 8px;
            margin-top: 10px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            text-align: center;
        }
        .game-info-bottom-right div {
            font-size: 1.1em;
            font-weight: bold;
            color: #ecf0f1;
            padding: 6px 0;
            border-bottom: 1px solid #34495e;
        }
         .game-info-bottom-right div:last-child {
            border-bottom: none;
        }
        #pot-display-bottom-right { color: #f1c40f; }
        #sb-bb-display-area { color: #bdc3c7; }


        .game-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 10px; padding: 10px; }
        .player-setup { display: flex; gap: 10px; align-items: center; margin-bottom:10px; }

        .game-settings-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        .game-settings-inputs label {
            font-size: 0.9em;
        }
        .game-settings-inputs input[type="number"] {
            width: 70px;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #7f8c8d;
            background-color: #ecf0f1;
            color: #2c3e50;
        }

        .end-game-buttons { display: flex; gap: 10px; }
        .end-game-buttons button#continue-game-button { background-color: #3498db; }
        .end-game-buttons button#start-game-button-main { background-color: #27ae60; }

        /* 모바일 등 작은 화면 대응 */
        @media (max-width: 768px) {
            body {
                /* flex-direction: column; /* 전체를 수직으로 쌓을 수도 있음, 하지만 game-container에서 처리 */
                height: auto; /* 스크롤 가능하게 */
                padding: 5px;
            }
            .game-container {
                flex-direction: column;
                height: auto;
            }
            .main-game-area {
                flex-basis: auto; /* 비율 무시 */
                width: 100%;
                order: 1; /* 테이블을 먼저 */
                padding-right: 0;
            }
            .right-panel {
                flex-basis: auto; /* 비율 무시 */
                width: 100%;
                margin-left: 0;
                margin-top: 15px; /* 테이블과의 간격 */
                height: 250px; /* 로그창 높이 고정 또는 비율 */
                order: 2; /* 로그창을 나중에 */
            }
            .game-table {
                border-radius: 50px; /* 모바일에서는 타원형 줄이기 */
                padding: 10px;
                gap: 3px;
            }
            .player-slot {
                min-width: 100px;
                min-height: 90px; /* 모바일에서 슬롯 높이 약간 줄임 */
                padding: 3px;
            }
            .card {
                width: 40px; height: 60px; font-size: 12px;
            }
            .card .rank { font-size: 14px; } .card .suit { font-size: 12px; }

            .actions-area { margin: 5px 0; gap: 5px; }
            .actions-area button {
                padding: 8px 6px; /* 버튼 패딩 줄임 */
                font-size: 12px;
            }
            #raise-input {
                padding: 8px;
                width: 50px; /* 입력창 크기 줄임 */
                font-size: 12px;
            }
            .poker-hands-button { font-size: 0.8em; padding: 6px 8px; }
            .poker-hands-guide { width: 200px; font-size: 0.8em; padding: 10px; }
            .enhanced-feedback { font-size: 1.5em !important; } /* 모바일에서 피드백 텍스트 크기 기본값 줄임 */
            .enhanced-feedback {
                font-size: 1.3em !important; /* 모바일에서 피드백 텍스트 크기 기본값 더 줄임 */
                left: calc(100% + 5px); /* 오른쪽 간격 줄임 */
            }
            .enhanced-feedback.show {
                font-size: 1.6em !important;
            }
            .enhanced-feedback.fade-out {
                font-size: 1.1em !important;
                transform: translateY(-50%) translateX(5px) scale(0.7); /* 오른쪽 이동폭 줄임 */
            }
            .feedback-win { font-size: 2em !important; }
        }
         @media (max-width: 480px) { /* 더 작은 화면 */
            .player-slot {
                min-width: 80px;
                min-height: 80px;
            }
            .chips-display { font-size: 11px; padding: 3px 6px;}
            .dealer-chip-ui, .blind-chip-ui { font-size: 8px; padding: 2px 4px;}
            .current-hand-display { font-size: 0.7em; }
            .community-cards-area h2 { font-size: 1.2em; }
         }
        .poker-hands-guide .hand-example-cards {
            display: flex;
            justify-content: center; /* 카드들을 중앙 정렬 */
            gap: 2px; /* 카드 간의 아주 작은 간격 */
            margin-top: 5px; /* 설명과의 간격 */
            padding: 3px;
            background-color: rgba(0, 80, 0, 0.1); /* 카드 배경과 구분되는 은은한 배경 */
            border-radius: 3px;
        }

        /* 족보 안내창 내부의 카드에만 적용되는 스타일 */
        .poker-hands-guide .card {
            width: 30px;       /* 카드 너비 축소 */
            height: 45px;      /* 카드 높이 축소 */
            font-size: 8px;    /* 카드 내부 글자 크기 축소 */
            box-shadow: 1px 1px 2px rgba(0,0,0,0.2); /* 그림자 약간 줄임 */
            border-radius: 3px;/* 테두리 둥글기 약간 줄임 */
            opacity: 1 !important; /* 항상 보이도록 강제 (is-dealt 등 클래스 영향 무시) */
            position: relative; /* 내부 rank, suit 위치 기준 */
            transform-style: flat; /* 3D 효과 불필요 */
            background-color: white; /* 명시적 흰색 배경 */
        }

        .poker-hands-guide .card .card-face { /* 예시 카드에서는 앞면만 필요 */
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        .poker-hands-guide .card .card-front {
            transform: rotateY(0deg) !important; /* 항상 앞면 */
            backface-visibility: hidden;
        }
        .poker-hands-guide .card .card-back {
            display: none !important; /* 뒷면은 완전히 숨김 */
        }


        .poker-hands-guide .card .rank {
            font-size: 12px;   /* 랭크(숫자) 글자 크기 */
            font-weight: bold;
            line-height: 1;
        }
        .poker-hands-guide .card .suit {
            font-size: 10px;   /* 슈트(모양) 글자 크기 */
            line-height: 1;
        }
    </style>
</head>
<body>
    <button class="poker-hands-button" id="poker-hands-info-btn">포커 족보</button>
        <div class="poker-hands-guide" id="poker-hands-guide-div">
        <h4>포커 족보 (높은 순)</h4>
        <ul>
            <li><b>로열 플러쉬</b> (Royal Flush): 같은 무늬 A-K-Q-J-10
                <div class="hand-example-cards" data-hand-name="royal-flush"></div>
            </li>
            <li><b>스트레이트 플러쉬</b> (Straight Flush): 같은 무늬 연속 숫자
                <div class="hand-example-cards" data-hand-name="straight-flush"></div>
            </li>
            <li><b>포카드</b> (Four of a Kind): 같은 숫자 4장
                <div class="hand-example-cards" data-hand-name="four-of-a-kind"></div>
            </li>
            <li><b>풀하우스</b> (Full House): 트리플 + 원 페어
                <div class="hand-example-cards" data-hand-name="full-house"></div>
            </li>
            <li><b>플러쉬</b> (Flush): 같은 무늬 5장
                <div class="hand-example-cards" data-hand-name="flush"></div>
            </li>
            <li><b>스트레이트</b> (Straight): 연속된 숫자 5장
                <div class="hand-example-cards" data-hand-name="straight"></div>
            </li>
            <li><b>트리플</b> (Three of a Kind): 같은 숫자 3장
                <div class="hand-example-cards" data-hand-name="three-of-a-kind"></div>
            </li>
            <li><b>투 페어</b> (Two Pair): 페어 2쌍
                <div class="hand-example-cards" data-hand-name="two-pair"></div>
            </li>
            <li><b>원 페어</b> (One Pair): 페어 1쌍
                <div class="hand-example-cards" data-hand-name="one-pair"></div>
            </li>
            <li><b>하이 카드</b> (High Card): 위 족보에 해당 없을 시 가장 높은 카드
                <div class="hand-example-cards" data-hand-name="high-card"></div>
            </li>
        </ul>
    </div>

    <div class="game-container">
        <div class="main-game-area">
            <div class="game-table">
                <div id="ai-action-effect-indicator" class="ai-action-effect"></div>
                <div id="player-slot-1" class="player-slot" style="display:none;"></div>
                <div id="player-slot-2" class="player-slot" style="display:none;"></div>
                <div id="player-slot-3" class="player-slot" style="display:none;"></div>
                <div class="community-cards-area">
                    <h2>커뮤니티 카드</h2>
                    <div id="community-cards" class="cards-container"></div>
                </div>
                <div id="player-slot-0" class="player-slot"></div>
                <div class="actions-area">
                    <button id="check-call-button">체크</button>
                    <button id="bet-raise-button">벳</button>
                    <input type="number" id="raise-input" value="0" min="0">
                    <button id="fold-button">폴드</button>
                </div>
            </div>
            <div class="game-controls">
                <div class="player-setup">
                    <label for="num-players-select">참가 인원 (AI 포함):</label>
                    <select id="num-players-select">
                        <option value="2" selected>2명</option>
                        <option value="3">3명</option>
                        <option value="4">4명</option>
                    </select>
                </div>
                <div class="game-settings-inputs">
                    <label for="starting-chips-input">시작 칩:</label>
                    <input type="number" id="starting-chips-input" placeholder="1000" min="100">
                    <label for="big-blind-input">BB 금액:</label>
                    <input type="number" id="big-blind-input" placeholder="20" min="2">
                </div>
                <div id="control-buttons-area" class="end-game-buttons">
                    <button id="start-game-button-main">새 게임</button>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="chat-area">
                <h3>게임 로그</h3>
                <div id="message-log" class="message-log">
                    <p class="system-message">텍사스 홀덤 게임에 오신 것을 환영합니다!</p>
                </div>
            </div>
            <div class="game-info-bottom-right">
                <div id="pot-display-bottom-right">팟: 0원</div>
                <div id="sb-bb-display-area">SB: 10 / BB: 20</div>
            </div>
        </div>
    </div>

    <script>
        const SUITS = ["♠", "♥", "♦", "♣"];
        const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
        const RANK_VALUES = { "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, "J": 11, "Q": 12, "K": 13, "A": 14, "A_LOW": 1 };
        const HAND_STRENGTH = { HIGH_CARD: 0, ONE_PAIR: 1, TWO_PAIR: 2, THREE_OF_A_KIND: 3, STRAIGHT: 4, FLUSH: 5, FULL_HOUSE: 6, FOUR_OF_A_KIND: 7, STRAIGHT_FLUSH: 8, ROYAL_FLUSH: 9 };

        let STARTING_CHIPS_CONFIG = 1000;
        let BIG_BLIND_AMOUNT_CONFIG = 20;
        let SMALL_BLIND_AMOUNT_CONFIG = 10;

        const BLUFF_PROBABILITY_BASE = 0.09;
        const KONAMI_CODE = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
        const VISUAL_ORDER_RULES = {
            4: [1, 2, 0, 3],
            3: [1, 2, 0],
            2: []
        };

        let deck = [], communityCards = [], players = [];
        let pot = 0, currentBet = 0, minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG;
        let gamePhase = "", currentPlayerIndex = -1, dealerIndex = -1;
        let currentHandActivePlayerIdsOrder = [], currentTurnInOrderIndex = -1;
        let lastRaiserId = -1, actualNumPlayersInCurrentGame = 0;
        let isAdminMode = false, konamiCodePosition = 0;

        const communityCardsDiv = document.getElementById('community-cards');
        const potDisplayBottomRightEl = document.getElementById('pot-display-bottom-right');
        const sbBbDisplayAreaEl = document.getElementById('sb-bb-display-area');
        const messageLogDiv = document.getElementById('message-log');
        const checkCallButton = document.getElementById('check-call-button');
        const betRaiseButton = document.getElementById('bet-raise-button');
        const raiseInput = document.getElementById('raise-input');
        const foldButton = document.getElementById('fold-button');
        const mainStartGameButton = document.getElementById('start-game-button-main');
        const controlButtonsArea = document.getElementById('control-buttons-area');
        const numPlayersSelect = document.getElementById('num-players-select');
        const aiActionEffectIndicator = document.getElementById('ai-action-effect-indicator');
        const pokerHandsInfoBtn = document.getElementById('poker-hands-info-btn');
        const pokerHandsGuideDiv = document.getElementById('poker-hands-guide-div');
        const startingChipsInputEl = document.getElementById('starting-chips-input');
        const bigBlindInputEl = document.getElementById('big-blind-input');
        // 포커 족보 예시 카드 데이터
        const pokerHandExamples = {
            "royal-flush": [
                { rank: "A", suit: "♠" }, { rank: "K", suit: "♠" }, { rank: "Q", suit: "♠" }, { rank: "J", suit: "♠" }, { rank: "10", suit: "♠" }
            ],
            "straight-flush": [
                { rank: "9", suit: "♥" }, { rank: "8", suit: "♥" }, { rank: "7", suit: "♥" }, { rank: "6", suit: "♥" }, { rank: "5", suit: "♥" }
            ],
            "four-of-a-kind": [
                { rank: "A", suit: "♦" }, { rank: "A", suit: "♣" }, { rank: "A", suit: "♥" }, { rank: "A", suit: "♠" }, { rank: "K", suit: "♠" }
            ],
            "full-house": [
                { rank: "K", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "K", suit: "♥" }, { rank: "7", suit: "♣" }, { rank: "7", suit: "♦" }
            ],
            "flush": [
                { rank: "A", suit: "♣" }, { rank: "J", suit: "♣" }, { rank: "9", suit: "♣" }, { rank: "5", suit: "♣" }, { rank: "3", suit: "♣" }
            ],
            "straight": [
                { rank: "A", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "Q", suit: "♥" }, { rank: "J", suit: "♣" }, { rank: "10", suit: "♠" }
            ],
            "three-of-a-kind": [
                { rank: "Q", suit: "♠" }, { rank: "Q", suit: "♦" }, { rank: "Q", suit: "♥" }, { rank: "A", suit: "♣" }, { rank: "K", suit: "♦" }
            ],
            "two-pair": [
                { rank: "J", suit: "♠" }, { rank: "J", suit: "♦" }, { rank: "8", suit: "♥" }, { rank: "8", suit: "♣" }, { rank: "A", suit: "♦" }
            ],
            "one-pair": [
                { rank: "10", suit: "♠" }, { rank: "10", suit: "♦" }, { rank: "A", suit: "♥" }, { rank: "K", suit: "♣" }, { rank: "Q", suit: "♦" }
            ],
            "high-card": [
                { rank: "A", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "J", suit: "♥" }, { rank: "9", suit: "♣" }, { rank: "7", suit: "♠" }
            ]
        };

        // 예시 카드 1장을 렌더링하는 함수 (족보 안내용)
        function renderSingleExampleCard(cardData) {
            const cardDiv = document.createElement('div');
            cardDiv.classList.add('card'); // .poker-hands-guide .card 스타일이 적용됨

            const cardFaceFront = document.createElement('div');
            cardFaceFront.classList.add('card-face', 'card-front');

            const rankDiv = document.createElement('span');
            rankDiv.classList.add('rank');
            rankDiv.textContent = cardData.rank;

            const suitDiv = document.createElement('span');
            suitDiv.classList.add('suit', `suit-${cardData.suit}`);
            suitDiv.innerHTML = cardData.suit;

            cardFaceFront.appendChild(rankDiv);
            cardFaceFront.appendChild(suitDiv);
            cardFaceFront.style.color = (cardData.suit === "♥" || cardData.suit === "♦") ? "red" : "black";

            cardDiv.appendChild(cardFaceFront);
            return cardDiv;
        }

        // 포커 족보 안내에 예시 카드를 채워넣는 함수
        function populatePokerHandExamples() {
            const exampleContainers = document.querySelectorAll('.poker-hands-guide .hand-example-cards');
            exampleContainers.forEach(container => {
                const handName = container.dataset.handName;
                const cardsData = pokerHandExamples[handName];
                if (cardsData) {
                    cardsData.forEach(cardInfo => {
                        const cardElement = renderSingleExampleCard(cardInfo);
                        container.appendChild(cardElement);
                    });
                }
            });
        }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        function showAIActionEffect() { aiActionEffectIndicator.classList.add('active'); setTimeout(() => aiActionEffectIndicator.classList.remove('active'), 700); }
        function getPlayerSlotElement(playerIndex) { return document.getElementById(`player-slot-${playerIndex}`); }

        function showEnhancedFeedback(playerId, text, typeClass) {
            const playerSlot = getPlayerSlotElement(playerId);
            if (!playerSlot) return;

            // 이전에 떠 있던 피드백이 있다면 즉시 제거 (애니메이션 중첩 및 잔상 방지)
            const existingFeedback = playerSlot.querySelector('.enhanced-feedback');
            if (existingFeedback) {
                existingFeedback.remove();
            }

            const feedbackDiv = document.createElement('div');
            feedbackDiv.classList.add('enhanced-feedback', typeClass);
            feedbackDiv.textContent = text;
            playerSlot.appendChild(feedbackDiv);

            // Show animation
            requestAnimationFrame(() => { // 브라우저가 다음 리페인트 준비가 되면 애니메이션 시작
                 setTimeout(() => { // DOM에 요소가 확실히 추가된 후 클래스 변경
                    feedbackDiv.classList.add('show');
                }, 20); // 아주 짧은 딜레이
            });


            // Fade out and remove
            setTimeout(() => {
                feedbackDiv.classList.add('fade-out');
                setTimeout(() => {
                    if (feedbackDiv.parentNode) {
                        feedbackDiv.remove();
                    }
                }, 700); // CSS transition 시간과 일치 (0.7s)
            }, 1500); // 1.5초 후 사라지기 시작 (총 약 2.2초 지속)
        }


        function getPlayerPositionCategory(player, dealerPlayerId, numActivePlayersInHandForPos, currentHandOrder) {
            if (numActivePlayersInHandForPos <= 1) return "OnlyPlayer";
            const playerActualOrder = currentHandOrder;
            const playerIndexInOrder = playerActualOrder.indexOf(player.id);
            if (playerIndexInOrder === -1) return "PositionError_NotFoundInOrder";

            if (numActivePlayersInHandForPos === 2) { return player.isSB ? "SB_Dealer" : "BB_Opponent"; }
            if (playerIndexInOrder === 0) return "SB";
            if (playerIndexInOrder === 1) return "BB";

            const bbPlayer = players.find(p => p.isBB && playerActualOrder.includes(p.id));
            let bbIndexInOrder = bbPlayer ? playerActualOrder.indexOf(bbPlayer.id) : 1;

            if (playerIndexInOrder === (bbIndexInOrder + 1) % numActivePlayersInHandForPos) return "UTG";
            if (player.id === dealerPlayerId) return "Dealer";
            const dealerIndexInActualOrder = playerActualOrder.indexOf(dealerPlayerId);
            if (dealerIndexInActualOrder !== -1) {
                 if (playerIndexInOrder === (dealerIndexInActualOrder - 1 + numActivePlayersInHandForPos) % numActivePlayersInHandForPos) return "CutOff";
            }
            if (numActivePlayersInHandForPos <= 6) {
                 if (playerIndexInOrder < Math.floor(numActivePlayersInHandForPos / 2) && playerIndexInOrder > 1) return "Early";
                 else if (playerIndexInOrder >= Math.floor(numActivePlayersInHandForPos / 2) && player.id !== dealerPlayerId && playerActualOrder.indexOf(dealerPlayerId) !== playerIndexInOrder -1 ) return "Late";
            } else {
                 if (playerIndexInOrder < numActivePlayersInHandForPos / 3 && playerIndexInOrder > 1) return "Early";
                 if (playerIndexInOrder < (numActivePlayersInHandForPos * 2) / 3  && playerIndexInOrder > 1) return "Middle";
                 if (player.id !== dealerPlayerId && playerActualOrder.indexOf(dealerPlayerId) !== playerIndexInOrder -1 ) return "Late";
            }
            return "Middle";
        }
        function calculatePotOdds(amountToCall, currentPotTotal) { if (amountToCall <= 0) return 1; return amountToCall / (currentPotTotal + amountToCall); }
        function analyzeBoardTexture(communityCards) {
            if (!communityCards || communityCards.length < 3) return { type: "preflop", isWet: false, isPaired: false, flushDraws: 0, straightDraws: 0, highCardValue:0 };
            let texture = { type: "unknown", isWet: false, isPaired: false, flushDraws: 0, straightDraws: 0, highCardValue:0 };
            const ranks = communityCards.map(c => c.value).sort((a,b)=>b-a); const suits = communityCards.map(c => c.suit);
            texture.highCardValue = ranks[0] || 0; const rankCounts = {}; ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            if (Object.values(rankCounts).some(count => count >= 2)) texture.isPaired = true;
            if (Object.values(rankCounts).some(count => count >= 3)) { texture.isPaired = true; texture.isWet = true; }
            const suitCounts = {}; suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            Object.values(suitCounts).forEach(count => { if (count === 2 && communityCards.length === 3) texture.flushDraws = 1; if (count >= 3) {texture.flushDraws = Math.max(texture.flushDraws, count); texture.isWet = true;} });
            const uniqueSortedRanks = [...new Set(ranks)].sort((a,b)=>a-b);
            if (uniqueSortedRanks.length >= 3) {
                for (let i = 0; i <= uniqueSortedRanks.length - 3; i++) { if (uniqueSortedRanks[i+2] - uniqueSortedRanks[i] <= 4) { texture.straightDraws++; texture.isWet = true; } }
                if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(2) && uniqueSortedRanks.includes(3)) texture.straightDraws++;
                if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(2) && uniqueSortedRanks.includes(4) && !uniqueSortedRanks.includes(3)) texture.straightDraws++;
                if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(3) && uniqueSortedRanks.includes(4) && !uniqueSortedRanks.includes(2)) texture.straightDraws++;
            }
            if (texture.straightDraws > 1 || (texture.straightDraws > 0 && texture.flushDraws >=3 )) texture.isWet = true;
            if (!texture.isWet && !texture.isPaired && texture.highCardValue < RANK_VALUES.J && ranks.length >=3 && (ranks[0] - ranks[ranks.length-1] > 5)) { texture.type = "dry_uncoordinated"; }
            else if (texture.isWet) { texture.type = "wet_drawy"; } else if (texture.isPaired) { texture.type = "paired"; }
            else { texture.type = "semi_coordinated"; }
            return texture;
        }

        function createDeck() { deck = []; for (let suit of SUITS) for (let rank of RANKS) deck.push({ suit, rank, value: RANK_VALUES[rank], id: rank+suit+Date.now()+Math.random() }); }
        function shuffleDeck() { for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } }
        function dealCardFromDeck(hiddenInitially = false) { if (deck.length > 0) { const card = deck.pop(); card.hidden = hiddenInitially; card.revealed = !hiddenInitially; return card; } return null; }
        function burnCard() { if (deck.length > 0) deck.pop(); }

        function createPlayerSlotUI(player) {
            const slotDiv = getPlayerSlotElement(player.id); if (!slotDiv) { console.error(`Slot DIV for player ${player.id} not found`); return; }
            slotDiv.innerHTML = `<div class="player-name-display">${player.name} <span id="dealer-chip-${player.id}" class="dealer-chip-ui" style="display:none;">D</span><span id="sb-chip-${player.id}" class="blind-chip-ui" style="display:none;">SB</span><span id="bb-chip-${player.id}" class="blind-chip-ui" style="display:none;">BB</span></div><div id="cards-player-${player.id}" class="cards-container"></div><div id="chips-player-${player.id}" class="chips-display">칩: ${Math.floor(player.chips)}원</div><div id="bet-player-${player.id}" class="bet-amount-display" style="display:none;"></div><div id="current-hand-player-${player.id}" class="current-hand-display"></div>`; // Removed old action-text-feedback div
            slotDiv.style.display = "block";
        }
        function renderPlayerCard(player, cardData, hiddenInitially = false) {
            const cardsContainer = document.getElementById(`cards-player-${player.id}`); if (!cardsContainer) return;
            let cardIsActuallyHiddenForRender = hiddenInitially; if (isAdminMode && player.type === 'ai') { cardIsActuallyHiddenForRender = false; }
            const cardElement = renderSingleCard(cardData, false, cardIsActuallyHiddenForRender); cardsContainer.appendChild(cardElement); return cardElement;
        }
        function renderSingleCard(card, isCommunity = false, hiddenInitially = false) {
            const cardDiv = document.createElement('div'); cardDiv.classList.add('card'); cardDiv.dataset.cardId = card.id;
            const cardFaceFront = document.createElement('div'); cardFaceFront.classList.add('card-face', 'card-front');
            const rankDiv = document.createElement('span'); rankDiv.classList.add('rank'); rankDiv.textContent = card.rank;
            const suitDiv = document.createElement('span'); suitDiv.classList.add('suit', `suit-${card.suit}`); suitDiv.innerHTML = card.suit;
            cardFaceFront.appendChild(rankDiv); cardFaceFront.appendChild(suitDiv); cardFaceFront.style.color = (card.suit === "♥" || card.suit === "♦") ? "red" : "black";
            const cardFaceBack = document.createElement('div'); cardFaceBack.classList.add('card-face', 'card-back');
            cardDiv.appendChild(cardFaceFront); cardDiv.appendChild(cardFaceBack);
            if (hiddenInitially) { cardDiv.classList.add('hidden');}
            let delay = 0; if (isCommunity) delay = communityCardsDiv.children.length * 150;
            setTimeout(() => { cardDiv.classList.add('is-dealt'); if (!hiddenInitially) { setTimeout(() => { if (!cardDiv.classList.contains('hidden')) { cardDiv.classList.add('is-flipping'); } }, 50 + delay + (isCommunity ? 100 : 0) ); } }, 50 + delay);
            return cardDiv;
        }
        async function dealAnimatedCommunityCard(cardData) { communityCards.push(cardData); const cardElement = renderSingleCard(cardData, true, false); communityCardsDiv.appendChild(cardElement); await sleep(200); }
        function revealHiddenCard(player, cardObj) {
            const cardElement = document.querySelector(`#cards-player-${player.id} .card[data-card-id="${cardObj.id}"]`);
            if (cardElement && cardElement.classList.contains('hidden')) { cardElement.classList.remove('hidden'); cardElement.classList.add('is-flipping'); }
            if(player.type === 'ai') { const gameCard = player.cards.find(c => c.id === cardObj.id); if(gameCard) { gameCard.hidden = false; gameCard.revealed = true;} }
        }

        function updateOverallUI() {
            players.forEach(p => {
                const slotDiv = getPlayerSlotElement(p.id); if (!slotDiv) return;
                document.getElementById(`chips-player-${p.id}`).textContent = `칩: ${Math.floor(p.chips)}원`;
                const betDiv = document.getElementById(`bet-player-${p.id}`);
                if (p.betInRound > 0) { betDiv.textContent = `벳: ${Math.floor(p.betInRound)}원`; betDiv.style.display = 'inline-block'; } else { betDiv.style.display = 'none'; }
                document.getElementById(`dealer-chip-${p.id}`).style.display = p.isDealer ? 'inline-block' : 'none';
                document.getElementById(`sb-chip-${p.id}`).style.display = p.isSB ? 'inline-block' : 'none';
                document.getElementById(`bb-chip-${p.id}`).style.display = p.isBB ? 'inline-block' : 'none';

                const currentHandDiv = document.getElementById(`current-hand-player-${p.id}`);
                if (currentHandDiv && p.type === "human" && p.cards.length >= 2 && !p.isFolded) {
                    if (communityCards.length >= 3) { const handDetails = getHandDetails([...p.cards, ...communityCards]); currentHandDiv.textContent = `현재 최고패: ${handDetails.handName}`; }
                    else if (p.cards.length === 2) {
                        let preflopHandName = ""; const card1 = p.cards[0]; const card2 = p.cards[1];
                        if (card1.value === card2.value) { preflopHandName = `${card1.rank} 페어`; }
                        else {
                            const highRankValue = Math.max(card1.value, card2.value); const lowRankValue = Math.min(card1.value, card2.value);
                            const highRankName = Object.keys(RANK_VALUES).find(key => RANK_VALUES[key] === highRankValue && key !== "A_LOW");
                            const lowRankName = Object.keys(RANK_VALUES).find(key => RANK_VALUES[key] === lowRankValue && key !== "A_LOW");
                            preflopHandName = `${highRankName || card1.rank}${lowRankName || card2.rank}`;
                            if (card1.suit === card2.suit) { preflopHandName += "s"; } else { preflopHandName += "o"; }
                             preflopHandName += ` (하이: ${highRankName || card1.rank})`;
                        }
                        currentHandDiv.textContent = `손패: ${preflopHandName}`;
                    }
                } else if (currentHandDiv) { currentHandDiv.textContent = ""; }

                slotDiv.classList.remove('acting', 'folded');
                const currentPlayerObject = players[currentPlayerIndex];
                if (currentPlayerObject && p.id === currentPlayerObject.id && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND" && !p.isFolded && !p.isAllIn) { slotDiv.classList.add('acting'); }
                if (p.isFolded) slotDiv.classList.add('folded');

                if (isAdminMode && p.type === 'ai' && !p.isFolded) {
                    p.cards.forEach(cardData => {
                        const cardElement = document.querySelector(`#cards-player-${p.id} .card[data-card-id="${cardData.id}"]`);
                        if (cardElement && cardElement.classList.contains('hidden')) {
                            cardElement.classList.remove('hidden');
                            if (!cardElement.classList.contains('is-flipping') && !cardElement.classList.contains('is-dealt')) { setTimeout(() => cardElement.classList.add('is-dealt'), 50); setTimeout(() => cardElement.classList.add('is-flipping'), 150); }
                            else if (!cardElement.classList.contains('is-flipping')) { cardElement.classList.add('is-flipping'); }
                        }
                        cardData.hidden = false; cardData.revealed = true;
                    });
                }
            });
            if (potDisplayBottomRightEl) potDisplayBottomRightEl.textContent = `팟: ${Math.floor(pot)}원`;
            updateActionButtonsForHuman();
        }
        function updateActionButtonsForHuman() {
            const humanPlayer = players.find(p => p.type === "human"); if (!humanPlayer) { checkCallButton.disabled = true; betRaiseButton.disabled = true; raiseInput.disabled = true; foldButton.disabled = true; return; }
            const currentPlayerObject = players[currentPlayerIndex]; const isHumanTurn = currentPlayerObject && humanPlayer.id === currentPlayerObject.id && !humanPlayer.isFolded && !humanPlayer.isAllIn && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND";
            checkCallButton.disabled = !isHumanTurn; betRaiseButton.disabled = !isHumanTurn; raiseInput.disabled = !isHumanTurn; foldButton.disabled = !isHumanTurn;
            if (isHumanTurn) {
                const amountToCall = currentBet - humanPlayer.betInRound;
                if (amountToCall > 0) { checkCallButton.textContent = `콜 (${Math.floor(Math.min(amountToCall, humanPlayer.chips))}원)`; betRaiseButton.textContent = "레이즈"; }
                else { checkCallButton.textContent = "체크"; betRaiseButton.textContent = "벳"; }
                let minNewTotalBet = currentBet + minRaiseAmount; if (currentBet === 0) minNewTotalBet = minRaiseAmount;
                minNewTotalBet = Math.max(minNewTotalBet, humanPlayer.betInRound + (currentBet > 0 ? minRaiseAmount : SMALL_BLIND_AMOUNT_CONFIG));
                raiseInput.min = Math.floor(Math.min(humanPlayer.chips + humanPlayer.betInRound, minNewTotalBet));
                raiseInput.value = Math.floor(Math.min(humanPlayer.chips + humanPlayer.betInRound, minNewTotalBet));
                raiseInput.max = Math.floor(humanPlayer.chips + humanPlayer.betInRound);
            } else { checkCallButton.textContent = "체크"; betRaiseButton.textContent = "벳"; }
        }
        function displayMessage(msg, type = "system-message") { const p = document.createElement('p'); p.classList.add(type); p.textContent = msg; messageLogDiv.appendChild(p); messageLogDiv.scrollTop = messageLogDiv.scrollHeight; }

        async function initializeNewGame() {
            let newStartingChips = parseInt(startingChipsInputEl.value); let newBigBlind = parseInt(bigBlindInputEl.value);
            STARTING_CHIPS_CONFIG = (!isNaN(newStartingChips) && newStartingChips >= 100) ? newStartingChips : 1000;
            BIG_BLIND_AMOUNT_CONFIG = (!isNaN(newBigBlind) && newBigBlind >= 2) ? newBigBlind : 20;
            SMALL_BLIND_AMOUNT_CONFIG = Math.floor(BIG_BLIND_AMOUNT_CONFIG / 2);
            minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG;
            if (sbBbDisplayAreaEl) sbBbDisplayAreaEl.textContent = `SB: ${SMALL_BLIND_AMOUNT_CONFIG} / BB: ${BIG_BLIND_AMOUNT_CONFIG}`;

            actualNumPlayersInCurrentGame = parseInt(numPlayersSelect.value); players = [];
            for (let i = 0; i < actualNumPlayersInCurrentGame; i++) {
                players.push({ id: i, name: i === 0 ? "플레이어" : `AI ${i}`, type: i === 0 ? "human" : "ai", chips: STARTING_CHIPS_CONFIG, cards: [], betInRound: 0, isFolded: false, isAllIn: false, isDealer: false, isSB: false, isBB: false, handDetails: null, hasActedThisBettingRound: false, positionCategory: "Unknown", previousAction: null, aggressionFactor: Math.random() * 0.5 + 0.75, tightnessFactor: Math.random() * 0.5 + 0.75 });
                createPlayerSlotUI(players[i]);
            }
            for (let i = actualNumPlayersInCurrentGame; i <= 3; i++) { const slot = getPlayerSlotElement(i); if(slot) slot.style.display = "none"; }
            dealerIndex = -1;
            controlButtonsArea.innerHTML = `<button id="start-game-button-main">새 게임</button>`;
            document.getElementById('start-game-button-main').addEventListener('click', initializeNewGame);
            numPlayersSelect.disabled = false; startingChipsInputEl.disabled = false; bigBlindInputEl.disabled = false;
            await startNewHand();
        }

        async function startNewHand() {
            controlButtonsArea.innerHTML = `<button id="start-game-button-main" style="display:none;">새 게임</button>`;
            document.getElementById('start-game-button-main').addEventListener('click', initializeNewGame);
            numPlayersSelect.disabled = true; startingChipsInputEl.disabled = true; bigBlindInputEl.disabled = true;

            if (players.length === 0) { await initializeNewGame(); return; }
            const activePlayersWithChips = players.filter(p => p.chips > 0);
            if (activePlayersWithChips.length <= 1 && players.length > 0) { await endCurrentHand(false); return; }

            gamePhase = "SETUP"; createDeck(); shuffleDeck(); communityCards = []; communityCardsDiv.innerHTML = '';
            pot = 0; currentBet = 0; minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG; lastRaiserId = -1;
            currentHandActivePlayerIdsOrder = []; currentTurnInOrderIndex = -1;

            players.forEach(p => {
                p.cards = []; p.betInRound = 0;
                if (p.chips <= 0) p.isFolded = true; else p.isFolded = false;
                p.isAllIn = (p.chips === 0 && !p.isFolded);
                p.isDealer = false; p.isSB = false; p.isBB = false;
                p.handDetails = null; p.hasActedThisBettingRound = false; p.previousAction = null;
                const cardsDiv = document.getElementById(`cards-player-${p.id}`); if (cardsDiv) cardsDiv.innerHTML = '';
                const currentHandDiv = document.getElementById(`current-hand-player-${p.id}`); if(currentHandDiv) currentHandDiv.textContent = "";
            });

            let prevDealerOriginalIndex = dealerIndex;
            if (dealerIndex === -1 || !players[dealerIndex] || players[dealerIndex].chips <= 0 || players[dealerIndex].isFolded) {
                 dealerIndex = Math.floor(Math.random() * actualNumPlayersInCurrentGame); let initialPick = dealerIndex;
                 while(!players[dealerIndex] || players[dealerIndex].chips <= 0 || players[dealerIndex].isFolded) { dealerIndex = (dealerIndex + 1) % actualNumPlayersInCurrentGame; if(dealerIndex === initialPick) { console.error("Cannot find a dealer."); await endCurrentHand(false); return; } }
            } else {
                const activeForDealerMove = players.filter(p=>p.chips>0 && !p.isFolded);
                if (activeForDealerMove.length === 2) {
                    const prevDealerPlayer = players[prevDealerOriginalIndex];
                    const nextDealerCand = activeForDealerMove.find(p => p.id !== prevDealerPlayer.id);
                    dealerIndex = players.findIndex(p => p.id === (nextDealerCand ? nextDealerCand.id : activeForDealerMove[0].id));
                } else if (activeForDealerMove.length > 2) {
                    const baseOrderForDealer = VISUAL_ORDER_RULES[actualNumPlayersInCurrentGame] || VISUAL_ORDER_RULES[4].filter(id => activeForDealerMove.some(p => p.id === id));
                    let currentDealerVisualPos = baseOrderForDealer.indexOf(players[prevDealerOriginalIndex].id); if(currentDealerVisualPos === -1) currentDealerVisualPos = 0;
                    let nextDealerId;
                    for (let i = 1; i <= baseOrderForDealer.length; i++) {
                        nextDealerId = baseOrderForDealer[(currentDealerVisualPos + i) % baseOrderForDealer.length];
                        const pCand = activeForDealerMove.find(p => p.id === nextDealerId);
                        if (pCand) { dealerIndex = players.findIndex(p => p.id === nextDealerId); break; }
                    }
                } else { console.error("Not enough active players for dealer."); await endCurrentHand(false); return; }
            }
            if(dealerIndex === -1 || !players[dealerIndex]) { // Fallback if dealerIndex somehow becomes invalid
                dealerIndex = players.findIndex(p => p.chips > 0 && !p.isFolded);
                if(dealerIndex === -1) { console.error("Critical: No valid dealer found."); await endCurrentHand(false); return;}
            }
            players[dealerIndex].isDealer = true;
            const currentDealerPlayerId = players[dealerIndex].id;
            displayMessage(`${players[dealerIndex].name}가 딜러입니다.`, "game-event");

            const activePlayersInHandList = players.filter(p => !p.isFolded && (p.chips > 0 || p.isAllIn));
            const numActiveInHand = activePlayersInHandList.length;
            let sbPlayer = null, bbPlayer = null;

            if (numActiveInHand === 2) {
                sbPlayer = players[dealerIndex]; sbPlayer.isSB = true;
                bbPlayer = activePlayersInHandList.find(p => p.id !== sbPlayer.id);
                if (bbPlayer) bbPlayer.isBB = true; else { console.error("HU: BB not found"); await endCurrentHand(false); return;}
                currentHandActivePlayerIdsOrder = [sbPlayer.id, bbPlayer.id];
            } else if (numActiveInHand > 2) {
                const baseVisualOrder = VISUAL_ORDER_RULES[numActiveInHand] ? [...VISUAL_ORDER_RULES[numActiveInHand]]
                                    : [...VISUAL_ORDER_RULES[4]].filter(id => activePlayersInHandList.some(p => p.id === id));
                let dealerPosInVisual = baseVisualOrder.indexOf(currentDealerPlayerId);
                if(dealerPosInVisual === -1) {
                    const tempOrderedActive = players.filter(p => baseVisualOrder.includes(p.id) && activePlayersInHandList.includes(p)).sort((a,b) => baseVisualOrder.indexOf(a.id) - baseVisualOrder.indexOf(b.id)).map(p=>p.id);
                    dealerPosInVisual = tempOrderedActive.indexOf(currentDealerPlayerId);
                     if(dealerPosInVisual === -1) dealerPosInVisual = 0;

                    for (let i = 0; i < tempOrderedActive.length; i++) {
                        const visualOrderIdx = (dealerPosInVisual + 1 + i) % tempOrderedActive.length;
                        currentHandActivePlayerIdsOrder.push(tempOrderedActive[visualOrderIdx]);
                    }
                } else {
                     for (let i = 0; i < baseVisualOrder.length; i++) {
                        const visualOrderIdx = (dealerPosInVisual + 1 + i) % baseVisualOrder.length;
                        const pIdInVisual = baseVisualOrder[visualOrderIdx];
                        if (activePlayersInHandList.some(p => p.id === pIdInVisual)) {
                           currentHandActivePlayerIdsOrder.push(pIdInVisual);
                        }
                    }
                }
                currentHandActivePlayerIdsOrder = currentHandActivePlayerIdsOrder.filter(id => activePlayersInHandList.some(p => p.id === id)).slice(0, numActiveInHand);

                if (currentHandActivePlayerIdsOrder.length >= 1) { sbPlayer = players.find(p => p.id === currentHandActivePlayerIdsOrder[0]); if (sbPlayer) sbPlayer.isSB = true; }
                if (currentHandActivePlayerIdsOrder.length >= 2) { bbPlayer = players.find(p => p.id === currentHandActivePlayerIdsOrder[1]); if (bbPlayer) bbPlayer.isBB = true; }
            }

            players.forEach(p => {
                if (currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && (p.chips > 0 || p.isAllIn) ) {
                    p.positionCategory = getPlayerPositionCategory(p, currentDealerPlayerId, numActiveInHand, currentHandActivePlayerIdsOrder);
                } else { p.positionCategory = "Folded/Out"; }
            });

            if (sbPlayer) {
                const sbAmountToPost = Math.min(SMALL_BLIND_AMOUNT_CONFIG, sbPlayer.chips);
                sbPlayer.chips -= sbAmountToPost; sbPlayer.betInRound = sbAmountToPost; pot += sbAmountToPost;
                displayMessage(`${sbPlayer.name} (SB) ${Math.floor(sbAmountToPost)}원 자동 베팅.`, sbPlayer.type === "human" ? "player-action" : "ai-action");
                if (sbPlayer.chips === 0 && sbAmountToPost > 0) sbPlayer.isAllIn = true;
            }
            if (bbPlayer) {
                const bbAmountToPost = Math.min(BIG_BLIND_AMOUNT_CONFIG, bbPlayer.chips);
                bbPlayer.chips -= bbAmountToPost; bbPlayer.betInRound = bbAmountToPost; pot += bbAmountToPost;
                displayMessage(`${bbPlayer.name} (BB) ${Math.floor(bbAmountToPost)}원 자동 베팅.`, bbPlayer.type === "human" ? "player-action" : "ai-action");
                if (bbPlayer.chips === 0 && bbAmountToPost > 0) bbPlayer.isAllIn = true;
            }
            currentBet = BIG_BLIND_AMOUNT_CONFIG;

            for (let i = 0; i < 2; i++) {
                for (const playerIdToDeal of currentHandActivePlayerIdsOrder) {
                    const p = players.find(pl => pl.id === playerIdToDeal);
                    if (p && !p.isFolded) { const newCard = dealCardFromDeck(p.type === "ai"); p.cards.push(newCard); renderPlayerCard(p, newCard, p.type === "ai"); await sleep(100); }
                }
            }

            gamePhase = "PREFLOP";
            if (currentHandActivePlayerIdsOrder.length > 0) {
                let firstToActOrderIndex = 0;
                if (numActiveInHand === 2) { firstToActOrderIndex = 0; }
                else if (numActiveInHand > 2) { firstToActOrderIndex = 2 % currentHandActivePlayerIdsOrder.length; }
                currentTurnInOrderIndex = firstToActOrderIndex;
                let initialSearchOrderIndex = currentTurnInOrderIndex; let foundFirst = false;
                for(let i=0; i<currentHandActivePlayerIdsOrder.length; i++){
                    const pId = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]; const pObj = players.find(p=>p.id === pId);
                    if(pObj && !pObj.isFolded && !pObj.isAllIn && pObj.chips > 0) { foundFirst = true; break; }
                    currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length;
                    if(currentTurnInOrderIndex === initialSearchOrderIndex && i > 0) break;
                }
                if(foundFirst){ currentPlayerIndex = players.findIndex(p => p.id === currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]); } else { currentPlayerIndex = -1; }
            } else { currentPlayerIndex = -1; }

            lastRaiserId = bbPlayer ? bbPlayer.id : (sbPlayer ? sbPlayer.id : -1) ;

            updateOverallUI();
            const activeNonAllInPlayers = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            if (currentPlayerIndex === -1 || activeNonAllInPlayers.length === 0) { await advanceGamePhase(); }
            else if (activeNonAllInPlayers.length === 1 && players[currentPlayerIndex] && players[currentPlayerIndex].isAllIn) { await advanceGamePhase(); }
            else { await startBettingRound(); }
        }

        async function startBettingRound() {
            players.forEach(p => { if (!p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
            displayMessage(`--- ${gamePhase} 라운드 시작 ---`, "game-event");

            if (gamePhase !== "PREFLOP") {
                currentTurnInOrderIndex = 0;
                let initialSearchOrderIndex = currentTurnInOrderIndex; let foundFirst = false;
                 for(let i=0; i<currentHandActivePlayerIdsOrder.length; i++){
                    const pId = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]; const pObj = players.find(p=>p.id === pId);
                    if(pObj && !pObj.isFolded && !pObj.isAllIn && pObj.chips > 0) { foundFirst = true; break; }
                    currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length;
                     if(currentTurnInOrderIndex === initialSearchOrderIndex && i > 0 && !foundFirst) { 
                         currentPlayerIndex = -1; break;
                     }
                }
                if(foundFirst){ currentPlayerIndex = players.findIndex(p => p.id === currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]); }
                else { currentPlayerIndex = -1; }

                players.forEach(p => { if(!p.isFolded && !p.isAllIn) p.betInRound = 0; });
                currentBet = 0; minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG; lastRaiserId = -1;
            }

            const activeForBetting = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            const allInPlayersThisRound = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && p.isAllIn);

            if (currentPlayerIndex === -1 || (activeForBetting.length === 0 && allInPlayersThisRound.length > 0) ) {
                 displayMessage("모든 잔여 플레이어가 올인 상태거나 액션할 플레이어 없음. 다음 단계로 진행.", "game-event");
                 await sleep(1000); await advanceGamePhase(); return;
            } else if (activeForBetting.length <=1 ) {
                const nonAllInCanAct = activeForBetting; let bettingStillPossible = false;
                if (nonAllInCanAct.length === 1) {
                    const actor = nonAllInCanAct[0];
                    bettingStillPossible = (currentBet > 0 && actor.betInRound < currentBet && actor.chips > 0) ||
                                           (gamePhase === "PREFLOP" && actor.isBB && currentBet === BIG_BLIND_AMOUNT_CONFIG && !actor.hasActedThisBettingRound && lastRaiserId === actor.id);
                }
                if (!bettingStillPossible) {
                    const isOnlyOnePlayerLeftOverall = players.filter(p => !p.isFolded).length === 1;
                    if(!isOnlyOnePlayerLeftOverall && activeForBetting.length <=1){
                        displayMessage("베팅할 플레이어가 한 명 이하. 다음 단계로 진행.", "game-event");
                        await sleep(1000); await advanceGamePhase(); return;
                    }
                }
            }
            updateOverallUI(); await processPlayerTurn();
        }

        async function processPlayerTurn() {
            if (currentPlayerIndex === -1 || currentTurnInOrderIndex === -1 || currentHandActivePlayerIdsOrder.length === 0) {
                 console.warn("processPlayerTurn: No current player. Advancing phase."); await advanceGamePhase(); return;
            }
            const currentPlayerIdToAct = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
            const currentPlayerObject = players.find(p => p.id === currentPlayerIdToAct);
            if (!currentPlayerObject || currentPlayerObject.isFolded || currentPlayerObject.isAllIn) {
                 console.warn(`processPlayerTurn: Player ${currentPlayerIdToAct} cannot act. Switching.`); await switchToNextPlayerOrEndRound(); return;
            }
            currentPlayerIndex = players.findIndex(p => p.id === currentPlayerIdToAct);

            displayMessage(`${currentPlayerObject.name}의 턴. (포지션: ${currentPlayerObject.positionCategory}) 현재 베팅액: ${Math.floor(currentBet)}원`, "system-message");
            updateOverallUI();
            if (currentPlayerObject.type === "human") { updateActionButtonsForHuman(); }
            else { await sleep(800 + Math.random() * 1000); await handleAIAction(currentPlayerObject); }
        }

        async function handleHumanAction(actionType) {
            const humanPlayer = players[currentPlayerIndex];
            if (!humanPlayer || humanPlayer.type !== "human" || humanPlayer.isFolded || humanPlayer.isAllIn) { console.warn("Human action: invalid player/state."); await switchToNextPlayerOrEndRound(); return; }
            humanPlayer.hasActedThisBettingRound = true; humanPlayer.previousAction = actionType;
            let actualBetMadeThisAction = 0;
            switch (actionType) {
                case 'FOLD':
                    humanPlayer.isFolded = true;
                    showEnhancedFeedback(humanPlayer.id, "폴드...", "feedback-fold");
                    displayMessage(`${humanPlayer.name} 폴드.`, "player-action");
                    break;
                case 'CHECK_CALL':
                    const amountToCall = currentBet - humanPlayer.betInRound;
                    if (amountToCall > 0) {
                        actualBetMadeThisAction = Math.min(amountToCall, humanPlayer.chips); humanPlayer.chips -= actualBetMadeThisAction;
                        humanPlayer.betInRound += actualBetMadeThisAction; pot += actualBetMadeThisAction;
                        showEnhancedFeedback(humanPlayer.id, "콜!", "feedback-call");
                        displayMessage(`${humanPlayer.name} ${Math.floor(actualBetMadeThisAction)}원 콜 (총 ${Math.floor(humanPlayer.betInRound)}원).`, "player-action");
                        if (humanPlayer.chips === 0 && actualBetMadeThisAction > 0) humanPlayer.isAllIn = true;
                    } else {
                        showEnhancedFeedback(humanPlayer.id, "체크", "feedback-check");
                        displayMessage(`${humanPlayer.name} 체크.`, "player-action");
                    }
                    break;
                case 'BET_RAISE':
                    let desiredTotalBet = parseInt(raiseInput.value);
                    if (isNaN(desiredTotalBet) || desiredTotalBet < 0) { displayMessage("유효한 금액 입력.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return; }
                    if (desiredTotalBet > humanPlayer.chips + humanPlayer.betInRound) desiredTotalBet = humanPlayer.chips + humanPlayer.betInRound;
                    actualBetMadeThisAction = desiredTotalBet - humanPlayer.betInRound;
                    if (actualBetMadeThisAction < 0) { displayMessage("잘못된 베팅 금액.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return; }

                    let feedbackText = "";
                    let feedbackClass = "";

                    if (currentBet === 0) { // Betting
                        if (desiredTotalBet < minRaiseAmount && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) { displayMessage(`최소 벳: ${Math.floor(minRaiseAmount)}원.`, "system-message"); humanPlayer.hasActedThisBettingRound = false; return; }
                        feedbackText = "벳!";
                        feedbackClass = "feedback-bet";
                    } else { // Raising
                        if (desiredTotalBet < currentBet + minRaiseAmount && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) { displayMessage(`최소 레이즈 총액: ${Math.floor(currentBet + minRaiseAmount)}원.`, "system-message"); humanPlayer.hasActedThisBettingRound = false; return; }
                        if (desiredTotalBet <= currentBet && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) { displayMessage("레이즈는 현재 베팅보다 커야 함.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return; }
                        feedbackText = "레이즈!";
                        feedbackClass = "feedback-raise";
                    }
                    humanPlayer.chips -= actualBetMadeThisAction; humanPlayer.betInRound += actualBetMadeThisAction; pot += actualBetMadeThisAction;
                    showEnhancedFeedback(humanPlayer.id, feedbackText, feedbackClass);
                    displayMessage(`${humanPlayer.name} ${Math.floor(actualBetMadeThisAction)}원 ${currentBet === 0 ? '벳' : '레이즈'} (총 ${Math.floor(humanPlayer.betInRound)}원).`, "player-action");
                    if (humanPlayer.chips === 0 && actualBetMadeThisAction > 0) humanPlayer.isAllIn = true;
                    if (humanPlayer.betInRound > currentBet) { minRaiseAmount = humanPlayer.betInRound - currentBet; currentBet = humanPlayer.betInRound; lastRaiserId = humanPlayer.id; players.forEach(p => { if (p.id !== humanPlayer.id && !p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; }); }
                    break;
            }
            updateOverallUI(); await switchToNextPlayerOrEndRound();
        }
        async function handleAIAction(aiPlayer) {
            if (aiPlayer.isFolded || aiPlayer.isAllIn) { await switchToNextPlayerOrEndRound(); return; }
            showAIActionEffect(); aiPlayer.hasActedThisBettingRound = true;
            let amountToCall = currentBet - aiPlayer.betInRound; let decisionType = "FOLD"; let aiActionAmount = 0;
            let isBluffing = false;
            const holeCardStrength = evaluateHoleCards(aiPlayer.cards); const combinedHand = [...aiPlayer.cards, ...communityCards];
            const currentMadeHandDetails = getHandDetails(combinedHand); const drawPotential = evaluateDrawPotential(communityCards, aiPlayer.cards);
            const boardInfo = analyzeBoardTexture(communityCards); let effectiveHandStrength = currentMadeHandDetails.strength / 9;
            if (drawPotential.outs > 0) effectiveHandStrength += drawPotential.outs * 0.02 + Math.random() * 0.03;

            // === AI 로직 수정 시작: activeOpponents 정의를 함수 초반으로 이동 ===
            const activeOpponents = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && p.id !== aiPlayer.id && !p.isFolded && !p.isAllIn && p.chips > 0);
            // === AI 로직 수정 끝 ===

            const aggressionMod = aiPlayer.aggressionFactor; const tightnessMod = aiPlayer.tightnessFactor;

            if (gamePhase === "PREFLOP") {
                // === AI 로직 수정: 프리플랍 오픈 레이즈 기준 및 사이즈 조정 ===
                let openRaiseMultiplier = 2.2 + (1.0 / tightnessMod) + (aggressionMod - 0.9); // 기본 배수 약간 낮춤
                if (aiPlayer.positionCategory === "Early" || aiPlayer.positionCategory === "UTG" || aiPlayer.positionCategory === "SB_Dealer") {
                    openRaiseMultiplier = Math.max(2.5, openRaiseMultiplier * 1.05); // 안좋은 자리면 배수 증가폭도 약간 줄임
                }

                if (activeOpponents.length >= 2) { // 예: 4인 게임에서 내 앞에 2명 이상이 아직 폴드 안했을 때
                    openRaiseMultiplier *= 0.85; // 레이즈 크기를 85%로 줄임
                } else if (activeOpponents.length === 1) { // 상대가 1명 남았을 때
                    openRaiseMultiplier *= 0.95; // 레이즈 크기를 95%로 약간만 줄임
                }
                // === AI 로직 수정 끝 ===
                let openRaiseSize = Math.floor(BIG_BLIND_AMOUNT_CONFIG * openRaiseMultiplier);
                openRaiseSize = Math.max(BIG_BLIND_AMOUNT_CONFIG * 2, openRaiseSize); // 최소 오픈 레이즈 사이즈 보장 (BB의 2배)


                let callThreshold = 0.42 * tightnessMod;
                // === AI 로직 수정: 프리플랍 오픈 레이즈 기준 조정 ===
                let raiseThreshold = 0.60 * tightnessMod * aggressionMod; // AI가 레이즈를 결정하는 기준점 (기본값을 0.58 -> 0.60으로 약간 올림)
                if (activeOpponents.length >= 2) {
                    raiseThreshold *= 1.15; // 레이즈 기준을 15% 더 높임 (더 좋은 패를 요구)
                } else if (activeOpponents.length === 1) {
                    raiseThreshold *= 1.05; // 레이즈 기준을 5% 더 높임
                }
                // === AI 로직 수정 끝 ===

                const isFoldedToSBvsBB = aiPlayer.isSB && currentBet === BIG_BLIND_AMOUNT_CONFIG && activeOpponents.length === 1 && activeOpponents[0].isBB;

                if (amountToCall === 0) { // 내가 처음 액션을 하거나, 앞사람들이 다 체크했을 때
                    if (isFoldedToSBvsBB) { // SB vs BB 상황
                        let sbStealRaiseThreshold = 0.45 / tightnessMod * aggressionMod;
                        let sbCompleteCallThreshold = 0.20 / tightnessMod;
                        if (holeCardStrength > sbStealRaiseThreshold || (holeCardStrength > 0.33 && Math.random() < 0.35 * aggressionMod)) {
                            decisionType = "BET_RAISE";
                            aiActionAmount = Math.floor(BIG_BLIND_AMOUNT_CONFIG * (2.2 + aggressionMod * 0.8 + Math.random() * 0.5));
                        } else if (holeCardStrength > sbCompleteCallThreshold && ((aiPlayer.cards[0].suit === aiPlayer.cards[1].suit) || Math.abs(aiPlayer.cards[0].value - aiPlayer.cards[1].value) <= 4)) {
                            decisionType = "CHECK_CALL"; // SB에서 BB를 상대로 림프에 컴플릿
                            aiActionAmount = BIG_BLIND_AMOUNT_CONFIG - aiPlayer.betInRound;
                            if (aiActionAmount < 0) aiActionAmount = 0;
                        } else {
                            decisionType = "FOLD";
                        }
                    } else if (aiPlayer.isBB && currentBet === BIG_BLIND_AMOUNT_CONFIG && !players.some(p => p.id !== aiPlayer.id && p.betInRound > BIG_BLIND_AMOUNT_CONFIG && p.hasActedThisBettingRound && currentHandActivePlayerIdsOrder.indexOf(p.id) < currentHandActivePlayerIdsOrder.indexOf(aiPlayer.id))) {
                        // BB가 아무도 레이즈 안 했을 때 옵션 체크
                        decisionType = "CHECK_CALL";
                        aiActionAmount = 0;
                    } else if (holeCardStrength > raiseThreshold) { // 내 패가 (새롭게 조정된) 레이즈 기준보다 좋으면
                        decisionType = "BET_RAISE";
                        aiActionAmount = openRaiseSize; // (새롭게 조정된) 만큼 레이즈!
                    } else if (holeCardStrength > (callThreshold * 0.70) && !aiPlayer.isSB && (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer") && Math.random() < (0.20 / tightnessMod)) {
                        // 뒷자리에서 아주 가끔 림프 시도 (기존 로직보다 약간 더 보수적으로)
                        decisionType = "CHECK_CALL"; // 림프 (사실상 콜, 0을 콜하는 것)
                        aiActionAmount = BIG_BLIND_AMOUNT_CONFIG - aiPlayer.betInRound; // 만약 BB가 아니라면, BB만큼 내야함.
                        if(aiActionAmount < 0) aiActionAmount = 0;
                        if(currentBet === 0 && aiPlayer.betInRound === 0) aiActionAmount = BIG_BLIND_AMOUNT_CONFIG; // 아직 아무도 벳 안했고, 나도 블라인드 아니면 BB만큼 내야 림프
                    }
                    else {
                        decisionType = "FOLD";
                    }
                } else { // 누군가 이미 돈을 걸어서 내가 돈을 내야 하는 상황 (amountToCall > 0)
                    const potOdds = calculatePotOdds(amountToCall, pot + currentBet);
                    // === AI 로직 수정: 프리플랍 3-Bet 기준 및 사이즈 조정 ===
                    let threeBetThreshold = (0.75 / tightnessMod) * aggressionMod; // 3벳 기준 (0.72 -> 0.75로 약간 올림)
                    let threeBetMultiplier = (1.7 + aggressionMod * 0.5); // 3벳 시 얼마를 더 올릴지 정하는 배수 (기본값을 약간 낮춤)

                    if (activeOpponents.length >= 2) { // 나 말고도 2명 이상 살아있으면 (즉, 팟에 3명 이상 연루 가능성)
                        threeBetThreshold *= 1.20; // 3벳 기준을 20% 더 높임
                        threeBetMultiplier *= 0.8;  // 3벳 크기 배수를 80%로 줄임
                    } else if (activeOpponents.length === 1) { // 나 말고 1명 살아있으면 (즉, 원레이저 외 추가 상대)
                        threeBetThreshold *= 1.10; // 3벳 기준을 10% 더 높임
                        threeBetMultiplier *= 0.9;  // 3벳 크기 배수를 90%로 줄임
                    }
                    let threeBetTargetAdditional = Math.floor((currentBet * threeBetMultiplier) + pot * 0.05); // 3벳 시 추가 금액 계산 (팟 기여도 줄임)
                    threeBetTargetAdditional = Math.max(minRaiseAmount, threeBetTargetAdditional - currentBet); // 실제 추가금액이 최소 레이즈액은 넘도록
                    // === AI 로직 수정 끝 ===

                    if (currentBet >= aiPlayer.chips + aiPlayer.betInRound) { // 상대 베팅이 내 올인 금액보다 크거나 같으면
                        decisionType = (holeCardStrength > (callThreshold * 0.80 / tightnessMod)) ? "CHECK_CALL" : "FOLD";
                        if (decisionType === "CHECK_CALL") aiActionAmount = amountToCall;
                    } else if (holeCardStrength > threeBetThreshold && amountToCall < aiPlayer.chips / 2.5) { // 내 패가 (새롭게 조정된) 3벳 기준보다 좋고...
                        decisionType = "BET_RAISE";
                        aiActionAmount = threeBetTargetAdditional; // (새롭게 조정된) 만큼 또 레이즈! (3-Bet)
                    } else if (holeCardStrength > callThreshold || (holeCardStrength > 0.22 && potOdds < 0.42 && activeOpponents.length <= 1) || (aiPlayer.isBB && potOdds < 0.48 && holeCardStrength > 0.18)) {
                        decisionType = "CHECK_CALL";
                        aiActionAmount = amountToCall;
                    } else {
                        // === AI 로직 수정: 프리플랍 블러프 3-Bet 빈도 조정 ===
                        let bluff3BetChance = 0.12 * aggressionMod;
                        if (activeOpponents.length >= 2) {
                            bluff3BetChance *= 0.5; // 상대 많으면 블러프 3벳 확률 반으로 줄임
                        } else if (activeOpponents.length === 1) {
                            bluff3BetChance *= 0.75;
                        }
                        // === AI 로직 수정 끝 ===
                        const lastRaiserPlayerObj = players.find(p => p.id === lastRaiserId);
                        if (lastRaiserPlayerObj &&
                            (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer" || aiPlayer.isBB) &&
                            (lastRaiserPlayerObj.positionCategory.includes("Early") || lastRaiserPlayerObj.positionCategory === "UTG" || lastRaiserPlayerObj.positionCategory.includes("Middle")) &&
                            Math.random() < bluff3BetChance && amountToCall < aiPlayer.chips / 2.8) {
                            decisionType = "BET_RAISE";
                            aiActionAmount = Math.floor(threeBetTargetAdditional * (0.85 + Math.random() * 0.2));
                            isBluffing = true;
                        } else {
                            decisionType = "FOLD";
                        }
                    }
                }
            } else { // 포스트플랍 (FLOP, TURN, RIVER)
                let valueBetStrength = 0.52 / tightnessMod;
                let semiBluffStrength = 0.28 / tightnessMod;
                let callStrength = 0.22 / tightnessMod;
                let checkRaiseStrength = 0.65 / tightnessMod * aggressionMod;

                // === AI 로직 수정: 포스트플랍 C-Bet, Probe Bet 등에서 activeOpponents 고려 강화 ===
                if (gamePhase === "FLOP" && lastRaiserId === aiPlayer.id && amountToCall === 0) { // C-Bet 상황
                    let cbetProb = (0.55 + 0.25 * aggressionMod);
                    if (boardInfo.type === "dry_uncoordinated") cbetProb = Math.min(0.95, cbetProb * 1.3);
                    else if (boardInfo.isWet) cbetProb *= 0.7;

                    if (activeOpponents.length === 1) { // 헤즈업 팟
                        if (boardInfo.highCardValue >= RANK_VALUES.Q && !boardInfo.isWet) cbetProb = Math.min(0.95, cbetProb * 1.15);
                    } else if (activeOpponents.length > 1) { // 멀티웨이 팟
                        cbetProb *= (1 / (1 + 0.50 * (activeOpponents.length - 1))); // 감소폭 기존 0.4 -> 0.50으로 증가
                    }

                    if (effectiveHandStrength > 0.45 || (drawPotential.outs >= 7 && Math.random() < 0.7) || Math.random() < cbetProb) {
                        decisionType = "BET_RAISE";
                        let cbetSizeRatio = 0.35 + Math.random() * 0.30 * aggressionMod;
                        if (boardInfo.isWet) cbetSizeRatio = Math.min(0.75, cbetSizeRatio * 1.2);
                        if (activeOpponents.length > 1) cbetSizeRatio *= 0.8; // 멀티웨이면 C-Bet 사이즈도 줄임
                        aiActionAmount = Math.floor(pot * cbetSizeRatio);
                        if (effectiveHandStrength < 0.4 && drawPotential.outs < 5 && Math.random() < cbetProb) isBluffing = true;
                    } else {
                        decisionType = "CHECK_CALL"; // 체크 (C-Bet 안함)
                    }
                } else if (amountToCall === 0 && (gamePhase === "TURN" || gamePhase === "RIVER") &&
                           ((lastRaiserId !== aiPlayer.id && players.find(p=>p.id===lastRaiserId)?.previousAction === 'CHECK_CALL' && players.find(p=>p.id===lastRaiserId)?.betInRound === 0) ||
                           (lastRaiserId === -1 && players.filter(p=>currentHandActivePlayerIdsOrder.includes(p.id)).every(p => p.isFolded || p.isAllIn || (p.hasActedThisBettingRound && p.betInRound === 0) || p.id === aiPlayer.id)))
                          ) { // 프로브 벳 상황 (앞에서 체크로 넘어왔을 때)
                    let probeBetProb = 0.38 * aggressionMod;
                    if(boardInfo.type === "dry_uncoordinated" || (boardInfo.type === "paired" && !boardInfo.isWet) ) probeBetProb = Math.min(0.8, probeBetProb * 1.25);

                    if (activeOpponents.length > 0) { // 프로브벳도 상대가 있으면 확률 감소
                        probeBetProb *= (1 / (1 + 0.3 * activeOpponents.length));
                    }

                    if (effectiveHandStrength > 0.42 || (drawPotential.outs >= 5 && Math.random() < 0.6) || Math.random() < probeBetProb) {
                        decisionType = "BET_RAISE";
                        let probeBetSizeRatio = 0.38 + Math.random() * 0.28 * aggressionMod;
                        if (activeOpponents.length > 0) probeBetSizeRatio *= 0.85; // 상대 있으면 프로브벳 사이즈도 약간 줄임
                        aiActionAmount = Math.floor(pot * probeBetSizeRatio);
                        if (effectiveHandStrength < 0.38 && drawPotential.outs < 4 && Math.random() < probeBetProb) isBluffing = true;
                    } else {
                        decisionType = "CHECK_CALL"; // 체크
                    }
                } else if (amountToCall === 0) { // 일반적인 체크 후 벳 상황
                    if (effectiveHandStrength > valueBetStrength) {
                        decisionType = "BET_RAISE";
                        let valueBetSizeRatio = 0.48 + effectiveHandStrength * 0.30 * aggressionMod;
                        if (boardInfo.isWet) valueBetSizeRatio = Math.min(0.8, valueBetSizeRatio * 1.15);
                        if (activeOpponents.length > 1) valueBetSizeRatio *= 0.8; // 멀티웨이면 밸류벳 사이즈도 약간 줄임
                        aiActionAmount = Math.floor(pot * valueBetSizeRatio);
                    } else if (effectiveHandStrength > semiBluffStrength && (drawPotential.outs >= 5 || Math.random() < (0.33 * aggressionMod))) {
                        decisionType = "BET_RAISE";
                        let semiBluffBetSizeRatio = 0.30 + Math.random() * 0.3 * aggressionMod;
                        if (activeOpponents.length > 1) semiBluffBetSizeRatio *= 0.75; // 멀티웨이면 세미블러프벳 사이즈도 줄임
                        aiActionAmount = Math.floor(pot * semiBluffBetSizeRatio);
                        if (effectiveHandStrength < 0.38 && drawPotential.outs < 8) isBluffing = true;
                    } else {
                        decisionType = "CHECK_CALL"; // 체크
                    }
                } else { // 상대가 벳/레이즈 해서 콜/레이즈/폴드 결정
                    const potOdds = calculatePotOdds(amountToCall, pot + currentBet);
                    // 체크-레이즈 조건 강화
                    let checkRaiseProbMod = 1.0;
                    if (activeOpponents.length >= 1) { // 체크-레이즈는 최소 한명의 상대가 더 있어야 의미가 있음
                        checkRaiseProbMod = 1 / (1 + 0.3 * activeOpponents.length);
                    }

                    if ((aiPlayer.positionCategory.includes("Early") || aiPlayer.positionCategory === "SB" || aiPlayer.positionCategory === "BB") &&
                        !aiPlayer.hasActedThisBettingRound && effectiveHandStrength > checkRaiseStrength &&
                        amountToCall < pot * 0.75 && Math.random() < (0.18 * aggressionMod * checkRaiseProbMod) && // 확률에 activeOpponent 수 반영
                        (!boardInfo.isWet || drawPotential.outs > 7)) {
                        decisionType = "BET_RAISE"; // 체크-레이즈
                        let checkRaiseSizeMultiplier = 1.8 + aggressionMod * 0.8;
                        if (activeOpponents.length >= 1) checkRaiseSizeMultiplier *= (0.85 / (1 + 0.05 * activeOpponents.length));
                        aiActionAmount = Math.floor(amountToCall * checkRaiseSizeMultiplier + pot * 0.2);
                        if(effectiveHandStrength < (checkRaiseStrength * 0.8) && drawPotential.outs < 5) isBluffing = true;
                    } else if (currentBet >= aiPlayer.chips + aiPlayer.betInRound) { // 상대 베팅이 내 올인 금액보다 크거나 같으면
                        decisionType = (effectiveHandStrength > (callStrength * 0.85) + (drawPotential.outs * 0.018)) ? "CHECK_CALL" : "FOLD";
                        if (decisionType === "CHECK_CALL") aiActionAmount = amountToCall;
                    } else if (effectiveHandStrength > (valueBetStrength * 1.1) && amountToCall < aiPlayer.chips / 1.4) {
                        decisionType = "BET_RAISE"; // 밸류 레이즈
                        let valueRaiseMultiplier = 1.7 + aggressionMod * 0.75;
                        if (activeOpponents.length >= 1) valueRaiseMultiplier *= (0.9 / (1 + 0.1 * activeOpponents.length));
                        aiActionAmount = Math.floor(amountToCall * valueRaiseMultiplier + pot * 0.22);
                    } else if (effectiveHandStrength > callStrength || (drawPotential.outs >= 8 && potOdds < 0.48) || (drawPotential.outs >=5 && potOdds < 0.40)) {
                        decisionType = "CHECK_CALL"; // 콜
                        aiActionAmount = amountToCall;
                    } else if (drawPotential.outs >= 7 && potOdds < (0.35 / tightnessMod) && Math.random() < (0.35 * aggressionMod) && !boardInfo.isPaired && gamePhase !== "RIVER") {
                        decisionType = "BET_RAISE"; // 세미블러프 레이즈
                        let semiBluffRaiseMultiplier = 1.6 + aggressionMod * 0.6;
                        if (activeOpponents.length >= 1) semiBluffRaiseMultiplier *= (0.8 / (1 + 0.1 * activeOpponents.length));
                        aiActionAmount = Math.floor(amountToCall * semiBluffRaiseMultiplier + pot * 0.15);
                        isBluffing = true;
                    } else {
                        const spr = aiPlayer.chips > 0 ? pot / aiPlayer.chips : 100;
                        if (spr < 1.5 && effectiveHandStrength > 0.12 && potOdds < 0.65) {
                             decisionType = "CHECK_CALL"; // 팟 작고, 칩 적을 때 약한 패로도 콜
                             aiActionAmount = amountToCall;
                        } else {
                            decisionType = "FOLD";
                        }
                    }
                }
                // === AI 로직 수정 끝 ===
            }

            // 블러프 결정 로직 (기존 폴드/약한 체크 상황에서)
            if (decisionType === "FOLD" || (decisionType === "CHECK_CALL" && amountToCall === 0 && effectiveHandStrength < 0.35)) {
                let currentBluffChance = BLUFF_PROBABILITY_BASE * aggressionMod * (boardInfo.isWet ? 0.8 : 1.25);
                if (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer" || aiPlayer.positionCategory === "SB_Dealer") currentBluffChance *= 1.4;
                if (gamePhase === "RIVER") {
                    const communitySuitCounts = {}; communityCards.forEach(c => communitySuitCounts[c.suit] = (communitySuitCounts[c.suit] || 0) + 1);
                    const flushPossibleOnBoardCount = Math.max(...Object.values(communitySuitCounts).map(Number), 0);
                    if (flushPossibleOnBoardCount === 4 && currentMadeHandDetails.strength < HAND_STRENGTH.FLUSH) { currentBluffChance *= 1.8; }
                    else if (flushPossibleOnBoardCount === 3 && currentMadeHandDetails.strength < HAND_STRENGTH.FLUSH && drawPotential.type.includes("flush")) { currentBluffChance *= 1.6; }
                    if (currentMadeHandDetails.strength < HAND_STRENGTH.ONE_PAIR && !boardInfo.isPaired && (boardInfo.type === "dry_uncoordinated" || boardInfo.highCardValue < RANK_VALUES["10"])) { currentBluffChance *= 1.6; }
                }
                if (activeOpponents.every(opp => opp.previousAction === 'CHECK_CALL' && opp.betInRound === 0 && opp.chips > 0)) { currentBluffChance *= 1.75; }
                const lastRaiserPlayerObjForBluff = players.find(p=>p.id === lastRaiserId);
                if (lastRaiserPlayerObjForBluff && lastRaiserPlayerObjForBluff.previousAction === "CHECK_CALL" && lastRaiserPlayerObjForBluff.betInRound === 0) { currentBluffChance *= 1.35; }

                // === AI 로직 수정: 블러프 빈도 조정 (상대방 수 고려) ===
                if (activeOpponents.length >= 2) { // 나 말고 2명 이상 살아있으면
                    currentBluffChance *= 0.4; // 블러프 확률을 40% 수준으로 대폭 낮춤
                } else if (activeOpponents.length === 1) { // 나 말고 1명 살아있으면
                    currentBluffChance *= 0.7; // 블러프 확률을 70% 수준으로 낮춤
                }
                // === AI 로직 수정 끝 ===

                if (Math.random() < currentBluffChance && amountToCall < aiPlayer.chips * 0.65) {
                    isBluffing = true;
                    decisionType = "BET_RAISE";
                    let bluffSizeRatioBase = (gamePhase === "RIVER") ? 0.60 : 0.50;
                    let bluffSizeRatio = bluffSizeRatioBase + Math.random() * 0.35 * aggressionMod;
                    // === AI 로직 수정: 블러프 사이즈 조정 (상대방 수 고려) ===
                    if (activeOpponents.length >= 2) {
                        bluffSizeRatio *= 0.7; // 상대 많으면 블러프 사이즈도 줄임
                    } else if (activeOpponents.length === 1) {
                        bluffSizeRatio *= 0.85;
                    }
                    // === AI 로직 수정 끝 ===
                    aiActionAmount = Math.floor(pot * bluffSizeRatio);
                }
            }

            aiActionAmount = Math.max(0, Math.floor(aiActionAmount)); // 음수 베팅 방지
            let actualChipsToCommit = 0;

            // AI 결정 유효성 검사 및 실제 칩 커밋양 계산
            if (decisionType === "BET_RAISE") {
                let intendedAdditionalBet = aiActionAmount; // AI가 추가로 베팅하려는 금액
                let intendedTotalBetForRound = aiPlayer.betInRound + intendedAdditionalBet; // 이번 라운드 총 베팅액

                // 너무 작은 벳/레이즈 방지
                if (currentBet === 0) { // 벳 상황
                    if (intendedTotalBetForRound < minRaiseAmount && intendedTotalBetForRound < aiPlayer.chips + aiPlayer.betInRound) { // 최소 벳보다 작고 올인이 아니면
                        // 약한 패면 체크, 아니면 최소벳 시도 또는 콜 가능한 상황이면 콜
                        if (effectiveHandStrength < 0.3 && !isBluffing) { // 패가 약하고 블러핑도 아니면
                             decisionType = "CHECK_CALL"; actualChipsToCommit = 0; // 체크로 변경
                        } else { // 최소벳 시도
                           actualChipsToCommit = Math.min(aiPlayer.chips, minRaiseAmount - aiPlayer.betInRound);
                           if (actualChipsToCommit < 0) actualChipsToCommit = 0; // 이미 더 많이 냈으면 0
                           if (aiPlayer.betInRound + actualChipsToCommit < minRaiseAmount && aiPlayer.chips > minRaiseAmount - aiPlayer.betInRound) { // 그래도 최소벳 안되면
                                decisionType = "CHECK_CALL"; actualChipsToCommit = 0; // 체크
                           } else if (aiPlayer.chips <= minRaiseAmount - aiPlayer.betInRound) { // 올인벳이 최소벳보다 작을 수 있음
                               actualChipsToCommit = aiPlayer.chips;
                           }
                        }
                    } else { // 정상적인 벳
                        actualChipsToCommit = Math.min(aiPlayer.chips, intendedAdditionalBet);
                    }
                } else { // 레이즈 상황
                    if (intendedTotalBetForRound < currentBet + minRaiseAmount && intendedTotalBetForRound < aiPlayer.chips + aiPlayer.betInRound) { // 최소 레이즈보다 작고 올인이 아니면
                        // 콜 가능한지 확인, 아니면 폴드
                        if (amountToCall <= aiPlayer.chips && amountToCall >= 0) { // 콜 가능하면 콜
                            decisionType = "CHECK_CALL";
                            actualChipsToCommit = amountToCall;
                        } else { // 콜 불가능하면 폴드
                            decisionType = "FOLD";
                            actualChipsToCommit = 0;
                        }
                    } else if (intendedTotalBetForRound === currentBet) { // 레이즈 금액이 현재 벳과 같으면 그냥 콜
                        decisionType = "CHECK_CALL";
                        actualChipsToCommit = amountToCall;
                    }
                     else { // 정상적인 레이즈
                        actualChipsToCommit = Math.min(aiPlayer.chips, intendedAdditionalBet);
                    }
                }
            } else if (decisionType === "CHECK_CALL") {
                actualChipsToCommit = Math.min(aiPlayer.chips, amountToCall); // 콜 금액 (체크면 amountToCall이 0)
                if (actualChipsToCommit < 0) actualChipsToCommit = 0; // 이미 더 많이 낸 경우
            } else { // FOLD
                actualChipsToCommit = 0;
            }


            aiPlayer.previousAction = decisionType;
            let feedbackText = "";
            let feedbackClass = "";

            switch (decisionType) {
                case 'FOLD':
                    // 폴드는 amountToCall > 0 일 때만 의미있게 피드백. (체크 상황에서 폴드 결정된 건 사실상 체크)
                    if (amountToCall > 0 || currentBet > 0 || (aiPlayer.previousAction === "FOLD" && !(amountToCall === 0 && currentBet === 0 && aiPlayer.betInRound === 0 ))) {
                        aiPlayer.isFolded = true;
                        feedbackText = "폴드..."; feedbackClass = "feedback-fold";
                        displayMessage(`${aiPlayer.name} 폴드.`, "ai-action");
                    } else { // 실제로는 체크한 것과 같음 (폴드 결정했지만 액션이 체크)
                        feedbackText = "체크"; feedbackClass = "feedback-check";
                        displayMessage(`${aiPlayer.name} 체크.`, "ai-action");
                         actualChipsToCommit = 0; // 폴드 결정이어도 체크 상황이면 칩 변화 없음
                    }
                    break;
                case 'CHECK_CALL':
                    if (amountToCall > 0) {
                        feedbackText = "콜!"; feedbackClass = "feedback-call";
                    } else {
                        feedbackText = "체크"; feedbackClass = "feedback-check";
                        actualChipsToCommit = 0; // 체크는 칩 변화 없음
                    }
                    aiPlayer.chips -= actualChipsToCommit; aiPlayer.betInRound += actualChipsToCommit; pot += actualChipsToCommit;
                    displayMessage(`${aiPlayer.name} ${feedbackText.replace("!", "")} (총 ${Math.floor(aiPlayer.betInRound)}원).`, "ai-action");
                    if (aiPlayer.chips <= 0 && actualChipsToCommit >= 0 && !(aiPlayer.chips === 0 && actualChipsToCommit === 0)) { // 0원 콜 제외
                         aiPlayer.isAllIn = true;
                         if (aiPlayer.chips < 0) aiPlayer.chips = 0; // 칩이 음수가 되지 않도록
                    }
                    break;
                case 'BET_RAISE':
                    // 실제 커밋할 칩이 없으면 (예: 최소벳 미달로 체크 전환된 경우 등) 여기서 처리하면 안됨.
                    // 위에서 decisionType이 CHECK_CALL로 바뀌었어야 함.
                    // 이 블록은 실제 벳/레이즈가 일어날 때만 실행되어야 함.
                    if (actualChipsToCommit <= 0 && !(aiPlayer.chips ===0 && aiPlayer.betInRound > 0) ) { // 0원 벳/레이즈 방지 (단, 올인 상황에서 이미 건 돈이 있을 수 있음)
                         // 이 경우 실제로는 체크나 콜이 되어야 함.
                         // 하지만 로직상 여기까지 왔다면 문제가 있을 수 있으므로, 안전하게 체크로 처리.
                         feedbackText = "체크"; feedbackClass = "feedback-check";
                         displayMessage(`${aiPlayer.name} 체크 (내부 조정).`, "ai-action");
                         // pot 이나 betInRound 변경 없음.
                    } else {
                        if (currentBet === 0) {
                            feedbackText = "벳!"; feedbackClass = "feedback-bet";
                        } else {
                            feedbackText = "레이즈!"; feedbackClass = "feedback-raise";
                        }
                        aiPlayer.chips -= actualChipsToCommit; aiPlayer.betInRound += actualChipsToCommit; pot += actualChipsToCommit;
                        displayMessage(`${aiPlayer.name} ${Math.floor(actualChipsToCommit)}원 ${currentBet === 0 ? '벳' : '레이즈'} (총 ${Math.floor(aiPlayer.betInRound)}원).`, "ai-action");
                        if (aiPlayer.chips <= 0 && actualChipsToCommit > 0) {
                             aiPlayer.isAllIn = true;
                             if (aiPlayer.chips < 0) aiPlayer.chips = 0; // 칩이 음수가 되지 않도록
                        }
                        if (aiPlayer.betInRound > currentBet) {
                            minRaiseAmount = Math.max(BIG_BLIND_AMOUNT_CONFIG, aiPlayer.betInRound - currentBet); // 최소 레이즈액은 BB보다 작을 수 없음
                            currentBet = aiPlayer.betInRound;
                            lastRaiserId = aiPlayer.id;
                            players.forEach(p => { if (p.id !== aiPlayer.id && !p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
                        }
                    }
                    break;
            }

            if (feedbackText && !aiPlayer.isFolded) {
                 showEnhancedFeedback(aiPlayer.id, feedbackText, feedbackClass);
            } else if (aiPlayer.isFolded && feedbackText === "폴드...") {
                 showEnhancedFeedback(aiPlayer.id, feedbackText, feedbackClass);
            }
            updateOverallUI(); await switchToNextPlayerOrEndRound();
        }
        async function switchToNextPlayerOrEndRound() {
            const unfoldedPlayersStillInHand = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded);
            if (unfoldedPlayersStillInHand.length <= 1) {
                if (unfoldedPlayersStillInHand.length === 1) {
                    const winner = unfoldedPlayersStillInHand[0];
                    displayMessage(`${winner.name} 승리! 다른 플레이어 폴드. (팟: ${Math.floor(pot)}원)`, "game-event");
                    winner.chips += pot; pot = 0;
                    if (winner.type === 'human') {
                        showEnhancedFeedback(winner.id, "승리!", "feedback-win");
                    }
                } else {
                    displayMessage("모든 플레이어가 폴드했습니다.", "game-event");
                     const humanPlayer = players.find(p => p.type === 'human');
                     if (humanPlayer && humanPlayer.isFolded) { // 사람이 폴드해서 아무도 안남은 경우
                        // showEnhancedFeedback(humanPlayer.id, "패배ㅠㅠ...", "feedback-lose"); // 폴드 피드백으로 대체 가능
                     }
                }
                await endCurrentHand(false); return;
            }
            let bettingOver = true; const activePlayersWhoCanBet = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            if (activePlayersWhoCanBet.length === 0 && unfoldedPlayersStillInHand.length > 0) { bettingOver = true; }
            else if (activePlayersWhoCanBet.length > 0) {
                bettingOver = activePlayersWhoCanBet.every(p => p.hasActedThisBettingRound && (p.betInRound === currentBet || p.chips === 0));
                if (bettingOver && gamePhase === "PREFLOP" && currentBet === BIG_BLIND_AMOUNT_CONFIG) {
                    const bbPlayer = players.find(p => p.isBB && currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn);
                    const lastRaiserPlayerObj = players.find(p=>p.id === lastRaiserId);
                    if (bbPlayer && !bbPlayer.hasActedThisBettingRound && (!lastRaiserPlayerObj || lastRaiserPlayerObj.id === bbPlayer.id || players.filter(plr => currentHandActivePlayerIdsOrder.includes(plr.id)).every(plr => plr.isFolded || plr.isAllIn || plr.betInRound <= BIG_BLIND_AMOUNT_CONFIG || plr.id === bbPlayer.id)) ) {
                         const currentPlayerObjectForBBCheck = players[currentPlayerIndex]; if(currentPlayerObjectForBBCheck && currentPlayerObjectForBBCheck.id === bbPlayer.id){ bettingOver = false; }
                    }
                }
            } else { bettingOver = true; }
            if (bettingOver) { await advanceGamePhase(); }
            else {
                let nextPlayerFound = false; let initialSearchOrderIndex = currentTurnInOrderIndex;
                for (let i = 0; i < currentHandActivePlayerIdsOrder.length; i++) {
                    currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length;
                    const nextPlayerIdToAct = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]; const nextPlayer = players.find(p => p.id === nextPlayerIdToAct);
                    if (nextPlayer && !nextPlayer.isFolded && !nextPlayer.isAllIn && nextPlayer.chips > 0) {
                        if (!nextPlayer.hasActedThisBettingRound || (nextPlayer.betInRound < currentBet && nextPlayer.chips > 0)) { currentPlayerIndex = players.findIndex(p => p.id === nextPlayerIdToAct); nextPlayerFound = true; break; }
                    }
                    if (currentTurnInOrderIndex === initialSearchOrderIndex && i >= currentHandActivePlayerIdsOrder.length -1 && !nextPlayerFound) { console.warn("Full loop in switchToNextPlayer without finding next actor (bettingOver=false). Advancing."); await advanceGamePhase(); return; }
                }
                if (nextPlayerFound) { await processPlayerTurn(); }
                else { console.warn("SwitchToNext: Betting not over logically, but no specific next player found. Advancing."); await advanceGamePhase(); }
            }
        }
        async function advanceGamePhase() {
            displayMessage(`--- ${gamePhase} 베팅 종료 ---`, "game-event");
            const activePlayersForShowdown = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded);
            const playersCanStillBet = activePlayersForShowdown.filter(p => !p.isAllIn && p.chips > 0);
            const playersAllInThisRound = activePlayersForShowdown.filter(p => p.isAllIn); let runOutBoard = false;
            if (activePlayersForShowdown.length > 0) { if (playersCanStillBet.length === 0 && playersAllInThisRound.length >= 1) { runOutBoard = true; } else if (playersCanStillBet.length === 1 && playersAllInThisRound.length >= 1) { const soleBettor = playersCanStillBet[0]; let allAllInsCoveredByBettor = true; for (const pAllIn of playersAllInThisRound) { if (soleBettor.betInRound < pAllIn.betInRound && soleBettor.chips > 0) { allAllInsCoveredByBettor = false; break; } } if (allAllInsCoveredByBettor) runOutBoard = true; } }
            if ( runOutBoard && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND") {
                displayMessage("올인 상황 또는 베팅 가능한 플레이어가 한명 이하. 남은 카드 공개.", "game-event"); await revealAllAICards();
                if (gamePhase === "PREFLOP") { await dealCommunityCardsForPhase("FLOP"); gamePhase = "FLOP"; }
                if (gamePhase === "FLOP" && communityCards.length < 4) { await dealCommunityCardsForPhase("TURN"); gamePhase = "TURN"; }
                if (gamePhase === "TURN" && communityCards.length < 5) { await dealCommunityCardsForPhase("RIVER"); gamePhase = "RIVER"; }
                gamePhase = "SHOWDOWN";
            }
            if (gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND") {
                switch (gamePhase) {
                    case "PREFLOP": gamePhase = "FLOP"; await dealCommunityCardsForPhase("FLOP"); break;
                    case "FLOP": gamePhase = "TURN"; await dealCommunityCardsForPhase("TURN"); break;
                    case "TURN": gamePhase = "RIVER"; await dealCommunityCardsForPhase("RIVER"); break;
                    case "RIVER": gamePhase = "SHOWDOWN"; break;
                }
            }
            updateOverallUI();
            if (gamePhase === "SHOWDOWN") { await determineWinner(); }
            else if (gamePhase !== "END_HAND") { players.forEach(p => { if(!p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; }); await startBettingRound(); }
        }
        async function dealCommunityCardsForPhase(phaseToDeal) { displayMessage(`--- ${phaseToDeal} 카드 공개 ---`, "game-event"); burnCard(); if (phaseToDeal === "FLOP") { if (communityCards.length < 3) for (let i=0; i<3; i++) await dealAnimatedCommunityCard(dealCardFromDeck(false)); } else if (phaseToDeal === "TURN") { if (communityCards.length < 4) await dealAnimatedCommunityCard(dealCardFromDeck(false)); } else if (phaseToDeal === "RIVER") { if (communityCards.length < 5) await dealAnimatedCommunityCard(dealCardFromDeck(false)); } await sleep(500);  }
        async function revealAllAICards() { for (const p of players) { if (p.type === 'ai' && !p.isFolded) { for (const card of p.cards) { if (card.hidden) { revealHiddenCard(p, card); await sleep(200); }}}} await sleep(400); }
        async function endCurrentHand(showdownOccurred) {
            gamePhase = "END_HAND"; updateOverallUI();
            const activePlayersWithChips = players.filter(p => p.chips > 0); const controlBtnArea = document.getElementById('control-buttons-area');
            const humanPlayer = players.find(p => p.type === 'human');

            if (activePlayersWithChips.length <= 1) {
                const winner = activePlayersWithChips.length > 0 ? activePlayersWithChips[0] : (players.length > 0 ? players.find(p => p.isAllIn && !p.isFolded) : null);
                displayMessage(winner ? `${winner.name} 최종 승리!` : "게임 종료 - 최종 승자 없음", "game-event");

                if (winner && winner.type === 'human') {
                    showEnhancedFeedback(winner.id, "최종 승리!", "feedback-win");
                } else if (humanPlayer && humanPlayer.chips <= 0 && !activePlayersWithChips.some(ap => ap.id === humanPlayer.id)) {
                     // 사람이 칩을 다 잃고 최종 승자가 아닐 때
                    showEnhancedFeedback(humanPlayer.id, "최종 패배ㅠㅠ", "feedback-lose");
                }


                controlBtnArea.innerHTML = `<button id="start-game-button-main">새 게임</button><button id="continue-game-button">이어하기</button>`;
                document.getElementById('start-game-button-main').addEventListener('click', initializeNewGame);
                document.getElementById('continue-game-button').addEventListener('click', () => { if (players.length === 0 || players.filter(p=>p.chips > 0).length <=1) { initializeNewGame(); } else { actualNumPlayersInCurrentGame = players.length; players.forEach(p => { if(p.chips > 0) p.isFolded = false; }); startNewHand(); } });
                numPlayersSelect.disabled = false; startingChipsInputEl.disabled = false; bigBlindInputEl.disabled = false;
            } else {
                controlBtnArea.innerHTML = `<button id="next-hand-button">다음 핸드</button><button id="start-game-button-main" style="margin-left: 10px;">새 게임</button>`;
                const nextHandBtn = document.getElementById('next-hand-button'); if(nextHandBtn) nextHandBtn.addEventListener('click', startNewHand);
                const newGameBtnInMid = document.getElementById('start-game-button-main'); if(newGameBtnInMid) newGameBtnInMid.addEventListener('click', initializeNewGame);
                numPlayersSelect.disabled = true; startingChipsInputEl.disabled = true; bigBlindInputEl.disabled = true;
            }
            checkCallButton.disabled = true; betRaiseButton.disabled = true; raiseInput.disabled = true; foldButton.disabled = true;
        }
        function evaluateHoleCards(holeCards) { if (!holeCards || holeCards.length < 2) return 0; const [c1, c2] = holeCards; let score = (c1.value + c2.value) / 28; if (c1.rank === c2.rank) score += 0.35; if (c1.suit === c2.suit) score += 0.15; if (Math.abs(c1.value - c2.value) === 1 || (c1.value === RANK_VALUES.A && c2.value === RANK_VALUES["2"]) || (c2.value === RANK_VALUES.A && c1.value === RANK_VALUES["2"]) || (Math.abs(c1.value - c2.value) === 12 && (c1.value === RANK_VALUES.A || c2.value === RANK_VALUES.A))) { score += 0.1; } if (Math.abs(c1.value - c2.value) <= 4 && Math.abs(c1.value - c2.value) > 1) score += 0.05; return Math.min(1, score); }
        function evaluateDrawPotential(allCommunityCards, holeCards) {
            let outs = 0; let drawType = "none"; const revealedCommunityCards = allCommunityCards.filter(c => c.revealed !== false);
            const combinedCardsForDraw = [...holeCards, ...revealedCommunityCards];
            if (combinedCardsForDraw.length < 4 || !holeCards || holeCards.length < 2) return { outs: 0, type: "none", hasFlushDraw: false, hasStraightDraw: false };
            let hasFlushDraw = false; let hasStraightDraw = false; const suitCounts = {};
            combinedCardsForDraw.forEach(c => suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1);
            for (const suit in suitCounts) { if (suitCounts[suit] === 4 && (holeCards[0].suit === suit || holeCards[1].suit === suit)) { outs += (13 - 4); drawType = drawType === "none" ? "flush" : "combo"; hasFlushDraw = true; break; } }
            const uniqueRanks = [...new Set(combinedCardsForDraw.map(c => c.value))].sort((a, b) => a - b);
            if (uniqueRanks.length >= 3) {
                 for (let i = 0; i <= uniqueRanks.length - 4; i++) {
                    const sub = uniqueRanks.slice(i, i + 4);
                    if (sub[3] - sub[0] === 3) {
                        const usesHoleCard = sub.some(r => holeCards.some(hc => hc.value === r));
                        if(usesHoleCard){ let tempOuts = 8; if (sub[0] === RANK_VALUES["2"]) tempOuts = 4; if (sub[3] === RANK_VALUES.A) tempOuts = 4; if (drawType === "flush" || drawType === "combo") tempOuts = Math.max(1, tempOuts - 2); outs += tempOuts; drawType = (drawType === "flush" || drawType === "combo_straight_gutshot") ? "combo_OESD_flush" : (drawType === "none" ? "straight_OESD" : "combo_OESD"); hasStraightDraw = true; break; }
                    }
                }
                if (!hasStraightDraw && uniqueRanks.length >= 4) {
                    for (let i = 0; i <= uniqueRanks.length - 4; i++) {
                        const sub = uniqueRanks.slice(i, i + 4); const usesHoleCard = sub.some(r => holeCards.some(hc => hc.value === r)); if(!usesHoleCard) continue;
                        if ((sub[3] - sub[0] === 4 && ( (sub[1]-sub[0] > 1 && sub[2]-sub[1]===1 && sub[3]-sub[2]===1) || (sub[1]-sub[0] ===1 && sub[2]-sub[1]>1 && sub[3]-sub[2]===1) || (sub[1]-sub[0] ===1 && sub[2]-sub[1]===1 && sub[3]-sub[2]>1) ))) { let tempOuts = 4; if (drawType === "flush" || drawType === "combo_OESD_flush") tempOuts = Math.max(1, tempOuts - 1); outs += tempOuts; drawType = (drawType === "flush" || drawType === "combo_OESD_flush") ? "combo_gutshot_flush" : (drawType === "none" ? "straight_gutshot" : "combo_gutshot"); hasStraightDraw = true; break;}
                    }
                }
                const hasAce = uniqueRanks.includes(RANK_VALUES.A); const has2 = uniqueRanks.includes(RANK_VALUES["2"]); const has3 = uniqueRanks.includes(RANK_VALUES["3"]); const has4 = uniqueRanks.includes(RANK_VALUES["4"]); const has5 = uniqueRanks.includes(RANK_VALUES["5"]);
                if (hasAce && has2 && has3 && has4 && !has5 && (holeCards.some(hc=>[RANK_VALUES.A,2,3,4].includes(hc.value))) && !isStraightFiveHigh(uniqueRanks) && !hasStraightDraw) { outs +=4; drawType= drawType.includes("flush") ? "combo_gutshot_flush" : "straight_gutshot"; hasStraightDraw = true; }
                else if (has2 && has3 && has4 && has5 && !hasAce && (holeCards.some(hc=>[2,3,4,5].includes(hc.value))) && !isStraightFiveHigh(uniqueRanks) && !hasStraightDraw) { outs +=4; drawType= drawType.includes("flush") ? "combo_gutshot_flush" : "straight_gutshot"; hasStraightDraw = true; }
            }
            function isStraightFiveHigh(ranksArray) { return ranksArray.includes(RANK_VALUES.A)&&ranksArray.includes(RANK_VALUES["2"])&&ranksArray.includes(RANK_VALUES["3"])&&ranksArray.includes(RANK_VALUES["4"])&&ranksArray.includes(RANK_VALUES["5"]); }
            return { outs: Math.min(outs, 17), type: drawType, hasFlushDraw, hasStraightDraw };
        }
        function getCombinations(arr, k) { if (k === 0) return [[]]; if (!arr || arr.length < k) return []; if (arr.length === k) return [arr]; if (k === 1) return arr.map(e => [e]); const first = arr[0]; const woFirst = getCombinations(arr.slice(1), k - 1); const wFirst = woFirst.map(c => [first, ...c]); const fRest = getCombinations(arr.slice(1), k); return [...wFirst, ...fRest]; }
        function getHandDetails(sevenCards) { if (!sevenCards || sevenCards.length < 5) { return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: [0], handName: "카드 부족", bestHand: [] };} const all5CardCombinations = getCombinations(sevenCards, 5); if (!all5CardCombinations || all5CardCombinations.length === 0) { return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: [0], handName: "조합 생성 실패", bestHand: [] };} let bestHandFound = { strength: -1, rankValues: [0], handName: "N/A", bestHand: [] }; for (const fiveCardArr of all5CardCombinations) { const currentEval = evaluateSingleHand(fiveCardArr); if (currentEval.strength > bestHandFound.strength) { bestHandFound = currentEval; } else if (currentEval.strength === bestHandFound.strength) { for (let i = 0; i < currentEval.rankValues.length; i++) { if (currentEval.rankValues[i] > bestHandFound.rankValues[i]) { bestHandFound = currentEval; break; } if (currentEval.rankValues[i] < bestHandFound.rankValues[i]) { break; }}}} return bestHandFound; }
        function evaluateSingleHand(fiveCards) {
            const ranks = fiveCards.map(c => c.value).sort((a, b) => b - a); const suits = fiveCards.map(c => c.suit);
            const isFlush = suits.every(s => s === suits[0]); const rankCounts = {}; ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            let isStraight = false; const uniqueRanksForStraight = [...new Set(ranks)].sort((a,b) => b-a);
            if (uniqueRanksForStraight.length === 5 && uniqueRanksForStraight[0] - uniqueRanksForStraight[4] === 4) { isStraight = true; }
            let aceLowStraightRanks = null;
            if (uniqueRanksForStraight.length === 5 && uniqueRanksForStraight[0] === RANK_VALUES.A && uniqueRanksForStraight[1] === RANK_VALUES["5"] && uniqueRanksForStraight[2] === RANK_VALUES["4"] && uniqueRanksForStraight[3] === RANK_VALUES["3"] && uniqueRanksForStraight[4] === RANK_VALUES["2"]) { isStraight = true; aceLowStraightRanks = [RANK_VALUES["5"], RANK_VALUES["4"], RANK_VALUES["3"], RANK_VALUES["2"], RANK_VALUES.A_LOW]; }
            const finalRanksForComparison = aceLowStraightRanks ? aceLowStraightRanks : ranks.slice(0,5);
            if (isStraight && isFlush) { const isRoyalCandidate = ranks[0] === RANK_VALUES.A && ranks[1] === RANK_VALUES.K && ranks[2] === RANK_VALUES.Q && ranks[3] === RANK_VALUES.J && ranks[4] === RANK_VALUES["10"]; if (isRoyalCandidate) { return { strength: HAND_STRENGTH.ROYAL_FLUSH, rankValues: ranks.slice(0,5), handName: "로열 플러쉬", bestHand: fiveCards }; } return { strength: HAND_STRENGTH.STRAIGHT_FLUSH, rankValues: finalRanksForComparison, handName: "스트레이트 플러쉬", bestHand: fiveCards }; }
            const counts = Object.values(rankCounts);
            if (counts.includes(4)) { const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4)); const kicker = ranks.find(r => r !== quadRank); return { strength: HAND_STRENGTH.FOUR_OF_A_KIND, rankValues: [quadRank, kicker].filter(v => v !== undefined), handName: "포카드", bestHand: fiveCards };}
            if (counts.includes(3) && counts.includes(2)) { const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3)); const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2)); return { strength: HAND_STRENGTH.FULL_HOUSE, rankValues: [tripRank, pairRank].sort((a,b)=>b-a), handName: "풀하우스", bestHand: fiveCards };}
            if (isFlush) { return { strength: HAND_STRENGTH.FLUSH, rankValues: ranks.slice(0,5), handName: "플러쉬", bestHand: fiveCards };}
            if (isStraight) { return { strength: HAND_STRENGTH.STRAIGHT, rankValues: finalRanksForComparison, handName: "스트레이트", bestHand: fiveCards };}
            if (counts.includes(3)) { const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3)); const kickers = ranks.filter(r => r !== tripRank).sort((a,b) => b-a).slice(0,2); return { strength: HAND_STRENGTH.THREE_OF_A_KIND, rankValues: [tripRank, ...kickers], handName: "쓰리 오브 어 카인드", bestHand: fiveCards };}
            const numPairs = counts.filter(c => c === 2).length;
            if (numPairs === 2) { const pairRanksVal = []; for (const r in rankCounts) { if (rankCounts[r] === 2) pairRanksVal.push(parseInt(r)); } pairRanksVal.sort((a,b) => b-a); const kicker = ranks.find(r => !pairRanksVal.includes(r)); return { strength: HAND_STRENGTH.TWO_PAIR, rankValues: [...pairRanksVal, kicker].filter(v => v !== undefined), handName: "투 페어", bestHand: fiveCards };}
            if (numPairs === 1) { const pairRankVal = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2)); const kickers = ranks.filter(r => r !== pairRankVal).sort((a,b) => b-a).slice(0,3); return { strength: HAND_STRENGTH.ONE_PAIR, rankValues: [pairRankVal, ...kickers], handName: "원 페어", bestHand: fiveCards };}
            return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: ranks.slice(0,5), handName: "하이 카드", bestHand: fiveCards };
        }
        async function determineWinner() {
            displayMessage("--- 쇼다운 ---", "game-event"); await revealAllAICards();
            let eligiblePlayers = players.filter(p => !p.isFolded && currentHandActivePlayerIdsOrder.includes(p.id));
            if (eligiblePlayers.length === 0) { displayMessage("쇼다운 할 플레이어가 없습니다.", "game-event"); await endCurrentHand(true); return; }
            eligiblePlayers.forEach(p => { p.handDetails = getHandDetails([...p.cards, ...communityCards]); displayMessage(`${p.name}: ${p.handDetails.handName} (${p.handDetails.bestHand.map(c=>c.rank+c.suit).join(',')})`, "system-message"); });
            eligiblePlayers.sort((a, b) => { if (b.handDetails.strength !== a.handDetails.strength) return b.handDetails.strength - a.handDetails.strength; for (let i = 0; i < a.handDetails.rankValues.length; i++) { if (b.handDetails.rankValues[i] !== a.handDetails.rankValues[i]) return b.handDetails.rankValues[i] - a.handDetails.rankValues[i]; } return 0; });
            const winners = eligiblePlayers.filter(p => p.handDetails.strength === eligiblePlayers[0].handDetails.strength && p.handDetails.rankValues.every((val, index) => val === eligiblePlayers[0].handDetails.rankValues[index]));

            const humanPlayer = players.find(p => p.type === 'human');
            let humanWonThisShowdown = false;

            if (winners.length > 0) {
                const potPerWinner = Math.floor(pot / winners.length);
                winners.forEach(winner => {
                    winner.chips += potPerWinner;
                    displayMessage(`${winner.name} 승리! 팟 ${Math.floor(potPerWinner)}원 획득.`, "game-event");
                    if (winner.type === 'human') {
                        humanWonThisShowdown = true;
                        showEnhancedFeedback(winner.id, "승리!", "feedback-win");
                    }
                });
                pot = pot - (potPerWinner * winners.length); if (pot > 0 && winners.length > 0) winners[0].chips += pot; pot = 0;
            } else {
                displayMessage("승자를 결정할 수 없습니다.", "system-message");
            }

            if (humanPlayer && !humanWonThisShowdown && eligiblePlayers.some(ep => ep.id === humanPlayer.id)) {
                // 쇼다운에 참여했지만 이기지 못한 경우 (무승부 포함, 여기서는 패배로 간주)
                showEnhancedFeedback(humanPlayer.id, "패배ㅠㅠ...", "feedback-lose");
            }

            updateOverallUI(); await endCurrentHand(true);
        }
        // 페이지 로드 시 포커 족보 예시 카드 생성
        document.addEventListener('DOMContentLoaded', () => {
            populatePokerHandExamples();
        });
        mainStartGameButton.addEventListener('click', initializeNewGame);
        checkCallButton.addEventListener('click', () => handleHumanAction('CHECK_CALL'));
        betRaiseButton.addEventListener('click', () => handleHumanAction('BET_RAISE'));
        foldButton.addEventListener('click', () => handleHumanAction('FOLD'));
        pokerHandsInfoBtn.addEventListener('mouseover', () => { pokerHandsGuideDiv.style.display = 'block'; });
        pokerHandsInfoBtn.addEventListener('mouseout', () => { pokerHandsGuideDiv.style.display = 'none'; });
        document.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); if (key === KONAMI_CODE[konamiCodePosition].toLowerCase()) { konamiCodePosition++; if (konamiCodePosition === KONAMI_CODE.length) { isAdminMode = !isAdminMode; displayMessage(`사기꾼 기능 ${isAdminMode ? "활성화" : "비활성화"} 되었습니다!`, "admin-message"); konamiCodePosition = 0; if (gamePhase !== "" && gamePhase !== "SETUP") updateOverallUI(); } } else { konamiCodePosition = 0; } });

        displayMessage("참가 인원과 설정을 선택하고 '새 게임'을 누르세요.", "system-message");
        for(let i=0; i<=3; i++) { const slot = getPlayerSlotElement(i); if(slot) slot.style.display = "none"; }
        if (sbBbDisplayAreaEl) sbBbDisplayAreaEl.textContent = `SB: ${SMALL_BLIND_AMOUNT_CONFIG} / BB: ${BIG_BLIND_AMOUNT_CONFIG}`;
        if (potDisplayBottomRightEl) potDisplayBottomRightEl.textContent = `팟: 0원`;
    </script>
</body>
</html>
