<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>텍사스 홀덤 - v8.9 AI Logic Enhanced (No Tutorial)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            background-color: #2c3e50;
            margin: 0;
            padding: 10px;
            color: #ecf0f1;
            height: 100vh;
            box-sizing: border-box;
            position: relative;
            overflow-x: hidden;
        }

        .poker-hands-button {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background-color: #e67e22;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
        }

        .poker-hands-guide {
            display: none;
            position: fixed;
            top: 45px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 999;
            width: 450px;
            max-width: 90vw;
            font-size: 0.9em;
        }
        .poker-hands-guide h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        .poker-hands-guide ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .poker-hands-guide li {
            margin-bottom: 5px;
            padding: 8px;
            background-color: rgba(0,0,0,0.03);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100px;
        }

        .current-hand-display {
            font-size: 0.8em;
            color: #f1c40f;
            margin-top: 5px;
            font-weight: bold;
        }

        .game-container {
            display: flex;
            width: 100%;
            height: calc(100vh - 20px);
        }

        .main-game-area {
            flex-grow: 1;
            flex-basis: 68%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding-right: 5px;
            box-sizing: border-box;
        }

        .game-table {
            display: none; 
            background-color: #006400;
            border-radius: 150px;
            padding: 15px;
            border: 5px solid #8B4513;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: auto auto auto;
            align-items: center;
            justify-items: center;
            width: 95%;
            max-width: 900px;
            position: relative;
            gap: 5px;
        }

        .ai-action-effect {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 150px; box-shadow: 0 0 30px 10px gold;
            opacity: 0; transition: opacity 0.3s ease-out;
            pointer-events: none; z-index: 10;
        }
        .ai-action-effect.active { opacity: 0.8; }

        .player-slot {
            border: 1px solid #4a6278;
            border-radius: 10px;
            padding: 5px;
            background-color: rgba(0,0,0,0.2);
            min-width: 150px;
            min-height: 115px;
            text-align: center;
            position: relative;
        }
        .player-slot.acting { box-shadow: 0 0 15px 5px gold; }
        .player-slot.folded { opacity: 0.5; background-color: rgba(100,100,100,0.3); }

        .enhanced-feedback {
            position: absolute;
            top: 50%;
            left: calc(100% + 10px);
            transform: translateY(-50%) scale(0.8);
            font-size: 1.8em;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.7s ease-out, transform 0.7s ease-out, font-size 0.7s ease-out;
            z-index: 100;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: rgba(0,0,0,0.1);
        }
        .enhanced-feedback.show { opacity: 1; transform: translateY(-50%) scale(1.1); font-size: 2.2em; }
        .enhanced-feedback.fade-out { opacity: 0; transform: translateY(-50%) translateX(10px) scale(0.7); font-size: 1.5em; }
        .feedback-raise { color: #e74c3c; border: 2px solid #c0392b; }
        .feedback-call { color: #2ecc71; border: 2px solid #27ae60; }
        .feedback-bet { color: #f39c12; border: 2px solid #e67e22; }
        .feedback-check { color: #3498db; border: 2px solid #2980b9; }
        .feedback-fold { color: #95a5a6; border: 2px solid #7f8c8d; }
        .feedback-win { color: #f1c40f; border: 2px solid #f39c12; font-size: 2.5em !important; }
        .feedback-lose { color: #7f8c8d; border: 2px solid #34495e; font-style: italic; }

        #player-slot-0 { grid-column: 2 / 3; grid-row: 3 / 4; align-self: end; }
        #player-slot-1 { grid-column: 2 / 3; grid-row: 1 / 2; align-self: start; }
        #player-slot-2 { grid-column: 1 / 2; grid-row: 2 / 3; justify-self: start; }
        #player-slot-3 { grid-column: 3 / 4; grid-row: 2 / 3; justify-self: end; }

        .community-cards-area {
            grid-column: 2 / 3; grid-row: 2 / 3;
            text-align: center; width: 100%;
        }
        .community-cards-area h2 { margin-top:0; margin-bottom: 5px; font-size: 1.3em;}

        .cards-container { display: flex; justify-content: center; gap: 5px; margin-top: 5px; perspective: 1000px; }
        .card {
            width: 50px; height: 75px; border: 1px solid #000; border-radius: 4px;
            font-size: 14px; font-weight: bold; background-color: white;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3); position: relative;
            transform-style: preserve-3d; transition: transform 0.6s, opacity 0.3s;
            opacity: 0;
        }
        .card.hidden .card-front { transform: rotateY(180deg); }
        .card.hidden .card-back { transform: rotateY(0deg); }
        .card.is-dealt { opacity: 1; }
        .card.is-flipping .card-front { transform: rotateY(0deg); }
        .card.is-flipping .card-back { transform: rotateY(-180deg); }

        .card-face {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            display: flex; flex-direction: column; justify-content: space-around;
            align-items: center; border-radius: 4px;
        }
        .card-front { background-color: white; transform: rotateY(0deg); }
        .card-back {
            background-color: #6c757d;
            background-image: repeating-linear-gradient(45deg, #5a6268, #5a6268 6px, #6c757d 6px, #6c757d 12px);
            transform: rotateY(180deg);
        }
        .card .rank { font-size: 18px; } .card .suit { font-size: 16px; }
        .suit-♠, .suit-♣ { color: black; } .suit-♥, .suit-♦ { color: red; }

        .chips-display, .dealer-chip-ui, .blind-chip-ui {
            background-color: #f5f5dc; padding: 5px 10px; border-radius: 15px;
            font-size: 13px; border: 1px solid #d2b48c; margin-top: 3px;
            display: inline-block; color: #333;
        }
        .dealer-chip-ui { background-color: #FFD700; color: black; font-weight: bold; padding: 3px 6px; font-size: 9px; margin-left: 5px; }
        .blind-chip-ui { background-color: #7f8c8d; color: white; font-weight: bold; padding: 3px 6px; font-size: 9px; margin-left: 3px;}

        .player-name-display { font-weight: bold; color: white; margin-bottom: 3px; }

        .actions-area {
            display: none; 
            grid-column: 1 / 4; grid-row: 4 / 5; margin: 10px 0;
            gap: 8px; flex-wrap: wrap; justify-content: center;
        }
        .actions-area button, .game-controls button {
            padding: 8px 12px; font-size: 14px; cursor: pointer;
            background-color: #4CAF50; color: white; border: none;
            border-radius: 5px; transition: background-color 0.3s;
        }
        .actions-area button:hover, .game-controls button:hover { background-color: #45a049; }
        .actions-area button:disabled, .game-controls button:disabled { background-color: #7f8c8d; cursor: not-allowed; opacity: 0.7; }
        #raise-input { padding: 8px; font-size: 14px; width: 80px; border-radius: 5px; border: 1px solid #ccc; }

        .bet-amount-display {
            background-color: rgba(0,0,0,0.7); color: white; padding: 2px 6px;
            border-radius: 5px; font-size: 11px; margin-top: 3px; display: inline-block;
        }

        .right-panel {
            flex-basis: 32%;
            min-width: 280px;
            height: calc(100vh - 20px);
            margin-left: 5px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .chat-area {
            flex-grow: 1;
            background-color: #34495e; padding: 10px;
            border-radius: 8px; box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; box-sizing: border-box;
            min-height: 200px;
        }
        .chat-area h3 { margin-top: 0; color: #ecf0f1; text-align: center; border-bottom: 1px solid #7f8c8d; padding-bottom: 5px; }
        .message-log { flex-grow: 1; overflow-y: auto; font-size: 0.9em; line-height: 1.4; }
        .message-log p { margin: 5px 0; padding: 3px; border-bottom: 1px dashed #4a6278; }
        .message-log p:last-child { border-bottom: none; }
        .message-log .player-action { color: #2ecc71; } .message-log .ai-action { color: #e74c3c; }
        .message-log .game-event { color: #f1c40f; } .message-log .system-message { color: #bdc3c7; }
        .admin-message { color: #e67e22; font-weight: bold;}
        
        .game-info-bottom-right {
            padding: 10px;
            background-color: #1e2b37;
            border-radius: 8px;
            margin-top: 10px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            text-align: center;
        }
        .game-info-bottom-right div {
            font-size: 1.1em;
            font-weight: bold;
            color: #ecf0f1;
            padding: 6px 0;
            border-bottom: 1px solid #34495e;
        }
        .game-info-bottom-right div:last-child { border-bottom: none; }
        #pot-display-bottom-right { color: #f1c40f; }
        #sb-bb-display-area { color: #bdc3c7; }

        .game-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 10px; padding: 10px; }
        .player-setup, .game-settings-inputs { display: flex; gap: 10px; align-items: center; margin-bottom:10px; flex-wrap: wrap; justify-content: center;}
        .game-settings-inputs label { font-size: 0.9em; }
        .game-settings-inputs input[type="number"] {
            width: 70px; padding: 6px; border-radius: 4px; border: 1px solid #7f8c8d;
            background-color: #ecf0f1; color: #2c3e50;
        }
        #ai-delay-input { width: 50px; }

        .end-game-buttons { display: flex; gap: 10px; }
        .end-game-buttons button#continue-game-button { background-color: #3498db; }
        .end-game-buttons button#start-game-button-main { background-color: #27ae60; }

        .poker-hands-guide .hand-example-cards {
            display: flex; justify-content: center; gap: 2px;
            margin-top: 5px; padding: 3px;
            background-color: rgba(0, 80, 0, 0.1); border-radius: 3px;
        }
        .poker-hands-guide .card {
            width: 30px; height: 45px; font-size: 8px;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.2); border-radius: 3px;
            opacity: 1 !important; position: relative;
            transform-style: flat; background-color: white;
        }
        .poker-hands-guide .card .card-face { display: flex; flex-direction: column; justify-content: space-around; align-items: center; width: 100%; height: 100%; }
        .poker-hands-guide .card .card-front { transform: rotateY(0deg) !important; backface-visibility: hidden; }
        .poker-hands-guide .card .card-back { display: none !important; }
        .poker-hands-guide .card .rank { font-size: 12px; font-weight: bold; line-height: 1; }
        .poker-hands-guide .card .suit { font-size: 10px; line-height: 1; }

        /* --- 모바일 화면 최적화 --- */
        @media (max-width: 768px) {
            body { height: auto; padding: 5px; }
            .game-container { flex-direction: column; height: auto; }
            .main-game-area { flex-basis: auto; width: 100%; order: 1; padding-right: 0; }
            .right-panel { flex-basis: auto; width: 100%; margin-left: 0; margin-top: 15px; height: 250px; order: 2; }
            .game-table { border-radius: 50px; padding: 10px; gap: 3px; }
            .player-slot { min-width: 85px; min-height: 90px; padding: 3px 1px; }
            .player-slot .cards-container { gap: 2px; }
            .player-slot .card { width: 36px; height: 54px; font-size: 11px; }
            .player-slot .card .rank { font-size: 12px; }
            .player-slot .card .suit { font-size: 10px; }

            .actions-area { margin: 5px 0; gap: 5px; }
            .actions-area button { padding: 8px 6px; font-size: 12px; }
            #raise-input { padding: 8px; width: 50px; font-size: 12px; }
            .poker-hands-button { font-size: 0.8em; padding: 6px 8px; }
            
            .poker-hands-guide {
                width: 90vw; left: 5vw; top: 50px; font-size: 0.85em;
                max-height: 80vh; overflow-y: auto; padding: 10px;
            }
            .poker-hands-guide ul { grid-template-columns: 1fr; gap: 8px; }
            .poker-hands-guide li { padding: 6px; min-height: auto; }
            .poker-hands-guide li b { font-size: 0.95em; }
            .poker-hands-guide .hand-example-cards { margin-top: 4px; gap: 1px; }
            .poker-hands-guide .card { width: 24px; height: 36px; }
            .poker-hands-guide .card .rank { font-size: 10px; }
            .poker-hands-guide .card .suit { font-size: 8px; }
            
            .enhanced-feedback {
                max-width: 90px; 
                word-break: keep-all; 
                white-space: normal; 
                text-align: center; 
                padding: 3px 6px; 
                font-size: 1.3em !important; 
                left: calc(100% + 5px);
            }
            #player-slot-3 .enhanced-feedback { 
                left: auto; 
                right: calc(100% + 5px); 
                transform: translateY(-50%) scale(0.8) translateX(-100%); 
            }
            .enhanced-feedback.show { font-size: 1.6em !important; }
            #player-slot-3 .enhanced-feedback.show { transform: translateY(-50%) scale(1.1) translateX(-100%); }
            .enhanced-feedback.fade-out { font-size: 1.1em !important; transform: translateY(-50%) translateX(10px) scale(0.7); }
            #player-slot-3 .enhanced-feedback.fade-out { transform: translateY(-50%) translateX(calc(-100% - 10px)) scale(0.7); }
            .feedback-win { font-size: 2em !important; }
        }
        @media (max-width: 480px) {
            .player-slot { min-width: 70px; min-height: 75px; }
            .player-slot .cards-container { gap: 1px; }
            .player-slot .card { width: 30px; height: 45px; font-size: 9px;}
            .player-slot .card .rank { font-size: 10px; }
            .player-slot .card .suit { font-size: 8px; }

            .chips-display { font-size: 11px; padding: 3px 6px;}
            .dealer-chip-ui, .blind-chip-ui { font-size: 8px; padding: 2px 4px;}
            .current-hand-display { font-size: 0.7em; }
            .community-cards-area h2 { font-size: 1.2em; }
            
            .poker-hands-guide { font-size: 0.8em; }
            .poker-hands-guide li b { font-size: 0.9em; }
            .poker-hands-guide .card { width: 20px; height: 30px; }
            .poker-hands-guide .card .rank { font-size: 8px; }
            .poker-hands-guide .card .suit { font-size: 7px; }

            .enhanced-feedback { max-width: 70px; padding: 2px 4px; }
            #player-slot-3 .enhanced-feedback {
                right: calc(100% + 2px); 
                font-size: 1.0em !important;
            }
            #player-slot-3 .enhanced-feedback.show { font-size: 1.2em !important; }
            #player-slot-3 .enhanced-feedback.fade-out { font-size: 0.8em !important; }
        }
    </style>
</head>
<body>
    <button class="poker-hands-button" id="poker-hands-info-btn">포커 족보</button>
    
    <div class="poker-hands-guide" id="poker-hands-guide-div">
        <h4>포커 족보 (높은 순)</h4>
        <ul>
            <li><b>로열 플러쉬</b> (Royal Flush): 같은 무늬 A-K-Q-J-10 <div class="hand-example-cards" data-hand-name="royal-flush"></div></li>
            <li><b>스트레이트 플러쉬</b> (Straight Flush): 같은 무늬 연속 숫자 <div class="hand-example-cards" data-hand-name="straight-flush"></div></li>
            <li><b>포카드</b> (Four of a Kind): 같은 숫자 4장 <div class="hand-example-cards" data-hand-name="four-of-a-kind"></div></li>
            <li><b>풀하우스</b> (Full House): 트리플 + 원 페어 <div class="hand-example-cards" data-hand-name="full-house"></div></li>
            <li><b>플러쉬</b> (Flush): 같은 무늬 5장 <div class="hand-example-cards" data-hand-name="flush"></div></li>
            <li><b>스트레이트</b> (Straight): 연속된 숫자 5장 <div class="hand-example-cards" data-hand-name="straight"></div></li>
            <li><b>트리플</b> (Three of a Kind): 같은 숫자 3장 <div class="hand-example-cards" data-hand-name="three-of-a-kind"></div></li>
            <li><b>투 페어</b> (Two Pair): 페어 2쌍 <div class="hand-example-cards" data-hand-name="two-pair"></div></li>
            <li><b>원 페어</b> (One Pair): 페어 1쌍 <div class="hand-example-cards" data-hand-name="one-pair"></div></li>
            <li><b>하이 카드</b> (High Card): 위 족보에 해당 없을 시 가장 높은 카드 <div class="hand-example-cards" data-hand-name="high-card"></div></li>
        </ul>
    </div>

    <div class="game-container">
        <div class="main-game-area">
            <div class="game-table" id="game-table-main">
                <div id="ai-action-effect-indicator" class="ai-action-effect"></div>
                <div id="player-slot-1" class="player-slot" style="display:none;"></div>
                <div id="player-slot-2" class="player-slot" style="display:none;"></div>
                <div id="player-slot-3" class="player-slot" style="display:none;"></div>
                <div class="community-cards-area">
                    <h2>커뮤니티 카드</h2>
                    <div id="community-cards" class="cards-container"></div>
                </div>
                <div id="player-slot-0" class="player-slot"></div>
                <div class="actions-area" id="actions-area-main">
                    <button id="check-call-button">체크</button>
                    <button id="bet-raise-button">벳</button>
                    <input type="number" id="raise-input" value="0" min="0">
                    <button id="fold-button">폴드</button>
                </div>
            </div>
            <div class="game-controls">
                <div class="player-setup">
                    <label for="num-players-select">참가 인원 (AI 포함):</label>
                    <select id="num-players-select">
                        <option value="2" selected>2명</option>
                        <option value="3">3명</option>
                        <option value="4">4명</option>
                    </select>
                </div>
                <div class="game-settings-inputs">
                    <label for="starting-chips-input">시작 칩:</label>
                    <input type="number" id="starting-chips-input" placeholder="1000" min="100">
                    <label for="big-blind-input">BB 금액:</label>
                    <input type="number" id="big-blind-input" placeholder="20" min="2">
                    <label for="ai-delay-input">AI 딜레이(초):</label>
                    <input type="number" id="ai-delay-input" placeholder="0" min="0" value="0">
                </div>
                <div id="control-buttons-area" class="end-game-buttons">
                    <button id="start-game-button-main">새 게임</button>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="chat-area">
                <h3>게임 로그</h3>
                <div id="message-log" class="message-log">
                    <p class="system-message">텍사스 홀덤 게임에 오신 것을 환영합니다!</p>
                    <p class="system-message">참가 인원, 시작 칩, BB 금액, AI 딜레이를 설정하고 '새 게임'을 누르세요.</p>
                </div>
            </div>
            <div class="game-info-bottom-right">
                <div id="pot-display-bottom-right">팟: 0원</div>
                <div id="sb-bb-display-area">SB: 10 / BB: 20</div>
            </div>
        </div>
    </div>

    <script>
        const SUITS = ["♠", "♥", "♦", "♣"];
        const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
        const RANK_VALUES = { "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, "J": 11, "Q": 12, "K": 13, "A": 14, "A_LOW": 1 };
        const HAND_STRENGTH = { HIGH_CARD: 0, ONE_PAIR: 1, TWO_PAIR: 2, THREE_OF_A_KIND: 3, STRAIGHT: 4, FLUSH: 5, FULL_HOUSE: 6, FOUR_OF_A_KIND: 7, STRAIGHT_FLUSH: 8, ROYAL_FLUSH: 9 };

        let STARTING_CHIPS_CONFIG = 1000;
        let BIG_BLIND_AMOUNT_CONFIG = 20;
        let SMALL_BLIND_AMOUNT_CONFIG = 10;
        let AI_ACTION_BASE_DELAY_MS = 0;

        const BLUFF_PROBABILITY_BASE = 0.07; 
        const KONAMI_CODE = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
        const VISUAL_ORDER_RULES = { 4: [1, 2, 0, 3], 3: [1, 2, 0], 2: [] };

        let deck = [], communityCards = [], players = [];
        let pot = 0, currentBet = 0, minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG;
        let gamePhase = "", currentPlayerIndex = -1, dealerIndex = -1;
        let currentHandActivePlayerIdsOrder = [], currentTurnInOrderIndex = -1;
        let lastRaiserId = -1, actualNumPlayersInCurrentGame = 0;
        let initialPlayerChipsBeforeHand = {};
        let initialNumPlayersForNextHandLogic = 0;

        let isAdminMode = false, konamiCodePosition = 0;
        
        const gameTableMainEl = document.getElementById('game-table-main');
        const actionsAreaMainEl = document.getElementById('actions-area-main');
        const communityCardsDiv = document.getElementById('community-cards');
        const potDisplayBottomRightEl = document.getElementById('pot-display-bottom-right');
        const sbBbDisplayAreaEl = document.getElementById('sb-bb-display-area');
        const messageLogDiv = document.getElementById('message-log');
        const checkCallButton = document.getElementById('check-call-button');
        const betRaiseButton = document.getElementById('bet-raise-button');
        const raiseInput = document.getElementById('raise-input');
        const foldButton = document.getElementById('fold-button');
        const mainStartGameButton = document.getElementById('start-game-button-main');
        const controlButtonsArea = document.getElementById('control-buttons-area');
        const numPlayersSelect = document.getElementById('num-players-select');
        const aiActionEffectIndicator = document.getElementById('ai-action-effect-indicator');
        const pokerHandsInfoBtn = document.getElementById('poker-hands-info-btn');
        const pokerHandsGuideDiv = document.getElementById('poker-hands-guide-div');
        const startingChipsInputEl = document.getElementById('starting-chips-input');
        const bigBlindInputEl = document.getElementById('big-blind-input');
        const aiDelayInputEl = document.getElementById('ai-delay-input');

        const pokerHandExamples = { "royal-flush": [ { rank: "A", suit: "♠" }, { rank: "K", suit: "♠" }, { rank: "Q", suit: "♠" }, { rank: "J", suit: "♠" }, { rank: "10", suit: "♠" } ], "straight-flush": [ { rank: "9", suit: "♥" }, { rank: "8", suit: "♥" }, { rank: "7", suit: "♥" }, { rank: "6", suit: "♥" }, { rank: "5", suit: "♥" } ], "four-of-a-kind": [ { rank: "A", suit: "♦" }, { rank: "A", suit: "♣" }, { rank: "A", suit: "♥" }, { rank: "A", suit: "♠" }, { rank: "K", suit: "♠" } ], "full-house": [ { rank: "K", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "K", suit: "♥" }, { rank: "7", suit: "♣" }, { rank: "7", suit: "♦" } ], "flush": [ { rank: "A", suit: "♣" }, { rank: "J", suit: "♣" }, { rank: "9", suit: "♣" }, { rank: "5", suit: "♣" }, { rank: "3", suit: "♣" } ], "straight": [ { rank: "A", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "Q", suit: "♥" }, { rank: "J", suit: "♣" }, { rank: "10", suit: "♠" } ], "three-of-a-kind": [ { rank: "Q", suit: "♠" }, { rank: "Q", suit: "♦" }, { rank: "Q", suit: "♥" }, { rank: "A", suit: "♣" }, { rank: "K", suit: "♦" } ], "two-pair": [ { rank: "J", suit: "♠" }, { rank: "J", suit: "♦" }, { rank: "8", suit: "♥" }, { rank: "8", suit: "♣" }, { rank: "A", suit: "♦" } ], "one-pair": [ { rank: "10", suit: "♠" }, { rank: "10", suit: "♦" }, { rank: "A", suit: "♥" }, { rank: "K", suit: "♣" }, { rank: "Q", suit: "♦" } ], "high-card": [ { rank: "A", suit: "♠" }, { rank: "K", suit: "♦" }, { rank: "J", suit: "♥" }, { rank: "9", suit: "♣" }, { rank: "7", suit: "♠" } ] };
        function renderSingleExampleCard(cardData) { const cardDiv = document.createElement('div'); cardDiv.classList.add('card'); const cardFaceFront = document.createElement('div'); cardFaceFront.classList.add('card-face', 'card-front'); const rankDiv = document.createElement('span'); rankDiv.classList.add('rank'); rankDiv.textContent = cardData.rank; const suitDiv = document.createElement('span'); suitDiv.classList.add('suit', `suit-${cardData.suit}`); suitDiv.innerHTML = cardData.suit; cardFaceFront.appendChild(rankDiv); cardFaceFront.appendChild(suitDiv); cardFaceFront.style.color = (cardData.suit === "♥" || cardData.suit === "♦") ? "red" : "black"; cardDiv.appendChild(cardFaceFront); return cardDiv; }
        function populatePokerHandExamples() { const exampleContainers = document.querySelectorAll('.poker-hands-guide .hand-example-cards'); exampleContainers.forEach(container => { container.innerHTML = ''; const handName = container.dataset.handName; const cardsData = pokerHandExamples[handName]; if (cardsData) { cardsData.forEach(cardInfo => { container.appendChild(renderSingleExampleCard(cardInfo)); }); } }); }
        function formatNumberWithCommas(number) { if (number === null || number === undefined) return '0'; return Math.floor(Number(number)).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        function showAIActionEffect() { aiActionEffectIndicator.classList.add('active'); setTimeout(() => aiActionEffectIndicator.classList.remove('active'), 700); }
        function getPlayerSlotElement(playerIndex) { return document.getElementById(`player-slot-${playerIndex}`); }
        function showEnhancedFeedback(playerId, text, typeClass) { const playerSlot = getPlayerSlotElement(playerId); if (!playerSlot) return; const existingFeedback = playerSlot.querySelector('.enhanced-feedback'); if (existingFeedback) { existingFeedback.remove(); } const feedbackDiv = document.createElement('div'); feedbackDiv.classList.add('enhanced-feedback', typeClass); feedbackDiv.textContent = text; playerSlot.appendChild(feedbackDiv); requestAnimationFrame(() => { setTimeout(() => { feedbackDiv.classList.add('show'); }, 20); }); setTimeout(() => { feedbackDiv.classList.add('fade-out'); setTimeout(() => { if (feedbackDiv.parentNode) { feedbackDiv.remove(); } }, 700); }, 1500); }
        function getPlayerPositionCategory(player, dealerPlayerId, numActivePlayersInHandForPos, currentHandOrder) { if (numActivePlayersInHandForPos <= 1) return "OnlyPlayer"; const playerActualOrder = currentHandOrder; const playerIndexInOrder = playerActualOrder.indexOf(player.id); if (playerIndexInOrder === -1) return "PositionError_NotFoundInOrder"; if (numActivePlayersInHandForPos === 2) { return player.isSB ? "SB_Dealer" : "BB_Opponent"; } if (playerIndexInOrder === 0) return "SB"; if (playerIndexInOrder === 1) return "BB"; const bbPlayer = players.find(p => p.isBB && playerActualOrder.includes(p.id)); let bbIndexInOrder = bbPlayer ? playerActualOrder.indexOf(bbPlayer.id) : 1; if (bbIndexInOrder === -1) bbIndexInOrder = 1; if (playerIndexInOrder === (bbIndexInOrder + 1) % numActivePlayersInHandForPos) return "UTG"; if (player.id === dealerPlayerId) return "Dealer"; const dealerIndexInActualOrder = playerActualOrder.indexOf(dealerPlayerId); if (dealerIndexInActualOrder !== -1) { if (playerIndexInOrder === (dealerIndexInActualOrder - 1 + numActivePlayersInHandForPos) % numActivePlayersInHandForPos) return "CutOff"; } if (numActivePlayersInHandForPos <= 6) { if (playerIndexInOrder < Math.floor(numActivePlayersInHandForPos / 2) && playerIndexInOrder > 1) return "Early"; else if (playerIndexInOrder >= Math.floor(numActivePlayersInHandForPos / 2) && player.id !== dealerPlayerId && playerActualOrder.indexOf(dealerPlayerId) !== playerIndexInOrder -1 ) return "Late"; } else { if (playerIndexInOrder < numActivePlayersInHandForPos / 3 && playerIndexInOrder > 1) return "Early"; if (playerIndexInOrder < (numActivePlayersInHandForPos * 2) / 3  && playerIndexInOrder > 1) return "Middle"; if (player.id !== dealerPlayerId && playerActualOrder.indexOf(dealerPlayerId) !== playerIndexInOrder -1 ) return "Late"; } return "Middle"; }
        function calculatePotOdds(amountToCall, currentPotTotal) { if (amountToCall <= 0) return 1; return amountToCall / (currentPotTotal + amountToCall); }
        function analyzeBoardTexture(communityCards) { if (!communityCards || communityCards.length < 3) return { type: "preflop", isWet: false, isPaired: false, flushDraws: 0, straightDraws: 0, highCardValue:0 }; let texture = { type: "unknown", isWet: false, isPaired: false, flushDraws: 0, straightDraws: 0, highCardValue:0 }; const ranks = communityCards.map(c => c.value).sort((a,b)=>b-a); const suits = communityCards.map(c => c.suit); texture.highCardValue = ranks[0] || 0; const rankCounts = {}; ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1); if (Object.values(rankCounts).some(count => count >= 2)) texture.isPaired = true; if (Object.values(rankCounts).some(count => count >= 3)) { texture.isPaired = true; texture.isWet = true; } const suitCounts = {}; suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1); Object.values(suitCounts).forEach(count => { if (count === 2 && communityCards.length === 3) texture.flushDraws = 1; if (count >= 3) {texture.flushDraws = Math.max(texture.flushDraws, count); texture.isWet = true;} }); const uniqueSortedRanks = [...new Set(ranks)].sort((a,b)=>a-b); if (uniqueSortedRanks.length >= 3) { for (let i = 0; i <= uniqueSortedRanks.length - 3; i++) { if (uniqueSortedRanks[i+2] - uniqueSortedRanks[i] <= 4) { texture.straightDraws++; texture.isWet = true; } } if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(2) && uniqueSortedRanks.includes(3)) texture.straightDraws++; if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(2) && uniqueSortedRanks.includes(4) && !uniqueSortedRanks.includes(3)) texture.straightDraws++; if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(3) && uniqueSortedRanks.includes(4) && !uniqueSortedRanks.includes(2)) texture.straightDraws++; } if (texture.straightDraws > 1 || (texture.straightDraws > 0 && texture.flushDraws >=3 )) texture.isWet = true; if (!texture.isWet && !texture.isPaired && texture.highCardValue < RANK_VALUES.J && ranks.length >=3 && (ranks[0] - ranks[ranks.length-1] > 5)) { texture.type = "dry_uncoordinated"; } else if (texture.isWet) { texture.type = "wet_drawy"; } else if (texture.isPaired) { texture.type = "paired"; } else { texture.type = "semi_coordinated"; } return texture; }
        function createDeck() { deck = []; for (let suit of SUITS) for (let rank of RANKS) deck.push({ suit, rank, value: RANK_VALUES[rank], id: rank+suit+Date.now()+Math.random() }); }
        function shuffleDeck() { for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } }
        function dealCardFromDeck(hiddenInitially = false) { if (deck.length > 0) { const card = deck.pop(); card.hidden = hiddenInitially; card.revealed = !hiddenInitially; return card; } return null; }
        function burnCard() { if (deck.length > 0) deck.pop(); }
        function createPlayerSlotUI(player) { const slotDiv = getPlayerSlotElement(player.id); if (!slotDiv) { console.error(`Slot DIV for player ${player.id} not found`); return; } slotDiv.innerHTML = `<div class="player-name-display">${player.name} <span id="dealer-chip-${player.id}" class="dealer-chip-ui" style="display:none;">D</span><span id="sb-chip-${player.id}" class="blind-chip-ui" style="display:none;">SB</span><span id="bb-chip-${player.id}" class="blind-chip-ui" style="display:none;">BB</span></div><div id="cards-player-${player.id}" class="cards-container"></div><div id="chips-player-${player.id}" class="chips-display">칩: ${formatNumberWithCommas(player.chips)}원</div><div id="bet-player-${player.id}" class="bet-amount-display" style="display:none;"></div><div id="current-hand-player-${player.id}" class="current-hand-display"></div>`; slotDiv.style.display = "block"; }
        function renderPlayerCard(player, cardData, hiddenInitially = false) { const cardsContainer = document.getElementById(`cards-player-${player.id}`); if (!cardsContainer) return; let cardIsActuallyHiddenForRender = hiddenInitially; if (isAdminMode && player.type === 'ai') { cardIsActuallyHiddenForRender = false; } const cardElement = renderSingleCard(cardData, false, cardIsActuallyHiddenForRender); cardsContainer.appendChild(cardElement); return cardElement; }
        function renderSingleCard(card, isCommunity = false, hiddenInitially = false) { const cardDiv = document.createElement('div'); cardDiv.classList.add('card'); cardDiv.dataset.cardId = card.id; const cardFaceFront = document.createElement('div'); cardFaceFront.classList.add('card-face', 'card-front'); const rankDiv = document.createElement('span'); rankDiv.classList.add('rank'); rankDiv.textContent = card.rank; const suitDiv = document.createElement('span'); suitDiv.classList.add('suit', `suit-${card.suit}`); suitDiv.innerHTML = card.suit; cardFaceFront.appendChild(rankDiv); cardFaceFront.appendChild(suitDiv); cardFaceFront.style.color = (card.suit === "♥" || card.suit === "♦") ? "red" : "black"; const cardFaceBack = document.createElement('div'); cardFaceBack.classList.add('card-face', 'card-back'); cardDiv.appendChild(cardFaceFront); cardDiv.appendChild(cardFaceBack); if (hiddenInitially) { cardDiv.classList.add('hidden');} let delay = 0; if (isCommunity) delay = communityCardsDiv.children.length * 150; setTimeout(() => { cardDiv.classList.add('is-dealt'); if (!hiddenInitially) { setTimeout(() => { if (!cardDiv.classList.contains('hidden')) { cardDiv.classList.add('is-flipping'); } }, 50 + delay + (isCommunity ? 100 : 0) ); } }, 50 + delay); return cardDiv; }
        async function dealAnimatedCommunityCard(cardData) { communityCards.push(cardData); const cardElement = renderSingleCard(cardData, true, false); communityCardsDiv.appendChild(cardElement); await sleep(200); }
        function revealHiddenCard(player, cardObj) { const cardElement = document.querySelector(`#cards-player-${player.id} .card[data-card-id="${cardObj.id}"]`); if (cardElement && cardElement.classList.contains('hidden')) { cardElement.classList.remove('hidden'); cardElement.classList.add('is-flipping'); } if(player.type === 'ai') { const gameCard = player.cards.find(c => c.id === cardObj.id); if(gameCard) { gameCard.hidden = false; gameCard.revealed = true;} } }

        function updateOverallUI() { players.forEach(p => { const slotDiv = getPlayerSlotElement(p.id); if (!slotDiv) return; document.getElementById(`chips-player-${p.id}`).textContent = `칩: ${formatNumberWithCommas(p.chips)}원`; const betDiv = document.getElementById(`bet-player-${p.id}`); if (p.betInRound > 0) { betDiv.textContent = `벳: ${formatNumberWithCommas(p.betInRound)}원`; betDiv.style.display = 'inline-block'; } else { betDiv.style.display = 'none'; } document.getElementById(`dealer-chip-${p.id}`).style.display = p.isDealer ? 'inline-block' : 'none'; document.getElementById(`sb-chip-${p.id}`).style.display = p.isSB ? 'inline-block' : 'none'; document.getElementById(`bb-chip-${p.id}`).style.display = p.isBB ? 'inline-block' : 'none'; const currentHandDiv = document.getElementById(`current-hand-player-${p.id}`); if (currentHandDiv && p.type === "human" && p.cards.length >= 2 && !p.isFolded) { if (communityCards.length >= 3) { const handDetails = getHandDetails([...p.cards, ...communityCards]); currentHandDiv.textContent = `현재 최고패: ${handDetails.handName}`; } else if (p.cards.length === 2) { let preflopHandName = ""; const card1 = p.cards[0]; const card2 = p.cards[1]; if (card1.value === card2.value) { preflopHandName = `${card1.rank} 페어`; } else { const highRankValue = Math.max(card1.value, card2.value); const lowRankValue = Math.min(card1.value, card2.value); const highRankName = Object.keys(RANK_VALUES).find(key => RANK_VALUES[key] === highRankValue && key !== "A_LOW"); const lowRankName = Object.keys(RANK_VALUES).find(key => RANK_VALUES[key] === lowRankValue && key !== "A_LOW"); preflopHandName = `${highRankName || card1.rank}${lowRankName || card2.rank}`; if (card1.suit === card2.suit) { preflopHandName += "s"; } else { preflopHandName += "o"; } preflopHandName += ` (하이: ${highRankName || card1.rank})`; } currentHandDiv.textContent = `손패: ${preflopHandName}`; } } else if (currentHandDiv) { currentHandDiv.textContent = ""; } slotDiv.classList.remove('acting', 'folded'); const currentPlayerObject = players[currentPlayerIndex]; if (currentPlayerObject && p.id === currentPlayerObject.id && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND" && !p.isFolded && !p.isAllIn) { slotDiv.classList.add('acting'); } if (p.isFolded) slotDiv.classList.add('folded'); if (isAdminMode && p.type === 'ai' && !p.isFolded) { p.cards.forEach(cardData => { const cardElement = document.querySelector(`#cards-player-${p.id} .card[data-card-id="${cardData.id}"]`); if (cardElement && cardElement.classList.contains('hidden')) { cardElement.classList.remove('hidden'); if (!cardElement.classList.contains('is-flipping') && !cardElement.classList.contains('is-dealt')) { setTimeout(() => cardElement.classList.add('is-dealt'), 50); setTimeout(() => cardElement.classList.add('is-flipping'), 150); } else if (!cardElement.classList.contains('is-flipping')) { cardElement.classList.add('is-flipping'); } } cardData.hidden = false; cardData.revealed = true; }); } }); if (potDisplayBottomRightEl) potDisplayBottomRightEl.textContent = `팟: ${formatNumberWithCommas(pot)}원`; updateActionButtonsForHuman(); }
        function updateActionButtonsForHuman() { const humanPlayer = players.find(p => p.type === "human"); if (!humanPlayer) { checkCallButton.disabled = true; betRaiseButton.disabled = true; raiseInput.disabled = true; foldButton.disabled = true; return; } const currentPlayerObject = players[currentPlayerIndex]; const isHumanTurn = currentPlayerObject && humanPlayer.id === currentPlayerObject.id && !humanPlayer.isFolded && !humanPlayer.isAllIn && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND"; checkCallButton.disabled = !isHumanTurn; betRaiseButton.disabled = !isHumanTurn; raiseInput.disabled = !isHumanTurn; foldButton.disabled = !isHumanTurn; if (isHumanTurn) { const amountToCall = currentBet - humanPlayer.betInRound; if (amountToCall > 0) { checkCallButton.textContent = `콜 (${formatNumberWithCommas(Math.min(amountToCall, humanPlayer.chips))}원)`; betRaiseButton.textContent = "레이즈"; } else { checkCallButton.textContent = "체크"; betRaiseButton.textContent = "벳"; } let minNewTotalBet = currentBet + minRaiseAmount; if (currentBet === 0) minNewTotalBet = minRaiseAmount; minNewTotalBet = Math.max(minNewTotalBet, humanPlayer.betInRound + (currentBet > 0 ? minRaiseAmount : SMALL_BLIND_AMOUNT_CONFIG)); raiseInput.min = Math.floor(Math.min(humanPlayer.chips + humanPlayer.betInRound, minNewTotalBet)); raiseInput.value = Math.floor(Math.min(humanPlayer.chips + humanPlayer.betInRound, minNewTotalBet)); raiseInput.max = Math.floor(humanPlayer.chips + humanPlayer.betInRound); } else { checkCallButton.textContent = "체크"; betRaiseButton.textContent = "벳"; } }
        function displayMessage(msg, type = "system-message") { const p = document.createElement('p'); p.classList.add(type); p.textContent = msg; messageLogDiv.appendChild(p); messageLogDiv.scrollTop = messageLogDiv.scrollHeight; }
        
        async function initializeNewGame() {
            gameTableMainEl.style.display = 'grid'; actionsAreaMainEl.style.display = 'flex';
            let newStartingChips = parseInt(startingChipsInputEl.value); let newBigBlind = parseInt(bigBlindInputEl.value); let newAiDelay = parseInt(aiDelayInputEl.value);
            STARTING_CHIPS_CONFIG = (!isNaN(newStartingChips) && newStartingChips >= 100) ? newStartingChips : 1000;
            BIG_BLIND_AMOUNT_CONFIG = (!isNaN(newBigBlind) && newBigBlind >= 2) ? newBigBlind : 20;
            AI_ACTION_BASE_DELAY_MS = (!isNaN(newAiDelay) && newAiDelay >= 0) ? newAiDelay * 1000 : 0;
            actualNumPlayersInCurrentGame = parseInt(numPlayersSelect.value);
            SMALL_BLIND_AMOUNT_CONFIG = Math.floor(BIG_BLIND_AMOUNT_CONFIG / 2); minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG;
            if (sbBbDisplayAreaEl) sbBbDisplayAreaEl.textContent = `SB: ${formatNumberWithCommas(SMALL_BLIND_AMOUNT_CONFIG)} / BB: ${formatNumberWithCommas(BIG_BLIND_AMOUNT_CONFIG)}`;
            initialNumPlayersForNextHandLogic = actualNumPlayersInCurrentGame;
            players = [];
            for (let i = 0; i < actualNumPlayersInCurrentGame; i++) { players.push({ id: i, name: i === 0 ? "플레이어" : `AI ${i}`, type: i === 0 ? "human" : "ai", chips: STARTING_CHIPS_CONFIG, cards: [], betInRound: 0, isFolded: false, isAllIn: false, isDealer: false, isSB: false, isBB: false, handDetails: null, hasActedThisBettingRound: false, positionCategory: "Unknown", previousAction: null, raisesThisRoundCount: 0, aggressionFactor: Math.random() * 0.4 + 0.7, tightnessFactor: Math.random() * 0.4 + 0.7 }); createPlayerSlotUI(players[i]); }
            for (let i = actualNumPlayersInCurrentGame; i <= 3; i++) { const slot = getPlayerSlotElement(i); if(slot) slot.style.display = "none"; }
            dealerIndex = -1;
            const oldMainStartButton = document.getElementById('start-game-button-main');
            if(oldMainStartButton) oldMainStartButton.style.display = 'none';
            controlButtonsArea.innerHTML = '';
            numPlayersSelect.disabled = true; startingChipsInputEl.disabled = true; bigBlindInputEl.disabled = true; aiDelayInputEl.disabled = true;
            await startNewHand();
        }

        async function startNewHand() {
            gameTableMainEl.style.display = 'grid'; actionsAreaMainEl.style.display = 'flex';
            controlButtonsArea.innerHTML = '';
            const oldMainStartButton = document.getElementById('start-game-button-main'); if(oldMainStartButton) oldMainStartButton.style.display = 'none';
            numPlayersSelect.disabled = true; startingChipsInputEl.disabled = true; bigBlindInputEl.disabled = true; aiDelayInputEl.disabled = true;
            
            if (players.length === 0) { console.error("플레이어 정보 없이 핸드 시작 시도."); gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none'; controlButtonsArea.innerHTML = `<button id="start-game-button-main">새 게임</button>`; document.getElementById('start-game-button-main').addEventListener('click', initializeNewGame); numPlayersSelect.disabled = false; startingChipsInputEl.disabled = false; bigBlindInputEl.disabled = false; aiDelayInputEl.disabled = false; return; }
            const activePlayersWithChips = players.filter(p => p.chips > 0);
            if (activePlayersWithChips.length <= 1 && players.length > 0) { await endCurrentHand(false); return; }
            gamePhase = "SETUP"; createDeck(); shuffleDeck(); communityCards = []; communityCardsDiv.innerHTML = ''; pot = 0; currentBet = 0; minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG; lastRaiserId = -1; currentHandActivePlayerIdsOrder = []; currentTurnInOrderIndex = -1;
            players.forEach(p => { p.cards = []; p.betInRound = 0; if (p.chips <= 0) p.isFolded = true; else p.isFolded = false; p.isAllIn = (p.chips === 0 && !p.isFolded); p.isDealer = false; p.isSB = false; p.isBB = false; p.handDetails = null; p.hasActedThisBettingRound = false; p.previousAction = null; p.raisesThisRoundCount = 0; const cardsDiv = document.getElementById(`cards-player-${p.id}`); if (cardsDiv) cardsDiv.innerHTML = ''; const currentHandDiv = document.getElementById(`current-hand-player-${p.id}`); if(currentHandDiv) currentHandDiv.textContent = ""; });
            let prevDealerOriginalIndex = dealerIndex;
            if (dealerIndex === -1 || !players[dealerIndex] || players[dealerIndex].chips <= 0 || players[dealerIndex].isFolded) { dealerIndex = Math.floor(Math.random() * actualNumPlayersInCurrentGame); let initialPick = dealerIndex; while(!players[dealerIndex] || players[dealerIndex].chips <= 0 || players[dealerIndex].isFolded) { dealerIndex = (dealerIndex + 1) % actualNumPlayersInCurrentGame; if(dealerIndex === initialPick) { console.error("Cannot find a dealer."); await endCurrentHand(false); return; } } }
            else { const activeForDealerMove = players.filter(p=>p.chips>0 && !p.isFolded); if (activeForDealerMove.length === 2) { const prevDealerPlayer = players[prevDealerOriginalIndex]; const nextDealerCand = activeForDealerMove.find(p => p.id !== prevDealerPlayer.id); dealerIndex = players.findIndex(p => p.id === (nextDealerCand ? nextDealerCand.id : activeForDealerMove[0].id)); } else if (activeForDealerMove.length > 2) { const baseOrderForDealer = VISUAL_ORDER_RULES[actualNumPlayersInCurrentGame] || VISUAL_ORDER_RULES[4].filter(id => activeForDealerMove.some(p => p.id === id)); let currentDealerVisualPos = baseOrderForDealer.indexOf(players[prevDealerOriginalIndex].id); if(currentDealerVisualPos === -1) currentDealerVisualPos = 0; let nextDealerId; for (let i = 1; i <= baseOrderForDealer.length; i++) { nextDealerId = baseOrderForDealer[(currentDealerVisualPos + i) % baseOrderForDealer.length]; const pCand = activeForDealerMove.find(p => p.id === nextDealerId); if (pCand) { dealerIndex = players.findIndex(p => p.id === nextDealerId); break; } } } else { console.error("Not enough active players for dealer."); await endCurrentHand(false); return; } }
            if(dealerIndex === -1 || !players[dealerIndex]) { dealerIndex = players.findIndex(p => p.chips > 0 && !p.isFolded); if(dealerIndex === -1) { console.error("Critical: No valid dealer found."); await endCurrentHand(false); return;} }
            players[dealerIndex].isDealer = true; const currentDealerPlayerId = players[dealerIndex].id; displayMessage(`${players[dealerIndex].name}가 딜러입니다.`, "game-event");
            const activePlayersInHandList = players.filter(p => !p.isFolded && (p.chips > 0 || p.isAllIn) );
            const numActiveInHand = activePlayersInHandList.length; let sbPlayer = null, bbPlayer = null;
            if (numActiveInHand === 2) { sbPlayer = players[dealerIndex]; sbPlayer.isSB = true; bbPlayer = activePlayersInHandList.find(p => p.id !== sbPlayer.id); if (bbPlayer) bbPlayer.isBB = true; else { console.error("HU: BB not found"); await endCurrentHand(false); return;} currentHandActivePlayerIdsOrder = [sbPlayer.id, bbPlayer.id]; }
            else if (numActiveInHand > 2) { const baseVisualOrder = VISUAL_ORDER_RULES[actualNumPlayersInCurrentGame] ? [...VISUAL_ORDER_RULES[actualNumPlayersInCurrentGame]] : [...VISUAL_ORDER_RULES[4]].filter(id => activePlayersInHandList.some(p => p.id === id)); let dealerPosInVisual = baseVisualOrder.indexOf(currentDealerPlayerId); currentHandActivePlayerIdsOrder = []; if(dealerPosInVisual === -1) { const activePlayerIdsOrdered = players.filter(p => activePlayersInHandList.includes(p)).map(p => p.id); let currentDealerIndexInActive = activePlayerIdsOrdered.indexOf(currentDealerPlayerId); if (currentDealerIndexInActive === -1) currentDealerIndexInActive = 0; for (let i = 0; i < activePlayerIdsOrdered.length; i++) { currentHandActivePlayerIdsOrder.push(activePlayerIdsOrdered[(currentDealerIndexInActive + 1 + i) % activePlayerIdsOrdered.length]); } } else { for (let i = 0; i < baseVisualOrder.length; i++) { const visualOrderIdx = (dealerPosInVisual + 1 + i) % baseVisualOrder.length; const pIdInVisual = baseVisualOrder[visualOrderIdx]; if (activePlayersInHandList.some(p => p.id === pIdInVisual)) { currentHandActivePlayerIdsOrder.push(pIdInVisual); } } } currentHandActivePlayerIdsOrder = currentHandActivePlayerIdsOrder.filter(id => activePlayersInHandList.some(p => p.id === id)).slice(0, numActiveInHand); if (currentHandActivePlayerIdsOrder.length >= 1) { sbPlayer = players.find(p => p.id === currentHandActivePlayerIdsOrder[0]); if (sbPlayer) sbPlayer.isSB = true; } if (currentHandActivePlayerIdsOrder.length >= 2) { bbPlayer = players.find(p => p.id === currentHandActivePlayerIdsOrder[1]); if (bbPlayer) bbPlayer.isBB = true; } }
            players.forEach(p => { if (currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && (p.chips > 0 || p.isAllIn) ) { p.positionCategory = getPlayerPositionCategory(p, currentDealerPlayerId, numActiveInHand, currentHandActivePlayerIdsOrder); } else { p.positionCategory = "Folded/Out"; } });
            if (sbPlayer) { const sbAmountToPost = Math.min(SMALL_BLIND_AMOUNT_CONFIG, sbPlayer.chips); sbPlayer.chips -= sbAmountToPost; sbPlayer.betInRound = sbAmountToPost; pot += sbAmountToPost; displayMessage(`${sbPlayer.name} (SB) ${formatNumberWithCommas(sbAmountToPost)}원 자동 베팅.`, sbPlayer.type === "human" ? "player-action" : "ai-action"); if (sbPlayer.chips === 0 && sbAmountToPost > 0) sbPlayer.isAllIn = true; }
            if (bbPlayer) { const bbAmountToPost = Math.min(BIG_BLIND_AMOUNT_CONFIG, bbPlayer.chips); bbPlayer.chips -= bbAmountToPost; bbPlayer.betInRound = bbAmountToPost; pot += bbAmountToPost; displayMessage(`${bbPlayer.name} (BB) ${formatNumberWithCommas(bbAmountToPost)}원 자동 베팅.`, bbPlayer.type === "human" ? "player-action" : "ai-action"); if (bbPlayer.chips === 0 && bbAmountToPost > 0) bbPlayer.isAllIn = true; }
            currentBet = BIG_BLIND_AMOUNT_CONFIG;
            for (let i = 0; i < 2; i++) { for (const playerIdToDeal of currentHandActivePlayerIdsOrder) { const p = players.find(pl => pl.id === playerIdToDeal); if (p && !p.isFolded) { const newCard = dealCardFromDeck(p.type === "ai" && !isAdminMode); p.cards.push(newCard); renderPlayerCard(p, newCard, p.type === "ai" && !isAdminMode); await sleep(100); } } }
            gamePhase = "PREFLOP";
            if (currentHandActivePlayerIdsOrder.length > 0) { let firstToActOrderIndex = 0; if (numActiveInHand === 2) { firstToActOrderIndex = 0; } else if (numActiveInHand > 2) { firstToActOrderIndex = 2 % currentHandActivePlayerIdsOrder.length; } currentTurnInOrderIndex = firstToActOrderIndex; let initialSearchOrderIndex = currentTurnInOrderIndex; let foundFirst = false; for(let i=0; i<currentHandActivePlayerIdsOrder.length; i++){ const pId = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]; const pObj = players.find(p=>p.id === pId); if(pObj && !pObj.isFolded && !pObj.isAllIn && pObj.chips > 0) { foundFirst = true; break; } currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length; if(currentTurnInOrderIndex === initialSearchOrderIndex && i > 0) break; } if(foundFirst){ currentPlayerIndex = players.findIndex(p => p.id === currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]); } else { currentPlayerIndex = -1; } } else { currentPlayerIndex = -1; }
            lastRaiserId = bbPlayer ? bbPlayer.id : (sbPlayer ? sbPlayer.id : -1) ;
            updateOverallUI();
            const activeNonAllInPlayers = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            if (currentPlayerIndex === -1 || activeNonAllInPlayers.length === 0) { await advanceGamePhase(); }
            else if (activeNonAllInPlayers.length === 1 && players[currentPlayerIndex] && players[currentPlayerIndex].isAllIn) { await advanceGamePhase(); }
            else { await startBettingRound(); }
        }

        async function startBettingRound() {
            players.forEach(p => { if (!p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; if (!p.isFolded) p.raisesThisRoundCount = 0; });
            displayMessage(`--- ${gamePhase} 라운드 시작 ---`, "game-event");
            if (gamePhase !== "PREFLOP") {
                currentTurnInOrderIndex = 0; 
                let initialSearchOrderIndex = currentTurnInOrderIndex; let foundFirst = false;
                for(let i=0; i<currentHandActivePlayerIdsOrder.length; i++){ const pId = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]; const pObj = players.find(p=>p.id === pId); if(pObj && !pObj.isFolded && !pObj.isAllIn && pObj.chips > 0) { foundFirst = true; break; } currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length; if(currentTurnInOrderIndex === initialSearchOrderIndex && i > 0 && !foundFirst) { currentPlayerIndex = -1; break; } }
                if(foundFirst){ currentPlayerIndex = players.findIndex(p => p.id === currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]); } else { currentPlayerIndex = -1; }
                players.forEach(p => { if(!p.isFolded && !p.isAllIn) p.betInRound = 0; }); 
                currentBet = 0; minRaiseAmount = BIG_BLIND_AMOUNT_CONFIG; lastRaiserId = -1;
            }
            const activeForBetting = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            const allInPlayersThisRound = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && p.isAllIn);
            if (currentPlayerIndex === -1 || (activeForBetting.length === 0 && allInPlayersThisRound.length > 0) ) { displayMessage("모든 잔여 플레이어가 올인 상태거나 액션할 플레이어 없음. 다음 단계로 진행.", "game-event"); await sleep(1000); await advanceGamePhase(); return; } 
            else if (activeForBetting.length <=1 ) { const nonAllInCanAct = activeForBetting; let bettingStillPossible = false; if (nonAllInCanAct.length === 1) { const actor = nonAllInCanAct[0]; bettingStillPossible = (currentBet > 0 && actor.betInRound < currentBet && actor.chips > 0) || (gamePhase === "PREFLOP" && actor.isBB && currentBet === BIG_BLIND_AMOUNT_CONFIG && !actor.hasActedThisBettingRound && (lastRaiserId === actor.id || lastRaiserId === -1 || players.find(p=>p.id===lastRaiserId)?.isAllIn ) ); } if (!bettingStillPossible) { const isOnlyOnePlayerLeftOverall = players.filter(p => !p.isFolded).length === 1; if(!isOnlyOnePlayerLeftOverall && activeForBetting.length <=1){ displayMessage("베팅할 플레이어가 한 명 이하. 다음 단계로 진행.", "game-event"); await sleep(1000); await advanceGamePhase(); return; } } }
            updateOverallUI();
            await processPlayerTurn();
        }

        async function processPlayerTurn() {
            if (currentPlayerIndex === -1 || currentTurnInOrderIndex === -1 || currentHandActivePlayerIdsOrder.length === 0) { console.warn("processPlayerTurn: No current player. Advancing phase."); await advanceGamePhase(); return; }
            const currentPlayerIdToAct = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
            const currentPlayerObject = players.find(p => p.id === currentPlayerIdToAct);
            if (!currentPlayerObject || currentPlayerObject.isFolded || currentPlayerObject.isAllIn) { console.warn(`processPlayerTurn: Player ${currentPlayerIdToAct} cannot act. Switching.`); await switchToNextPlayerOrEndRound(); return; }
            currentPlayerIndex = players.findIndex(p => p.id === currentPlayerIdToAct); 
            displayMessage(`${currentPlayerObject.name}의 턴. (포지션: ${currentPlayerObject.positionCategory}) 현재 베팅액: ${formatNumberWithCommas(currentBet)}원`, "system-message");
            updateOverallUI();
            if (currentPlayerObject.type === "human") { /* Human turn handled by event listeners */ } 
            else { const delay = AI_ACTION_BASE_DELAY_MS + 800 + Math.random() * 1000; await sleep(delay); await handleAIAction(currentPlayerObject); }
        }

        async function handleHumanAction(actionType) {
            const humanPlayer = players[currentPlayerIndex];
            if (!humanPlayer || humanPlayer.type !== "human" || humanPlayer.isFolded || humanPlayer.isAllIn) { console.warn("Human action: invalid player/state."); await switchToNextPlayerOrEndRound(); return; }
            humanPlayer.hasActedThisBettingRound = true; humanPlayer.previousAction = actionType; let actualBetMadeThisAction = 0;
            switch (actionType) {
                case 'FOLD': humanPlayer.isFolded = true; showEnhancedFeedback(humanPlayer.id, "폴드...", "feedback-fold"); displayMessage(`${humanPlayer.name} 폴드.`, "player-action"); break;
                case 'CHECK_CALL': const amountToCall = currentBet - humanPlayer.betInRound; if (amountToCall > 0) { actualBetMadeThisAction = Math.min(amountToCall, humanPlayer.chips); humanPlayer.chips -= actualBetMadeThisAction; humanPlayer.betInRound += actualBetMadeThisAction; pot += actualBetMadeThisAction; showEnhancedFeedback(humanPlayer.id, "콜!", "feedback-call"); displayMessage(`${humanPlayer.name} ${formatNumberWithCommas(actualBetMadeThisAction)}원 콜 (총 ${formatNumberWithCommas(humanPlayer.betInRound)}원).`, "player-action"); if (humanPlayer.chips === 0 && actualBetMadeThisAction > 0) humanPlayer.isAllIn = true; } else { showEnhancedFeedback(humanPlayer.id, "체크", "feedback-check"); displayMessage(`${humanPlayer.name} 체크.`, "player-action"); } break;
                case 'BET_RAISE': let desiredTotalBet = parseInt(raiseInput.value); if (isNaN(desiredTotalBet) || desiredTotalBet < 0) { displayMessage("유효한 금액 입력.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return; } if (desiredTotalBet > humanPlayer.chips + humanPlayer.betInRound) desiredTotalBet = humanPlayer.chips + humanPlayer.betInRound; actualBetMadeThisAction = desiredTotalBet - humanPlayer.betInRound; if (actualBetMadeThisAction < 0) { displayMessage("잘못된 베팅 금액.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return; } let feedbackText = ""; let feedbackClass = ""; if (currentBet === 0) { if (desiredTotalBet < minRaiseAmount && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) { displayMessage(`최소 벳: ${formatNumberWithCommas(minRaiseAmount)}원.`, "system-message"); humanPlayer.hasActedThisBettingRound = false; return; } feedbackText = "벳!"; feedbackClass = "feedback-bet"; } else { if (desiredTotalBet < currentBet + minRaiseAmount && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) { displayMessage(`최소 레이즈 총액: ${formatNumberWithCommas(currentBet + minRaiseAmount)}원.`, "system-message"); humanPlayer.hasActedThisBettingRound = false; return; } if (desiredTotalBet <= currentBet && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) { displayMessage("레이즈는 현재 베팅보다 커야 함.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return; } feedbackText = "레이즈!"; feedbackClass = "feedback-raise"; } humanPlayer.chips -= actualBetMadeThisAction; humanPlayer.betInRound += actualBetMadeThisAction; pot += actualBetMadeThisAction; showEnhancedFeedback(humanPlayer.id, feedbackText, feedbackClass); displayMessage(`${humanPlayer.name} ${formatNumberWithCommas(actualBetMadeThisAction)}원 ${currentBet === 0 ? '벳' : '레이즈'} (총 ${formatNumberWithCommas(humanPlayer.betInRound)}원).`, "player-action"); if (humanPlayer.chips === 0 && actualBetMadeThisAction > 0) humanPlayer.isAllIn = true; if (humanPlayer.betInRound > currentBet) { minRaiseAmount = humanPlayer.betInRound - currentBet; currentBet = humanPlayer.betInRound; lastRaiserId = humanPlayer.id; players.forEach(p => { if (p.id !== humanPlayer.id && !p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; }); } break;
            }
            updateOverallUI(); 
            await switchToNextPlayerOrEndRound();
        }

        async function handleAIAction(aiPlayer) {
            if (aiPlayer.isFolded || aiPlayer.isAllIn) { await switchToNextPlayerOrEndRound(); return; }
            showAIActionEffect(); aiPlayer.hasActedThisBettingRound = true;
            let decisionType = "FOLD"; let aiActionAmount = 0; let actualChipsToCommit = 0;
            let isBluffing = false; 
            
            let amountToCall = currentBet - aiPlayer.betInRound;
            const holeCardStrength = evaluateHoleCards(aiPlayer.cards); 
            const combinedHand = [...aiPlayer.cards, ...communityCards];
            const currentMadeHandDetails = getHandDetails(combinedHand);
            const drawPotential = evaluateDrawPotential(communityCards, aiPlayer.cards);
            const boardInfo = analyzeBoardTexture(communityCards);
            let effectiveHandStrength = currentMadeHandDetails.strength / HAND_STRENGTH.ROYAL_FLUSH;
            if (drawPotential.outs > 0) { effectiveHandStrength += Math.min(0.25, drawPotential.outs * 0.015 + Math.random() * 0.02); }
            const activeOpponents = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && p.id !== aiPlayer.id && !p.isFolded && !p.isAllIn && p.chips > 0);
            const aggressionMod = aiPlayer.aggressionFactor; const tightnessMod = aiPlayer.tightnessFactor;
            const potOdds = calculatePotOdds(amountToCall, pot + currentBet + amountToCall); 
            let positionTightnessFactor = 1.0;
            if (aiPlayer.positionCategory === "Early" || aiPlayer.positionCategory === "UTG") positionTightnessFactor = 1.25; // 더 신중하게
            else if (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer") positionTightnessFactor = 0.80; // 더 루즈하게

            if (gamePhase === "PREFLOP") {
                let openRaiseMultiplier = 1.9 + (0.6 / (tightnessMod * positionTightnessFactor)) + (aggressionMod > 1 ? (aggressionMod - 1) * 0.15 : (aggressionMod - 1) * 0.05);
                if (aiPlayer.positionCategory === "SB_Dealer") openRaiseMultiplier = Math.max(2.0, openRaiseMultiplier * 1.02); 
                else if (aiPlayer.positionCategory === "Early" || aiPlayer.positionCategory === "UTG") openRaiseMultiplier *= 0.90; 
                let openRaiseSize = Math.floor(BIG_BLIND_AMOUNT_CONFIG * openRaiseMultiplier); 
                openRaiseSize = Math.max(BIG_BLIND_AMOUNT_CONFIG * 2, openRaiseSize); // 최소 2BB
                openRaiseSize = Math.min(openRaiseSize, aiPlayer.chips * 0.8); // 스택의 80% 이상은 오픈 레이즈로 쓰지 않음 (올인 제외)
                if (openRaiseSize >= aiPlayer.chips) openRaiseSize = aiPlayer.chips; // 올인 가능


                let callThreshold = 0.48 * tightnessMod * positionTightnessFactor; 
                let raiseThreshold = 0.68 * tightnessMod * positionTightnessFactor * (1 + (aggressionMod - 1) * 0.3); 

                if (activeOpponents.length >= 2) raiseThreshold *= 1.03; else if (activeOpponents.length === 1) raiseThreshold *= 1.01;
                
                const isFoldedToSBvsBB = aiPlayer.isSB && currentBet === BIG_BLIND_AMOUNT_CONFIG && activeOpponents.length === 1 && activeOpponents[0].isBB;
                if (amountToCall === 0) { 
                    if (isFoldedToSBvsBB) { let sbStealRaiseThreshold = 0.40 / (tightnessMod * positionTightnessFactor) * aggressionMod; let sbCompleteCallThreshold = 0.22 / (tightnessMod * positionTightnessFactor); if (holeCardStrength > sbStealRaiseThreshold || (holeCardStrength > 0.30 && Math.random() < 0.35 * aggressionMod)) { decisionType = "BET_RAISE"; aiActionAmount = Math.floor(BIG_BLIND_AMOUNT_CONFIG * (1.8 + aggressionMod * 0.5 + Math.random() * 0.3)); aiPlayer.raisesThisRoundCount++; } else if (holeCardStrength > sbCompleteCallThreshold && ((aiPlayer.cards[0].suit === aiPlayer.cards[1].suit) || Math.abs(aiPlayer.cards[0].value - aiPlayer.cards[1].value) <= 4)) { decisionType = "CHECK_CALL"; aiActionAmount = BIG_BLIND_AMOUNT_CONFIG - aiPlayer.betInRound; if (aiActionAmount < 0) aiActionAmount = 0; } else { decisionType = "FOLD"; } }
                    else if (aiPlayer.isBB && currentBet === BIG_BLIND_AMOUNT_CONFIG && !players.some(p => p.id !== aiPlayer.id && p.betInRound > BIG_BLIND_AMOUNT_CONFIG && p.hasActedThisBettingRound && currentHandActivePlayerIdsOrder.indexOf(p.id) < currentHandActivePlayerIdsOrder.indexOf(aiPlayer.id) && !p.isFolded && !p.isAllIn)) { decisionType = "CHECK_CALL"; aiActionAmount = 0; } 
                    else if (holeCardStrength > raiseThreshold) { decisionType = "BET_RAISE"; aiActionAmount = openRaiseSize; aiPlayer.raisesThisRoundCount++; }
                    else if (holeCardStrength > (callThreshold * 0.75) && (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer") && Math.random() < (0.20 / tightnessMod)) { decisionType = "CHECK_CALL"; aiActionAmount = BIG_BLIND_AMOUNT_CONFIG - aiPlayer.betInRound; if(aiActionAmount < 0) aiActionAmount = 0; if(currentBet === 0 && aiPlayer.betInRound === 0) aiActionAmount = BIG_BLIND_AMOUNT_CONFIG;}
                    else { decisionType = "FOLD"; }
                } else { 
                    let threeBetThreshold = (0.82 / (tightnessMod * positionTightnessFactor)) * (1 + (aggressionMod - 1) * 0.20); 
                    let threeBetMultiplierForSizeCalc = (1.3 + (aggressionMod > 1 ? (aggressionMod - 1) * 0.10 : 0));
                    if (activeOpponents.length >= 2) { threeBetThreshold *= 1.10; threeBetMultiplierForSizeCalc *= 0.92;  } else if (activeOpponents.length === 1) { threeBetThreshold *= 1.04; threeBetMultiplierForSizeCalc *= 0.96; }
                    
                    let desiredTotalBetFor3Bet = currentBet * (1.9 + threeBetMultiplierForSizeCalc + (aiPlayer.positionCategory.includes("Early") || aiPlayer.positionCategory.includes("SB") ? 0.20 : 0));
                    desiredTotalBetFor3Bet = Math.max(desiredTotalBetFor3Bet, currentBet + BIG_BLIND_AMOUNT_CONFIG * 1.5);
                    let threeBetTargetAdditional = desiredTotalBetFor3Bet - aiPlayer.betInRound;
                    threeBetTargetAdditional = Math.max(minRaiseAmount, threeBetTargetAdditional);
                    threeBetTargetAdditional = Math.min(threeBetTargetAdditional, aiPlayer.chips * 0.8); // 스택의 80% 이상 3벳 지양
                    if (threeBetTargetAdditional >= aiPlayer.chips) threeBetTargetAdditional = aiPlayer.chips;


                    let allowRaise = !(activeOpponents.length === 1 && aiPlayer.raisesThisRoundCount >=1 && holeCardStrength < 0.88); // HU 3벳 후 리레이즈는 매우 강패만
                    
                    if (currentBet >= aiPlayer.chips + aiPlayer.betInRound) { decisionType = (holeCardStrength > (callThreshold * 0.82 / (tightnessMod * positionTightnessFactor))) ? "CHECK_CALL" : "FOLD"; if (decisionType === "CHECK_CALL") aiActionAmount = amountToCall; }
                    else if (allowRaise && holeCardStrength > threeBetThreshold && amountToCall < aiPlayer.chips / 1.8) { decisionType = "BET_RAISE"; aiActionAmount = threeBetTargetAdditional; aiPlayer.raisesThisRoundCount++; }
                    else if (holeCardStrength > callThreshold || (holeCardStrength > 0.25 && potOdds < 0.50 && activeOpponents.length <= 1) || (aiPlayer.isBB && potOdds < 0.55 && holeCardStrength > 0.20 && currentBet <= BIG_BLIND_AMOUNT_CONFIG * 3.0)) { decisionType = "CHECK_CALL"; aiActionAmount = amountToCall; }
                    else { 
                        let bluff3BetChance = 0.04 * (1 + (aggressionMod - 1) * 0.35); 
                        if (activeOpponents.length >= 2) { bluff3BetChance *= 0.20; } else if (activeOpponents.length === 1) { bluff3BetChance *= 0.50;}
                        const lastRaiserPlayerObj = players.find(p => p.id === lastRaiserId);
                        const canConsiderBluff3Bet = allowRaise && lastRaiserPlayerObj && (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer" || aiPlayer.isBB) && (lastRaiserPlayerObj.positionCategory.includes("Late") || lastRaiserPlayerObj.positionCategory === "CutOff" || lastRaiserPlayerObj.positionCategory === "Dealer") && Math.random() < bluff3BetChance && (amountToCall + threeBetTargetAdditional) < aiPlayer.chips * 0.30;
                        if (canConsiderBluff3Bet) { decisionType = "BET_RAISE"; aiActionAmount = Math.floor(threeBetTargetAdditional * (0.65 + Math.random() * 0.1)); isBluffing = true; aiPlayer.raisesThisRoundCount++; }
                        else { decisionType = "FOLD"; }
                    }
                }
                if (decisionType === "BET_RAISE" && !isBluffing && effectiveHandStrength < 0.50) { // 기존 0.48 -> 0.50으로 약간 상향
                     if (holeCardStrength > callThreshold * 0.98 && amountToCall <= aiPlayer.chips * 0.28) { 
                         decisionType = "CHECK_CALL"; aiActionAmount = amountToCall; aiPlayer.raisesThisRoundCount = Math.max(0, aiPlayer.raisesThisRoundCount -1);
                     } else { decisionType = "FOLD"; aiActionAmount = 0; aiPlayer.raisesThisRoundCount = Math.max(0, aiPlayer.raisesThisRoundCount -1); }
                     console.log(`AI (${aiPlayer.name}) PREFLOP_RAISE_ADJUSTED due to weak hand, new action: ${decisionType}`);
                }

            } else { // POSTFLOP
                let valueBetStrength = 0.52 / tightnessMod; 
                let semiBluffStrength = 0.28 / tightnessMod; 
                let callStrength = 0.25 / tightnessMod; // 콜 기준 약간 완화
                let checkRaiseStrength = 0.65 / tightnessMod * aggressionMod;
                const isLimpedPot = gamePhase === "FLOP" && players.filter(p=>!p.isFolded).every(p => p.betInRound <= BIG_BLIND_AMOUNT_CONFIG);
                const isMultiwayPot = activeOpponents.length >= 2;

                if (amountToCall > 0 && (isLimpedPot || isMultiwayPot) && lastRaiserId !== aiPlayer.id && lastRaiserId !== -1 && players.find(p=>p.id===lastRaiserId)?.type === 'human') {
                    const betSizeRatioToPot = amountToCall / (pot + amountToCall); 
                    if (betSizeRatioToPot < 0.4) callStrength *= 0.80; 
                    else if (betSizeRatioToPot > 0.75) callStrength *= 1.10; 
                    if (drawPotential.outs > 4) callStrength *= 0.88; // 드로우 있으면 좀 더 콜
                    if(currentMadeHandDetails.strength >= HAND_STRENGTH.ONE_PAIR) callStrength *=0.85; // 원페어라도 있으면 좀 더 콜
                }

                if (lastRaiserId === aiPlayer.id && amountToCall === 0 && gamePhase === "FLOP") { 
                    let cbetProb = (0.48 + 0.18 * aggressionMod); if (boardInfo.type === "dry_uncoordinated") cbetProb = Math.min(0.88, cbetProb * 1.22); else if (boardInfo.isWet) cbetProb *= 0.78; if (activeOpponents.length === 1) { if (boardInfo.highCardValue >= RANK_VALUES.Q && !boardInfo.isWet) cbetProb = Math.min(0.88, cbetProb * 1.08); } else if (activeOpponents.length > 1) { cbetProb *= (1 / (1 + 0.42 * (activeOpponents.length - 1))); } 
                    if (effectiveHandStrength > 0.40 || (drawPotential.outs >= 5 && Math.random() < 0.60) || Math.random() < cbetProb) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount++; let cbetSizeRatio = 0.28 + Math.random() * 0.22 * aggressionMod; if (boardInfo.isWet) cbetSizeRatio = Math.min(0.65, cbetSizeRatio * 1.12); if (activeOpponents.length > 1) cbetSizeRatio *= 0.88; aiActionAmount = Math.floor(pot * cbetSizeRatio); if (effectiveHandStrength < 0.36 && drawPotential.outs < 3 && Math.random() < cbetProb) isBluffing = true; } else { decisionType = "CHECK_CALL"; } 
                }
                else if (amountToCall === 0 && (gamePhase === "TURN" || gamePhase === "RIVER") && ((lastRaiserId !== aiPlayer.id && players.find(p=>p.id===lastRaiserId)?.previousAction === 'CHECK_CALL' && players.find(p=>p.id===lastRaiserId)?.betInRound === 0) || (lastRaiserId === -1 && players.filter(p=>currentHandActivePlayerIdsOrder.includes(p.id)).every(p => p.isFolded || p.isAllIn || (p.hasActedThisBettingRound && p.betInRound === 0) || p.id === aiPlayer.id)))) { 
                    let probeBetProb = 0.33 * aggressionMod; if(boardInfo.type === "dry_uncoordinated" || (boardInfo.type === "paired" && !boardInfo.isWet) ) probeBetProb = Math.min(0.72, probeBetProb * 1.18); if (activeOpponents.length > 0) { probeBetProb *= (1 / (1 + 0.22 * activeOpponents.length)); } if (effectiveHandStrength > 0.38 || (drawPotential.outs >= 3 && Math.random() < 0.52) || Math.random() < probeBetProb) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount++; let probeBetSizeRatio = 0.33 + Math.random() * 0.22 * aggressionMod; if (activeOpponents.length > 0) probeBetSizeRatio *= 0.92; aiActionAmount = Math.floor(pot * probeBetSizeRatio); if (effectiveHandStrength < 0.33 && drawPotential.outs < 2 && Math.random() < probeBetProb) isBluffing = true; } else { decisionType = "CHECK_CALL"; } 
                }
                else if (amountToCall === 0) { 
                    if (effectiveHandStrength > valueBetStrength) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount++; let valueBetSizeRatio = 0.42 + effectiveHandStrength * 0.22 * aggressionMod; if (boardInfo.isWet) valueBetSizeRatio = Math.min(0.72, valueBetSizeRatio * 1.08); if (activeOpponents.length > 1) valueBetSizeRatio *= 0.88; aiActionAmount = Math.floor(pot * valueBetSizeRatio); } 
                    else if (effectiveHandStrength > semiBluffStrength && (drawPotential.outs >= 4 || Math.random() < (0.28 * aggressionMod))) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount++; let semiBluffBetSizeRatio = 0.26 + Math.random() * 0.26 * aggressionMod; if (activeOpponents.length > 1) semiBluffBetSizeRatio *= 0.82; aiActionAmount = Math.floor(pot * semiBluffBetSizeRatio); if (effectiveHandStrength < 0.33 && drawPotential.outs < 6) isBluffing = true; } 
                    else { decisionType = "CHECK_CALL"; } 
                }
                else { 
                    let allowRaise = !(activeOpponents.length === 1 && aiPlayer.raisesThisRoundCount >= 1 && effectiveHandStrength < 0.86); // 몬스터급 아니면 HU에서 리레이즈 자제
                    let checkRaiseProbMod = 1.0; if (activeOpponents.length >= 1) { checkRaiseProbMod = 1 / (1 + 0.22 * activeOpponents.length); }
                    if (allowRaise && (aiPlayer.positionCategory.includes("Early") || aiPlayer.positionCategory === "SB" || aiPlayer.positionCategory === "BB") && !aiPlayer.hasActedThisBettingRound && effectiveHandStrength > checkRaiseStrength && amountToCall < pot * 0.65 && Math.random() < (0.13 * aggressionMod * checkRaiseProbMod) && (!boardInfo.isWet || drawPotential.outs > 5)) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount++; let checkRaiseSizeMultiplier = 1.65 + aggressionMod * 0.65; if (activeOpponents.length >= 1) checkRaiseSizeMultiplier *= (0.92 / (1 + 0.06 * activeOpponents.length)); aiActionAmount = Math.floor(amountToCall * checkRaiseSizeMultiplier + pot * 0.16); if(effectiveHandStrength < (checkRaiseStrength * 0.78) && drawPotential.outs < 3) isBluffing = true; }
                    else if (currentBet >= aiPlayer.chips + aiPlayer.betInRound) { decisionType = (effectiveHandStrength > (callStrength * 0.80) + (drawPotential.outs * 0.016)) ? "CHECK_CALL" : "FOLD"; if (decisionType === "CHECK_CALL") aiActionAmount = amountToCall; }
                    else if (allowRaise && effectiveHandStrength > (valueBetStrength * 1.06) && amountToCall < aiPlayer.chips / 1.6) { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount++; let valueRaiseMultiplier = 1.55 + aggressionMod * 0.65; if (activeOpponents.length >= 1) valueRaiseMultiplier *= (0.94 / (1 + 0.06 * activeOpponents.length)); if (activeOpponents.length === 1) valueRaiseMultiplier *= 0.94; aiActionAmount = Math.floor(amountToCall * valueRaiseMultiplier + pot * 0.18); }
                    else if (effectiveHandStrength > callStrength || (drawPotential.outs >= 6 && potOdds < 0.52) || (drawPotential.outs >=3 && potOdds < 0.45)) { decisionType = "CHECK_CALL"; aiActionAmount = amountToCall; }
                    else if (allowRaise && drawPotential.outs >= 5 && potOdds < (0.40 / tightnessMod) && Math.random() < (0.30 * aggressionMod) && !boardInfo.isPaired && gamePhase !== "RIVER") { decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount++; let semiBluffRaiseMultiplier = 1.45 + aggressionMod * 0.50; if (activeOpponents.length >= 1) semiBluffRaiseMultiplier *= (0.88 / (1 + 0.06 * activeOpponents.length)); if (activeOpponents.length === 1) semiBluffRaiseMultiplier *= 0.94; aiActionAmount = Math.floor(amountToCall * semiBluffRaiseMultiplier + pot * 0.10); isBluffing = true; }
                    else { const spr = aiPlayer.chips > 0 ? (pot + amountToCall) / (aiPlayer.chips - amountToCall) : 100; if (spr < 2.0 && effectiveHandStrength > 0.08 && potOdds < 0.70) { decisionType = "CHECK_CALL"; aiActionAmount = amountToCall; } else { decisionType = "FOLD"; } }
                }
                if (decisionType === "FOLD" || (decisionType === "CHECK_CALL" && amountToCall === 0 && effectiveHandStrength < 0.30)) { 
                    let currentBluffChance = BLUFF_PROBABILITY_BASE * aggressionMod * (boardInfo.isWet ? 0.70 : 1.15); if (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer" || aiPlayer.positionCategory === "SB_Dealer") currentBluffChance *= 1.25; if (gamePhase === "RIVER") { const commSuitCounts = {}; communityCards.forEach(c => commSuitCounts[c.suit] = (commSuitCounts[c.suit] || 0) + 1); const flushPossible = Math.max(...Object.values(commSuitCounts).map(Number), 0); if (flushPossible === 4 && currentMadeHandDetails.strength < HAND_STRENGTH.FLUSH) { currentBluffChance *= 1.65; } else if (flushPossible === 3 && currentMadeHandDetails.strength < HAND_STRENGTH.FLUSH && drawPotential.type.includes("flush")) { currentBluffChance *= 1.45; } if (currentMadeHandDetails.strength < HAND_STRENGTH.ONE_PAIR && !boardInfo.isPaired && (boardInfo.type === "dry_uncoordinated" || boardInfo.highCardValue < RANK_VALUES["10"])) { currentBluffChance *= 1.45; } } 
                    if (activeOpponents.every(opp => opp.previousAction === 'CHECK_CALL' && opp.betInRound === 0 && opp.chips > 0)) { currentBluffChance *= 1.55; } 
                    const lastRaiserObjBluff = players.find(p=>p.id === lastRaiserId); if (lastRaiserObjBluff && lastRaiserObjBluff.previousAction === "CHECK_CALL" && lastRaiserObjBluff.betInRound === 0) { currentBluffChance *= 1.25; } 
                    if (activeOpponents.length >= 2) { currentBluffChance *= 0.30; } else if (activeOpponents.length === 1) { currentBluffChance *= 0.60; } 
                    if (Math.random() < currentBluffChance && amountToCall < aiPlayer.chips * 0.55) { isBluffing = true; decisionType = "BET_RAISE"; aiPlayer.raisesThisRoundCount++; let bluffSizeBase = (gamePhase === "RIVER") ? 0.50 : 0.40; let bluffRatio = bluffSizeBase + Math.random() * 0.28 * aggressionMod; if (activeOpponents.length >= 2) { bluffRatio *= 0.70; } else if (activeOpponents.length === 1) { bluffRatio *= 0.82; } aiActionAmount = Math.floor(pot * bluffRatio); } 
                }
            }

            aiActionAmount = Math.max(0, Math.floor(aiActionAmount));
            if (decisionType === "BET_RAISE") { let intendedAddBet = aiActionAmount; let intendedTotalAfterAIAction = aiPlayer.betInRound + intendedAddBet; if (currentBet === 0) { if (intendedTotalAfterAIAction < minRaiseAmount && intendedTotalAfterAIAction < aiPlayer.chips + aiPlayer.betInRound) { if (effectiveHandStrength < 0.3 && !isBluffing) { decisionType = "CHECK_CALL"; actualChipsToCommit = 0; } else { actualChipsToCommit = Math.min(aiPlayer.chips, minRaiseAmount - aiPlayer.betInRound); if (actualChipsToCommit < 0) actualChipsToCommit = 0; if (aiPlayer.chips <= minRaiseAmount - aiPlayer.betInRound) actualChipsToCommit = aiPlayer.chips; else if (aiPlayer.betInRound + actualChipsToCommit < minRaiseAmount) { decisionType = "CHECK_CALL"; actualChipsToCommit = 0; } } } else { actualChipsToCommit = Math.min(aiPlayer.chips, intendedAddBet); } } else { if (intendedTotalAfterAIAction < currentBet + minRaiseAmount && intendedTotalAfterAIAction < aiPlayer.chips + aiPlayer.betInRound) { const amountToCallForAI = currentBet - aiPlayer.betInRound; if (amountToCallForAI <= aiPlayer.chips && amountToCallForAI >= 0) { decisionType = "CHECK_CALL"; actualChipsToCommit = amountToCallForAI; } else { decisionType = "FOLD"; actualChipsToCommit = 0; } } else if (intendedTotalAfterAIAction === currentBet) { decisionType = "CHECK_CALL"; actualChipsToCommit = currentBet - aiPlayer.betInRound; if (actualChipsToCommit < 0) actualChipsToCommit = 0; actualChipsToCommit = Math.min(aiPlayer.chips, actualChipsToCommit); } else { actualChipsToCommit = Math.min(aiPlayer.chips, intendedAddBet); } } } else if (decisionType === "CHECK_CALL") { actualChipsToCommit = Math.min(aiPlayer.chips, currentBet - aiPlayer.betInRound); if (actualChipsToCommit < 0) actualChipsToCommit = 0; } else { actualChipsToCommit = 0; }
            aiPlayer.previousAction = decisionType; let feedbackText = ""; let feedbackClass = "";
            switch (decisionType) {
                case 'FOLD': if (currentBet - aiPlayer.betInRound > 0 ) { aiPlayer.isFolded = true; feedbackText = "폴드..."; feedbackClass = "feedback-fold"; displayMessage(`${aiPlayer.name} 폴드.`, "ai-action"); } else { decisionType = "CHECK_CALL"; aiPlayer.previousAction = "CHECK_CALL"; feedbackText = "체크"; feedbackClass = "feedback-check"; displayMessage(`${aiPlayer.name} 체크.`, "ai-action"); actualChipsToCommit = 0; } break;
                case 'CHECK_CALL': const amountToCallForAICheckCall = currentBet - aiPlayer.betInRound; if (amountToCallForAICheckCall > 0) { feedbackText = "콜!"; feedbackClass = "feedback-call"; } else { feedbackText = "체크"; feedbackClass = "feedback-check"; actualChipsToCommit = 0; } aiPlayer.chips -= actualChipsToCommit; aiPlayer.betInRound += actualChipsToCommit; pot += actualChipsToCommit; displayMessage(`${aiPlayer.name} ${feedbackText.replace("!", "")} (총 ${formatNumberWithCommas(aiPlayer.betInRound)}원).`, "ai-action"); if (aiPlayer.chips <= 0 && actualChipsToCommit >= 0 && !(aiPlayer.chips === 0 && actualChipsToCommit === 0)) { aiPlayer.isAllIn = true; if (aiPlayer.chips < 0) aiPlayer.chips = 0; } break;
                case 'BET_RAISE': if (actualChipsToCommit <= 0 && !(aiPlayer.chips ===0 && aiPlayer.betInRound > 0 && currentBet === 0) ) { feedbackText = "체크"; feedbackClass = "feedback-check"; displayMessage(`${aiPlayer.name} 체크 (내부 조정).`, "ai-action"); decisionType = "CHECK_CALL"; aiPlayer.previousAction = "CHECK_CALL"; } else { if (currentBet === 0) { feedbackText = "벳!"; feedbackClass = "feedback-bet"; } else { feedbackText = "레이즈!"; feedbackClass = "feedback-raise"; } aiPlayer.chips -= actualChipsToCommit; aiPlayer.betInRound += actualChipsToCommit; pot += actualChipsToCommit; displayMessage(`${aiPlayer.name} ${formatNumberWithCommas(actualChipsToCommit)}원 ${currentBet === 0 ? '벳' : '레이즈'} (총 ${formatNumberWithCommas(aiPlayer.betInRound)}원).`, "ai-action"); if (aiPlayer.chips <= 0 && actualChipsToCommit > 0) { aiPlayer.isAllIn = true; if (aiPlayer.chips < 0) aiPlayer.chips = 0; } if (aiPlayer.betInRound > currentBet) { minRaiseAmount = Math.max(BIG_BLIND_AMOUNT_CONFIG, aiPlayer.betInRound - currentBet); currentBet = aiPlayer.betInRound; lastRaiserId = aiPlayer.id; players.forEach(p => { if (p.id !== aiPlayer.id && !p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; }); } } break;
            }
            if (feedbackText && !aiPlayer.isFolded) { showEnhancedFeedback(aiPlayer.id, feedbackText, feedbackClass); } else if (aiPlayer.isFolded && feedbackText === "폴드...") { showEnhancedFeedback(aiPlayer.id, feedbackText, feedbackClass); }
            updateOverallUI(); 
            await switchToNextPlayerOrEndRound();
        }

        async function switchToNextPlayerOrEndRound() {
            const unfoldedPlayersStillInHand = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded);
            if (unfoldedPlayersStillInHand.length <= 1) { if (unfoldedPlayersStillInHand.length === 1) { const winner = unfoldedPlayersStillInHand[0]; displayMessage(`${winner.name} 승리! 다른 플레이어 폴드. (팟: ${formatNumberWithCommas(pot)}원)`, "game-event"); winner.chips += pot; pot = 0; if (winner.type === 'human') { showEnhancedFeedback(winner.id, "승리!", "feedback-win"); } } else { displayMessage("모든 플레이어가 폴드했습니다. 남은 팟은 다음 핸드로 이월되지 않습니다.", "game-event"); pot = 0; } await endCurrentHand(false); return; }
            let bettingOver = true; const activePlayersWhoCanBet = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            if (activePlayersWhoCanBet.length === 0 && unfoldedPlayersStillInHand.length > 0) { bettingOver = true; } 
            else if (activePlayersWhoCanBet.length > 0) { bettingOver = activePlayersWhoCanBet.every(p => p.hasActedThisBettingRound && (p.betInRound === currentBet || p.chips === 0)); if (bettingOver && gamePhase === "PREFLOP" && currentBet === BIG_BLIND_AMOUNT_CONFIG) { const bbPlayer = players.find(p => p.isBB && currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0); if (bbPlayer && !bbPlayer.hasActedThisBettingRound) { const isOnlyBbLeftToActOrNoRaise = players.filter(plr => currentHandActivePlayerIdsOrder.includes(plr.id) && !plr.isFolded && !plr.isAllIn && plr.id !== bbPlayer.id).every(plr => plr.hasActedThisBettingRound && plr.betInRound <= BIG_BLIND_AMOUNT_CONFIG); if (isOnlyBbLeftToActOrNoRaise) { bettingOver = false; } } } } 
            else { bettingOver = true; }
            if (bettingOver) { await advanceGamePhase(); } 
            else { let nextPlayerFound = false; let initialSearchOrderIndex = currentTurnInOrderIndex; for (let i = 0; i < currentHandActivePlayerIdsOrder.length; i++) { currentTurnInOrderIndex = (initialSearchOrderIndex + 1 + i) % currentHandActivePlayerIdsOrder.length; const nextPlayerIdToAct = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]; const nextPlayer = players.find(p => p.id === nextPlayerIdToAct); if (nextPlayer && !nextPlayer.isFolded && !nextPlayer.isAllIn && nextPlayer.chips > 0) { if (!nextPlayer.hasActedThisBettingRound || (nextPlayer.betInRound < currentBet && nextPlayer.chips > 0)) { currentPlayerIndex = players.findIndex(p => p.id === nextPlayerIdToAct); nextPlayerFound = true; break; } } } if (nextPlayerFound) { await processPlayerTurn(); } else { console.warn("SwitchToNext: No specific next player found, but bettingOver is false. Advancing phase."); await advanceGamePhase(); } }
        }
        async function advanceGamePhase() {
            displayMessage(`--- ${gamePhase} 베팅 종료 ---`, "game-event");
            const activePlayersForShowdown = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded);
            const playersCanStillBet = activePlayersForShowdown.filter(p => !p.isAllIn && p.chips > 0);
            const playersAllInThisRound = activePlayersForShowdown.filter(p => p.isAllIn); let runOutBoard = false;
            if (activePlayersForShowdown.length > 0) { if (playersCanStillBet.length === 0 && playersAllInThisRound.length >= 1) { runOutBoard = true; } else if (playersCanStillBet.length === 1 && playersAllInThisRound.length >= 1) { const soleBettor = playersCanStillBet[0]; let allAllInsCoveredOrBettorCannotBetMore = true; for (const pAllIn of playersAllInThisRound) { if (soleBettor.betInRound < pAllIn.betInRound && soleBettor.chips > 0) { allAllInsCoveredOrBettorCannotBetMore = false; break; } } if (allAllInsCoveredOrBettorCannotBetMore) runOutBoard = true; } }
            if ( runOutBoard && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND") { displayMessage("올인 상황 또는 베팅 가능한 플레이어가 한명 이하. 남은 카드 공개.", "game-event"); await revealAllAICards(); const phasesToDeal = []; if (gamePhase === "PREFLOP" && communityCards.length < 3) phasesToDeal.push("FLOP"); if ((gamePhase === "PREFLOP" || gamePhase === "FLOP") && communityCards.length < 4) phasesToDeal.push("TURN"); if ((gamePhase === "PREFLOP" || gamePhase === "FLOP" || gamePhase === "TURN") && communityCards.length < 5) phasesToDeal.push("RIVER"); for (const phase of phasesToDeal) { if (communityCards.length < 5) { await dealCommunityCardsForPhase(phase, true); } } gamePhase = "SHOWDOWN"; }
            if (gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND") { switch (gamePhase) { case "PREFLOP": gamePhase = "FLOP"; await dealCommunityCardsForPhase("FLOP"); break; case "FLOP": gamePhase = "TURN"; await dealCommunityCardsForPhase("TURN"); break; case "TURN": gamePhase = "RIVER"; await dealCommunityCardsForPhase("RIVER"); break; case "RIVER": gamePhase = "SHOWDOWN"; break; } }
            updateOverallUI(); 
            if (gamePhase === "SHOWDOWN") { await determineWinner(); } else if (gamePhase !== "END_HAND") { players.forEach(p => { if(!p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; }); await startBettingRound(); }
        }
        async function dealCommunityCardsForPhase(phaseToDeal, isRunOut = false) { if (!isRunOut) displayMessage(`--- ${phaseToDeal} 카드 공개 ---`, "game-event"); if (communityCards.length < 5) burnCard(); if (phaseToDeal === "FLOP" && communityCards.length < 3) { for (let i=0; i<3; i++) if(communityCards.length < 5) await dealAnimatedCommunityCard(dealCardFromDeck(false)); } else if (phaseToDeal === "TURN" && communityCards.length < 4) { if(communityCards.length < 5) await dealAnimatedCommunityCard(dealCardFromDeck(false)); } else if (phaseToDeal === "RIVER" && communityCards.length < 5) { if(communityCards.length < 5) await dealAnimatedCommunityCard(dealCardFromDeck(false)); } if (!isRunOut) await sleep(500); }
        async function revealAllAICards() { for (const p of players) { if (p.type === 'ai' && !p.isFolded) { for (const card of p.cards) { if (card.hidden) { revealHiddenCard(p, card); await sleep(200); } } } } await sleep(400); }

        async function endCurrentHand(showdownOccurred) {
            gamePhase = "END_HAND"; updateOverallUI(); initialPlayerChipsBeforeHand = {}; players.forEach(p => initialPlayerChipsBeforeHand[p.id] = p.chips); initialNumPlayersForNextHandLogic = actualNumPlayersInCurrentGame; 
            numPlayersSelect.disabled = false; startingChipsInputEl.disabled = false; bigBlindInputEl.disabled = false; aiDelayInputEl.disabled = false; 
            const activePlayersWithChips = players.filter(p => p.chips > 0); const humanPlayer = players.find(p => p.type === 'human'); 
            if (activePlayersWithChips.length <= 1) { const winner = activePlayersWithChips.length > 0 ? activePlayersWithChips[0] : (players.length > 0 ? players.find(p => p.isAllIn && !p.isFolded && p.chips > 0) : null); displayMessage(winner ? `${winner.name} 최종 승리!` : "게임 종료 - 최종 승자 없음", "game-event"); if (winner && winner.type === 'human') { showEnhancedFeedback(winner.id, "최종 승리!", "feedback-win"); } else if (humanPlayer && humanPlayer.chips <= 0 && !activePlayersWithChips.some(ap => ap.id === humanPlayer.id)) { showEnhancedFeedback(humanPlayer.id, "최종 패배ㅠㅠ", "feedback-lose"); } controlButtonsArea.innerHTML = `<button id="start-game-button-main-end">새 게임</button><button id="continue-game-button">이어하기</button>`; document.getElementById('start-game-button-main-end').addEventListener('click', () => { gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none'; initializeNewGame(); }); const continueBtn = document.getElementById('continue-game-button'); if (players.length === 0 || players.filter(p=>p.chips > 0).length <=1) { continueBtn.disabled = true; continueBtn.title = "이어하기 불가능: 칩을 가진 플레이어가 1명 이하입니다."; } else { continueBtn.disabled = (parseInt(numPlayersSelect.value) !== initialNumPlayersForNextHandLogic); continueBtn.title = continueBtn.disabled ? "이어하기 불가능: 이전 게임과 인원수가 다릅니다." : "이전 칩 상태로 이어하기"; } continueBtn.addEventListener('click', () => { if (parseInt(numPlayersSelect.value) === initialNumPlayersForNextHandLogic && !(players.length === 0 || players.filter(p=>p.chips > 0).length <=1) ) { players.forEach(p => { p.chips = initialPlayerChipsBeforeHand[p.id] !== undefined ? initialPlayerChipsBeforeHand[p.id] : STARTING_CHIPS_CONFIG; if(p.chips > 0) p.isFolded = false; else p.isFolded = true; }); actualNumPlayersInCurrentGame = initialNumPlayersForNextHandLogic; startNewHand(); } else { gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none'; initializeNewGame(); } }); } 
            else { controlButtonsArea.innerHTML = `<button id="next-hand-button">다음 핸드</button><button id="start-game-button-main-mid" style="margin-left: 10px;">새 게임</button>`; const nextHandBtn = document.getElementById('next-hand-button'); if (nextHandBtn) { nextHandBtn.disabled = (parseInt(numPlayersSelect.value) !== initialNumPlayersForNextHandLogic); nextHandBtn.title = nextHandBtn.disabled ? "다음 핸드 불가능: 이전 게임과 인원수가 다릅니다." : "다음 핸드 시작"; nextHandBtn.addEventListener('click', startNewHand); } document.getElementById('start-game-button-main-mid').addEventListener('click', () => { gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none'; initializeNewGame(); }); startingChipsInputEl.disabled = true; bigBlindInputEl.disabled = true; aiDelayInputEl.disabled = true; } 
            checkCallButton.disabled = true; betRaiseButton.disabled = true; raiseInput.disabled = true; foldButton.disabled = true;
        }

        function evaluateHoleCards(holeCards) { if (!holeCards || holeCards.length < 2) return 0; const [c1, c2] = holeCards; let score = (c1.value + c2.value) / 28; if (c1.rank === c2.rank) score += 0.35; if (c1.suit === c2.suit) score += 0.15; if (Math.abs(c1.value - c2.value) === 1 || (c1.value === RANK_VALUES.A && c2.value === RANK_VALUES["2"]) || (c2.value === RANK_VALUES.A && c1.value === RANK_VALUES["2"]) || (Math.abs(c1.value - c2.value) === 12 && (c1.value === RANK_VALUES.A || c2.value === RANK_VALUES.A))) { score += 0.1; } if (Math.abs(c1.value - c2.value) <= 4 && Math.abs(c1.value - c2.value) > 1) score += 0.05; return Math.min(1, score); }
        function evaluateDrawPotential(allCommunityCards, holeCards) { let outs = 0; let drawType = "none"; const revealedCommunityCards = allCommunityCards.filter(c => c.revealed !== false); const combinedCardsForDraw = [...holeCards, ...revealedCommunityCards]; if (combinedCardsForDraw.length < 4 || !holeCards || holeCards.length < 2) return { outs: 0, type: "none", hasFlushDraw: false, hasStraightDraw: false }; let hasFlushDraw = false; let hasStraightDraw = false; const suitCounts = {}; combinedCardsForDraw.forEach(c => suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1); for (const suit in suitCounts) { if (suitCounts[suit] === 4 && (holeCards[0].suit === suit || holeCards[1].suit === suit)) { outs += (13 - 4); drawType = drawType === "none" ? "flush" : "combo"; hasFlushDraw = true; break; } } const uniqueRanks = [...new Set(combinedCardsForDraw.map(c => c.value))].sort((a, b) => a - b); if (uniqueRanks.length >= 3) { for (let i = 0; i <= uniqueRanks.length - 4; i++) { const sub = uniqueRanks.slice(i, i + 4); if (sub[3] - sub[0] === 3) { const usesHoleCard = sub.some(r => holeCards.some(hc => hc.value === r)); if(usesHoleCard){ let tempOuts = 8; if (sub[0] === RANK_VALUES["2"]) tempOuts = 4; if (sub[3] === RANK_VALUES.A) tempOuts = 4; if (drawType === "flush" || drawType === "combo") tempOuts = Math.max(1, tempOuts - 2); outs += tempOuts; drawType = (drawType === "flush" || drawType === "combo_straight_gutshot") ? "combo_OESD_flush" : (drawType === "none" ? "straight_OESD" : "combo_OESD"); hasStraightDraw = true; break; } } } if (!hasStraightDraw && uniqueRanks.length >= 4) { for (let i = 0; i <= uniqueRanks.length - 4; i++) { const sub = uniqueRanks.slice(i, i + 4); const usesHoleCard = sub.some(r => holeCards.some(hc => hc.value === r)); if(!usesHoleCard) continue; if ((sub[3] - sub[0] === 4 && ( (sub[1]-sub[0] > 1 && sub[2]-sub[1]===1 && sub[3]-sub[2]===1) || (sub[1]-sub[0] ===1 && sub[2]-sub[1]>1 && sub[3]-sub[2]===1) || (sub[1]-sub[0] ===1 && sub[2]-sub[1]===1 && sub[3]-sub[2]>1) ))) { let tempOuts = 4; if (drawType === "flush" || drawType === "combo_OESD_flush") tempOuts = Math.max(1, tempOuts - 1); outs += tempOuts; drawType = (drawType === "flush" || drawType === "combo_OESD_flush") ? "combo_gutshot_flush" : (drawType === "none" ? "straight_gutshot" : "combo_gutshot"); hasStraightDraw = true; break;} } } const hasAce = uniqueRanks.includes(RANK_VALUES.A); const has2 = uniqueRanks.includes(RANK_VALUES["2"]); const has3 = uniqueRanks.includes(RANK_VALUES["3"]); const has4 = uniqueRanks.includes(RANK_VALUES["4"]); const has5 = uniqueRanks.includes(RANK_VALUES["5"]); if (hasAce && has2 && has3 && has4 && !has5 && (holeCards.some(hc=>[RANK_VALUES.A,2,3,4].includes(hc.value))) && !isStraightFiveHigh(uniqueRanks) && !hasStraightDraw) { outs +=4; drawType= drawType.includes("flush") ? "combo_gutshot_flush" : "straight_gutshot"; hasStraightDraw = true; } else if (has2 && has3 && has4 && has5 && !hasAce && (holeCards.some(hc=>[2,3,4,5].includes(hc.value))) && !isStraightFiveHigh(uniqueRanks) && !hasStraightDraw) { outs +=4; drawType= drawType.includes("flush") ? "combo_gutshot_flush" : "straight_gutshot"; hasStraightDraw = true; } } function isStraightFiveHigh(ranksArray) { return ranksArray.includes(RANK_VALUES.A)&&ranksArray.includes(RANK_VALUES["2"])&&ranksArray.includes(RANK_VALUES["3"])&&ranksArray.includes(RANK_VALUES["4"])&&ranksArray.includes(RANK_VALUES["5"]); } return { outs: Math.min(outs, 17), type: drawType, hasFlushDraw, hasStraightDraw }; }
        function getCombinations(arr, k) { if (k === 0) return [[]]; if (!arr || arr.length < k) return []; if (arr.length === k) return [arr]; if (k === 1) return arr.map(e => [e]); const first = arr[0]; const woFirst = getCombinations(arr.slice(1), k - 1); const wFirst = woFirst.map(c => [first, ...c]); const fRest = getCombinations(arr.slice(1), k); return [...wFirst, ...fRest]; }
        function getHandDetails(sevenCards) { if (!sevenCards || sevenCards.length < 5) { return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: [0], handName: "카드 부족", bestHand: [] };} const all5CardCombinations = getCombinations(sevenCards, 5); if (!all5CardCombinations || all5CardCombinations.length === 0) { return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: [0], handName: "조합 생성 실패", bestHand: [] };} let bestHandFound = { strength: -1, rankValues: [0], handName: "N/A", bestHand: [] }; for (const fiveCardArr of all5CardCombinations) { const currentEval = evaluateSingleHand(fiveCardArr); if (currentEval.strength > bestHandFound.strength) { bestHandFound = currentEval; } else if (currentEval.strength === bestHandFound.strength) { for (let i = 0; i < currentEval.rankValues.length; i++) { if (currentEval.rankValues[i] > bestHandFound.rankValues[i]) { bestHandFound = currentEval; break; } if (currentEval.rankValues[i] < bestHandFound.rankValues[i]) { break; }}}} return bestHandFound; }
        function evaluateSingleHand(fiveCards) { const ranks = fiveCards.map(c => c.value).sort((a, b) => b - a); const suits = fiveCards.map(c => c.suit); const isFlush = suits.every(s => s === suits[0]); const rankCounts = {}; ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1); let isStraight = false; const uniqueRanksForStraight = [...new Set(ranks)].sort((a,b) => b-a); if (uniqueRanksForStraight.length === 5 && uniqueRanksForStraight[0] - uniqueRanksForStraight[4] === 4) { isStraight = true; } let aceLowStraightRanks = null; if (uniqueRanksForStraight.length === 5 && uniqueRanksForStraight[0] === RANK_VALUES.A && uniqueRanksForStraight[1] === RANK_VALUES["5"] && uniqueRanksForStraight[2] === RANK_VALUES["4"] && uniqueRanksForStraight[3] === RANK_VALUES["3"] && uniqueRanksForStraight[4] === RANK_VALUES["2"]) { isStraight = true; aceLowStraightRanks = [RANK_VALUES["5"], RANK_VALUES["4"], RANK_VALUES["3"], RANK_VALUES["2"], RANK_VALUES.A_LOW]; } const finalRanksForComparison = aceLowStraightRanks ? aceLowStraightRanks : ranks.slice(0,5); if (isStraight && isFlush) { const isRoyal = ranks[0]===RANK_VALUES.A && ranks[1]===RANK_VALUES.K && ranks[2]===RANK_VALUES.Q && ranks[3]===RANK_VALUES.J && ranks[4]===RANK_VALUES["10"]; if(isRoyal) return { strength: HAND_STRENGTH.ROYAL_FLUSH, rankValues: ranks.slice(0,5), handName: "로열 플러쉬", bestHand: fiveCards }; return { strength: HAND_STRENGTH.STRAIGHT_FLUSH, rankValues: finalRanksForComparison, handName: "스트레이트 플러쉬", bestHand: fiveCards }; } const counts = Object.values(rankCounts); if (counts.includes(4)) { const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4)); const kicker = ranks.find(r => r !== quadRank); return { strength: HAND_STRENGTH.FOUR_OF_A_KIND, rankValues: [quadRank, kicker].filter(v=>v!==undefined), handName: "포카드", bestHand: fiveCards };} if (counts.includes(3) && counts.includes(2)) { const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3)); const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2)); return { strength: HAND_STRENGTH.FULL_HOUSE, rankValues: [tripRank, pairRank].sort((a,b)=>b-a), handName: "풀하우스", bestHand: fiveCards };} if (isFlush) { return { strength: HAND_STRENGTH.FLUSH, rankValues: ranks.slice(0,5), handName: "플러쉬", bestHand: fiveCards };} if (isStraight) { return { strength: HAND_STRENGTH.STRAIGHT, rankValues: finalRanksForComparison, handName: "스트레이트", bestHand: fiveCards };} if (counts.includes(3)) { const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3)); const kickers = ranks.filter(r => r !== tripRank).sort((a,b)=>b-a).slice(0,2); return { strength: HAND_STRENGTH.THREE_OF_A_KIND, rankValues: [tripRank, ...kickers], handName: "쓰리 오브 어 카인드", bestHand: fiveCards };} const numPairs = counts.filter(c => c === 2).length; if (numPairs === 2) { const pairRanksVal = []; for(const r in rankCounts) { if(rankCounts[r]===2) pairRanksVal.push(parseInt(r));} pairRanksVal.sort((a,b)=>b-a); const kicker = ranks.find(r=> !pairRanksVal.includes(r)); return { strength: HAND_STRENGTH.TWO_PAIR, rankValues: [...pairRanksVal, kicker].filter(v=>v!==undefined), handName: "투 페어", bestHand: fiveCards };} if (numPairs === 1) { const pairRankVal = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2)); const kickers = ranks.filter(r => r !== pairRankVal).sort((a,b)=>b-a).slice(0,3); return { strength: HAND_STRENGTH.ONE_PAIR, rankValues: [pairRankVal, ...kickers], handName: "원 페어", bestHand: fiveCards };} return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: ranks.slice(0,5), handName: "하이 카드", bestHand: fiveCards }; }

        async function determineWinner() {
            displayMessage("--- 쇼다운 ---", "game-event"); await revealAllAICards(); console.log("[DEBUG] determineWinner 시작. 현재 pot:", formatNumberWithCommas(pot), "raw pot:", pot);
            let eligiblePlayers = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && p.cards && p.cards.length > 0); console.log("[DEBUG] Eligible Players for Showdown:", eligiblePlayers.map(p => ({name: p.name, chips: formatNumberWithCommas(p.chips), betInRound: p.betInRound }) ));
            if (eligiblePlayers.length === 0) { displayMessage("쇼다운 할 플레이어가 없습니다.", "game-event"); await endCurrentHand(true); return; }
            if (eligiblePlayers.length === 1) { const soleWinner = eligiblePlayers[0]; displayMessage(`${soleWinner.name}이(가) 단독으로 남아 팟 ${formatNumberWithCommas(pot)}원 획득.`, "game-event"); soleWinner.chips = Math.max(0, soleWinner.chips + pot); pot = 0; if (soleWinner.type === 'human') showEnhancedFeedback(soleWinner.id, "승리!", "feedback-win"); updateOverallUI(); await endCurrentHand(true); return; }
            eligiblePlayers.forEach(p => { p.handDetails = getHandDetails([...p.cards, ...communityCards]); displayMessage(`${p.name}: ${p.handDetails.handName} (${p.handDetails.bestHand.map(c=>c.rank+c.suit).join(',')})`, "system-message"); });
            eligiblePlayers.sort((a, b) => { if (b.handDetails.strength !== a.handDetails.strength) return b.handDetails.strength - a.handDetails.strength; for (let i = 0; i < a.handDetails.rankValues.length; i++) { if (b.handDetails.rankValues[i] !== a.handDetails.rankValues[i]) return b.handDetails.rankValues[i] - a.handDetails.rankValues[i]; } return 0; });
            const bestHandStrength = eligiblePlayers[0].handDetails.strength; const bestHandValues = eligiblePlayers[0].handDetails.rankValues; const potentialWinners = eligiblePlayers.filter(p => p.handDetails.strength === bestHandStrength && p.handDetails.rankValues.every((val, index) => val === bestHandValues[index])); console.log("[DEBUG] Potential Winners (after sort):", potentialWinners.map(w => ({name: w.name, hand: w.handDetails.handName, chipsBefore: formatNumberWithCommas(w.chips), betInRound: w.betInRound }) ));
            let remainingPot = pot; const awardedPlayers = new Set(); 
            const sortedPlayersByBet = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded).sort((a, b) => a.betInRound - b.betInRound);
            let lastBetLevel = 0;
            for (const playerAtBetLevel of sortedPlayersByBet) {
                if (remainingPot <= 0) break; if (playerAtBetLevel.betInRound <= lastBetLevel) continue; 
                const currentBetLevelCap = playerAtBetLevel.betInRound; let sidePot = 0; let contributorsToThisSidePot = [];
                players.forEach(p => { if (currentHandActivePlayerIdsOrder.includes(p.id)) { const effectiveContribution = Math.min(p.betInRound, currentBetLevelCap); const contributionToThisPot = Math.max(0, effectiveContribution - lastBetLevel); if (contributionToThisPot > 0) { sidePot += contributionToThisPot; if (!p.isFolded) { contributorsToThisSidePot.push(p); } } } });
                if (sidePot > 0 && contributorsToThisSidePot.length > 0) { console.log(`[DEBUG] Side Pot for bet level up to ${currentBetLevelCap} (contrib from ${lastBetLevel}): ${formatNumberWithCommas(sidePot)}. Eligible winners in this pot: ${contributorsToThisSidePot.map(p=>p.name)}`); const winnersOfThisSidePot = potentialWinners.filter(pw => contributorsToThisSidePot.some(c => c.id === pw.id)); if (winnersOfThisSidePot.length > 0) { const potShare = Math.floor(sidePot / winnersOfThisSidePot.length); const oddChips = sidePot % winnersOfThisSidePot.length; console.log(`[DEBUG] Winners of this side pot: ${winnersOfThisSidePot.map(w=>w.name)}. Share: ${formatNumberWithCommas(potShare)}`); winnersOfThisSidePot.forEach((winner, index) => { const chipsBeforeWin = winner.chips; let winAmount = potShare; if (index === 0 && oddChips > 0) { winAmount += oddChips; } winner.chips = Math.max(0, winner.chips + winAmount); displayMessage(`${winner.name} 승리! 팟 ${formatNumberWithCommas(winAmount)}원 획득. (핸드: ${winner.handDetails.handName})`, "game-event"); console.log(`[DEBUG] ${winner.name} gets ${formatNumberWithCommas(winAmount)}. Chips: ${formatNumberWithCommas(chipsBeforeWin)} -> ${formatNumberWithCommas(winner.chips)}`); awardedPlayers.add(winner.id); if (winner.type === 'human') showEnhancedFeedback(winner.id, "승리!", "feedback-win"); }); remainingPot -= sidePot; } else { console.warn("[DEBUG] No winners for a side pot. Pot remains."); } }
                lastBetLevel = currentBetLevelCap;
            }
            if (remainingPot > 0) { console.warn(`[DEBUG] Pot of ${formatNumberWithCommas(remainingPot)} remaining. Awarding to first potential winner(s).`); if (potentialWinners.length > 0) { const potShareRemaining = Math.floor(remainingPot / potentialWinners.length); const oddChipsRemaining = remainingPot % potentialWinners.length; potentialWinners.forEach((winner, index) => { let winAmount = potShareRemaining; if (index === 0 && oddChipsRemaining > 0) winAmount += oddChipsRemaining; winner.chips = Math.max(0, winner.chips + winAmount); displayMessage(`${winner.name}에게 남은 팟 ${formatNumberWithCommas(winAmount)}원 추가 분배.`, "game-event"); }); remainingPot = 0; } }
            pot = 0; 
            const humanPlayer = players.find(p => p.type === 'human'); if (humanPlayer && !awardedPlayers.has(humanPlayer.id) && eligiblePlayers.some(ep => ep.id === humanPlayer.id && !ep.isFolded)) { showEnhancedFeedback(humanPlayer.id, "패배ㅠㅠ...", "feedback-lose"); }
            players.forEach(p => { if (p.chips < 0) p.chips = 0; });
            updateOverallUI(); await endCurrentHand(true);
        }

        document.addEventListener('DOMContentLoaded', () => {
            populatePokerHandExamples();
            if (sbBbDisplayAreaEl) sbBbDisplayAreaEl.textContent = `SB: ${formatNumberWithCommas(SMALL_BLIND_AMOUNT_CONFIG)} / BB: ${formatNumberWithCommas(BIG_BLIND_AMOUNT_CONFIG)}`;
            if (potDisplayBottomRightEl) potDisplayBottomRightEl.textContent = `팟: ${formatNumberWithCommas(0)}원`;
            gameTableMainEl.style.display = 'none'; actionsAreaMainEl.style.display = 'none';
            mainStartGameButton.addEventListener('click', initializeNewGame);
        });

        checkCallButton.addEventListener('click', () => handleHumanAction('CHECK_CALL'));
        betRaiseButton.addEventListener('click', () => handleHumanAction('BET_RAISE'));
        foldButton.addEventListener('click', () => handleHumanAction('FOLD'));
        pokerHandsInfoBtn.addEventListener('mouseover', () => { pokerHandsGuideDiv.style.display = 'block'; });
        pokerHandsInfoBtn.addEventListener('mouseout', () => { pokerHandsGuideDiv.style.display = 'none'; });
        document.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); if (key === KONAMI_CODE[konamiCodePosition].toLowerCase()) { konamiCodePosition++; if (konamiCodePosition === KONAMI_CODE.length) { isAdminMode = !isAdminMode; displayMessage(`사기꾼 기능 ${isAdminMode ? "활성화" : "비활성화"} 되었습니다!`, "admin-message"); konamiCodePosition = 0; if (gamePhase !== "" && gamePhase !== "SETUP") updateOverallUI(); } } else { konamiCodePosition = 0; } });
        numPlayersSelect.addEventListener('change', () => { 
            const selectedNumPlayers = parseInt(numPlayersSelect.value); 
            const nextHandButton = document.getElementById('next-hand-button'); 
            const continueButton = document.getElementById('continue-game-button'); 
            if (gamePhase === "END_HAND") { 
                if (selectedNumPlayers !== initialNumPlayersForNextHandLogic) { 
                    if (nextHandButton) { nextHandButton.disabled = true; nextHandButton.title = "다음 핸드 불가능: 이전 게임과 인원수가 다릅니다."; } 
                    if (continueButton) { continueButton.disabled = true; continueButton.title = "이어하기 불가능: 이전 게임과 인원수가 다릅니다."; } 
                } else { 
                    if (nextHandButton && players.filter(p=>p.chips > 0).length > 1) { nextHandButton.disabled = false; nextHandButton.title = "다음 핸드 시작"; } 
                    if (continueButton && players.filter(p=>p.chips > 0).length > 1) { continueButton.disabled = false; continueButton.title = "이전 칩 상태로 이어하기"; } 
                } 
            } 
        });
        for(let i=0; i<=3; i++) { const slot = getPlayerSlotElement(i); if(slot) slot.style.display = "none"; }
    </script>
</body>
</html>
