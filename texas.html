<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>텍사스 홀덤 (최종 통합본) - v7.9 Turn Order & Preflop Hand Display</title> 
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            background-color: #2c3e50;
            margin: 0;
            padding: 10px;
            color: #ecf0f1;
            height: 100vh;
            box-sizing: border-box;
            position: relative; 
        }

        .poker-hands-button {
            position: fixed; 
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background-color: #e67e22; 
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
        }

        .poker-hands-guide {
            display: none; 
            position: fixed; 
            top: 45px; 
            left: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 99;
            width: 250px; 
            font-size: 0.9em;
        }
        .poker-hands-guide h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        .poker-hands-guide ul { list-style: none; padding: 0; margin: 0; }
        .poker-hands-guide li { margin-bottom: 5px; }


        .current-hand-display {
            font-size: 0.8em;
            color: #f1c40f; 
            margin-top: 5px;
            font-weight: bold;
        }


        .game-container {
            display: flex;
            width: 100%;
            height: calc(100vh - 20px);
        }

        .main-game-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; 
        }

        .game-table {
            background-color: #006400;
            border-radius: 150px; 
            padding: 15px; 
            border: 5px solid #8B4513;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: grid; 
            grid-template-columns: 1fr 2fr 1fr; 
            grid-template-rows: auto auto auto; 
            align-items: center;
            justify-items: center;
            width: 98%;
            max-width: 900px; 
            position: relative;
            gap: 5px;
        }
        
        .ai-action-effect {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 150px; box-shadow: 0 0 30px 10px gold;
            opacity: 0; transition: opacity 0.3s ease-out;
            pointer-events: none; z-index: 10;
        }
        .ai-action-effect.active { opacity: 0.8; }

        .player-slot { 
            border: 1px solid #4a6278;
            border-radius: 10px;
            padding: 5px;
            background-color: rgba(0,0,0,0.2);
            min-width: 150px; 
            min-height: 115px; 
            text-align: center;
            position: relative; 
        }
        .player-slot.acting { box-shadow: 0 0 15px 5px gold; }
        .player-slot.folded { opacity: 0.5; background-color: rgba(100,100,100,0.3); }

        .action-text-feedback {
            position: absolute;
            top: -20px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            z-index: 20;
            pointer-events: none;
        }
        .action-text-feedback.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }


        #player-slot-0 { grid-column: 2 / 3; grid-row: 3 / 4; align-self: end; } /* 남 (플레이어) */
        #player-slot-1 { grid-column: 2 / 3; grid-row: 1 / 2; align-self: start; } /* 북 (AI 1) */
        #player-slot-2 { grid-column: 1 / 2; grid-row: 2 / 3; justify-self: start; } /* 서 (AI 2) */
        #player-slot-3 { grid-column: 3 / 4; grid-row: 2 / 3; justify-self: end; } /* 동 (AI 3) */


        .community-cards-area {
            grid-column: 2 / 3; grid-row: 2 / 3;
            text-align: center; width: 100%;
        }
        .pot-display-container { margin-top: 10px; }

        .cards-container {
            display: flex; justify-content: center;
            gap: 5px; margin-top: 5px; perspective: 1000px; 
        }
        .card {
            width: 50px; height: 75px;
            border: 1px solid #000; border-radius: 4px;
            font-size: 14px; font-weight: bold;
            background-color: white; box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            position: relative; transform-style: preserve-3d;
            transition: transform 0.6s, opacity 0.3s;
            opacity: 0; 
        }
        .card.hidden .card-front { transform: rotateY(180deg); } 
        .card.hidden .card-back { transform: rotateY(0deg); }   
        .card.is-dealt { opacity: 1; }
        .card.is-flipping .card-front { transform: rotateY(0deg); } 
        .card.is-flipping .card-back { transform: rotateY(-180deg); } 


        .card-face { 
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden; display: flex;
            flex-direction: column; justify-content: space-around;
            align-items: center; border-radius: 4px;
        }
        .card-front { background-color: white; transform: rotateY(0deg); }
        .card-back {
            background-color: #6c757d;
            background-image: repeating-linear-gradient(45deg, #5a6268, #5a6268 6px, #6c757d 6px, #6c757d 12px);
            transform: rotateY(180deg);
        }

        .card .rank { font-size: 18px; }
        .card .suit { font-size: 16px; }
        .suit-♠, .suit-♣ { color: black; }
        .suit-♥, .suit-♦ { color: red; }

        .chips-display, .pot-display, .dealer-chip-ui, .blind-chip-ui { 
            background-color: #f5f5dc; padding: 5px 10px; 
            border-radius: 15px; font-size: 13px; 
            border: 1px solid #d2b48c; margin-top: 3px;
            display: inline-block; color: #333;
        }
        .dealer-chip-ui { background-color: #FFD700; color: black; font-weight: bold; padding: 3px 6px; font-size: 9px; margin-left: 5px; }
        .blind-chip-ui { background-color: #7f8c8d; color: white; font-weight: bold; padding: 3px 6px; font-size: 9px; margin-left: 3px;}


        .player-name-display {
            font-weight: bold; color: white; margin-bottom: 3px;
        }
        
        .actions-area {
            grid-column: 1 / 4; grid-row: 4 / 5;  
            margin: 10px 0; display: flex;
            gap: 8px; flex-wrap: wrap; justify-content: center;
        }
        .actions-area button, .game-controls button {
            padding: 8px 12px; font-size: 14px; cursor: pointer;
            background-color: #4CAF50; color: white;
            border: none; border-radius: 5px;
            transition: background-color 0.3s;
        }
        .actions-area button:hover, .game-controls button:hover { background-color: #45a049; }
        .actions-area button:disabled { background-color: #7f8c8d; cursor: not-allowed; }
        #raise-input {
            padding: 8px; font-size: 14px; width: 80px;
            border-radius: 5px; border: 1px solid #ccc;
        }
        
        .bet-amount-display { 
            background-color: rgba(0,0,0,0.7); color: white;
            padding: 2px 6px; border-radius: 5px;
            font-size: 11px; margin-top: 3px; display: inline-block;
        }

        .chat-area {
            width: 300px; height: calc(100vh - 40px);
            background-color: #34495e; padding: 10px;
            margin-left: 10px; border-radius: 8px;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            display: flex; flex-direction: column;
            box-sizing: border-box;
        }
        .chat-area h3 {
            margin-top: 0; color: #ecf0f1; text-align: center;
            border-bottom: 1px solid #7f8c8d; padding-bottom: 5px;
        }
        .message-log {
            flex-grow: 1; overflow-y: auto;
            font-size: 0.9em; line-height: 1.4;
        }
        .message-log p { margin: 5px 0; padding: 3px; border-bottom: 1px dashed #4a6278; }
        .message-log p:last-child { border-bottom: none; }
        .message-log .player-action { color: #2ecc71; }
        .message-log .ai-action { color: #e74c3c; }
        .message-log .game-event { color: #f1c40f; }
        .message-log .system-message { color: #bdc3c7; }
         .admin-message { color: #e67e22; font-weight: bold;} 


        .game-controls {
            display: flex; flex-direction: column; 
            align-items: center; gap: 10px;
            margin-top: 10px; padding: 10px;
        }
        .player-setup {
            display: flex; gap: 10px; align-items: center; margin-bottom:10px;
        }
        .end-game-buttons {
            display: flex; 
            gap: 10px;
        }
        .end-game-buttons button#continue-game-button {
            background-color: #3498db; 
        }
        .end-game-buttons button#start-game-button-main { 
             background-color: #27ae60;
        }
    </style>
</head>
<body>
    <button class="poker-hands-button" id="poker-hands-info-btn">포커 족보</button>
    <div class="poker-hands-guide" id="poker-hands-guide-div">
        <h4>포커 족보 (높은 순)</h4>
        <ul>
            <li><b>로열 플러쉬</b> (Royal Flush): 같은 무늬 A-K-Q-J-10</li>
            <li><b>스트레이트 플러쉬</b> (Straight Flush): 같은 무늬 연속 숫자</li>
            <li><b>포카드</b> (Four of a Kind): 같은 숫자 4장</li>
            <li><b>풀하우스</b> (Full House): 트리플 + 원 페어</li>
            <li><b>플러쉬</b> (Flush): 같은 무늬 5장</li>
            <li><b>스트레이트</b> (Straight): 연속된 숫자 5장</li>
            <li><b>트리플</b> (Three of a Kind): 같은 숫자 3장</li>
            <li><b>투 페어</b> (Two Pair): 페어 2쌍</li>
            <li><b>원 페어</b> (One Pair): 페어 1쌍</li>
            <li><b>하이 카드</b> (High Card): 위 족보에 해당 없을 시 가장 높은 카드</li>
        </ul>
    </div>

    <div class="game-container">
        <div class="main-game-area">
            <div class="game-table">
                <div id="ai-action-effect-indicator" class="ai-action-effect"></div>
                
                <div id="player-slot-1" class="player-slot" style="display:none;"></div> 
                <div id="player-slot-2" class="player-slot" style="display:none;"></div> 
                <div id="player-slot-3" class="player-slot" style="display:none;"></div> 

                <div class="community-cards-area">
                    <h2>커뮤니티 카드</h2>
                    <div id="community-cards" class="cards-container"></div>
                    <div class="pot-display-container">
                        <div id="pot" class="pot-display">팟: 0원</div>
                    </div>
                </div>
                
                <div id="player-slot-0" class="player-slot"></div> 

                <div class="actions-area">
                    <button id="check-call-button">체크</button>
                    <button id="bet-raise-button">벳</button>
                    <input type="number" id="raise-input" value="0" min="0">
                    <button id="fold-button">폴드</button>
                </div>
            </div>
            <div class="game-controls">
                <div class="player-setup">
                    <label for="num-players-select">참가 인원 (AI 포함):</label>
                    <select id="num-players-select">
                        <option value="2" selected>2명</option>
                        <option value="3">3명</option>
                        <option value="4">4명</option>
                    </select>
                </div>
                <div id="control-buttons-area" class="end-game-buttons"> 
                    <button id="start-game-button-main">새 게임</button> 
                </div>
            </div>
        </div>

        <div class="chat-area">
            <h3>게임 로그</h3>
            <div id="message-log" class="message-log">
                <p class="system-message">텍사스 홀덤 게임에 오신 것을 환영합니다!</p>
            </div>
        </div>
    </div>

    <script>
        // --- Constants ---
        const SUITS = ["♠", "♥", "♦", "♣"];
        const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
        const RANK_VALUES = { 
            "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, 
            "J": 11, "Q": 12, "K": 13, "A": 14, "A_LOW": 1 
        };
        const HAND_STRENGTH = { HIGH_CARD: 0, ONE_PAIR: 1, TWO_PAIR: 2, THREE_OF_A_KIND: 3, STRAIGHT: 4, FLUSH: 5, FULL_HOUSE: 6, FOUR_OF_A_KIND: 7, STRAIGHT_FLUSH: 8, ROYAL_FLUSH: 9 };
        const STARTING_CHIPS = 1000;
        const SMALL_BLIND_AMOUNT = 10;
        const BIG_BLIND_AMOUNT = 20;
        const BLUFF_PROBABILITY_BASE = 0.09; 
        const KONAMI_CODE = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];

        // Player ID mapping to visual slots: 0: South (Player), 1: North (AI1), 2: West (AI2), 3: East (AI3)
        // Desired visual counter-clockwise turn order:
        // 4 players: North (1) -> West (2) -> South (0) -> East (3)
        // 3 players (P, AI1, AI2): North (1) -> West (2) -> South (0)
        // 2 players (P, AI1): North (1) -> South (0)  (if AI1 is dealer/SB) OR South(0) -> North(1) (if Player is dealer/SB)

        const VISUAL_ORDER_RULES = {
            4: [1, 2, 0, 3], // North, West, South, East
            3: [1, 2, 0],    // North, West, South (assuming AI3 is not in play)
            2: [1, 0]     // North, South (Default, dealer logic will adjust for 2 players)
        };


        // --- Game State Variables ---
        let deck = [];
        let communityCards = [];
        let players = []; 
        let pot = 0;
        let currentBet = 0; 
        let minRaiseAmount = BIG_BLIND_AMOUNT; 
        
        let gamePhase = ""; 
        let currentPlayerIndex = -1; // Index in the main `players` array
        let dealerIndex = -1; // Index in the main `players` array for the dealer
        
        let currentHandActivePlayerIdsOrder = []; // Stores IDs of active players in visual turn order for current hand
        let currentTurnInOrderIndex = -1; // Index in `currentHandActivePlayerIdsOrder`

        let lastRaiserIndex = -1; // Index in the main `players` array
        let actualNumPlayersInCurrentGame = 0; 
        let isAdminMode = false; 
        let konamiCodePosition = 0;


        // --- UI Elements ---
        const communityCardsDiv = document.getElementById('community-cards');
        const potDiv = document.getElementById('pot');
        const messageLogDiv = document.getElementById('message-log');
        const checkCallButton = document.getElementById('check-call-button');
        const betRaiseButton = document.getElementById('bet-raise-button');
        const raiseInput = document.getElementById('raise-input');
        const foldButton = document.getElementById('fold-button');
        const mainStartGameButton = document.getElementById('start-game-button-main'); 
        const controlButtonsArea = document.getElementById('control-buttons-area');
        const numPlayersSelect = document.getElementById('num-players-select');
        const aiActionEffectIndicator = document.getElementById('ai-action-effect-indicator');
        const pokerHandsInfoBtn = document.getElementById('poker-hands-info-btn');
        const pokerHandsGuideDiv = document.getElementById('poker-hands-guide-div');


        // --- Utility Functions ---
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        function showAIActionEffect() {
            aiActionEffectIndicator.classList.add('active');
            setTimeout(() => aiActionEffectIndicator.classList.remove('active'), 700);
        }
        function getPlayerSlotElement(playerIndex) {
            return document.getElementById(`player-slot-${playerIndex}`);
        }

        // Generates the order of active player IDs for the current hand, starting from SB post-dealer.
        // This order respects the visual counter-clockwise flow.
        function getActivePlayerOrderForHand(dealerPlayerId, allPlayersList, numActivePlayersTotal) {
            const baseOrder = VISUAL_ORDER_RULES[numActivePlayersTotal] || Object.keys(allPlayersList).map(Number).sort((a,b)=>a-b);
            
            let orderedPlayerIds = [];
            let startIndexInBase = baseOrder.indexOf(dealerPlayerId);

            if (startIndexInBase === -1 && numActivePlayersTotal > 0) { // Dealer might not be in VISUAL_ORDER_RULES if fewer players
                // Fallback: find dealer and start from there, assuming players array is somewhat ordered.
                // This part needs robust handling if dealer ID isn't in the predefined visual order.
                // For now, assume dealerId will be part of the logic derived from VISUAL_ORDER_RULES.
                // A simple approach for <4 players is to filter VISUAL_ORDER_RULES[4]
                let currentVisualOrder = [...VISUAL_ORDER_RULES[4]];
                currentVisualOrder = currentVisualOrder.filter(id => allPlayersList.find(p=>p.id === id && !p.isFolded && (p.chips > 0 || p.isAllIn)));
                
                // If numActivePlayersTotal is less than 4, we need to adjust baseOrder.
                // This example uses the first N players from the full visual order who are active.
                // A more robust solution would map active players to visual slots.
                if (numActivePlayersTotal < 4 && numActivePlayersTotal > 0) {
                    const activeIdsInGame = allPlayersList.filter(p => (p.chips > 0 || p.isAllIn) && !p.isFolded).map(p => p.id);
                    const specificVisualOrder = VISUAL_ORDER_RULES[numActivePlayersTotal] ? [...VISUAL_ORDER_RULES[numActivePlayersTotal]] : [];
                    // Filter specificVisualOrder to only include active players for THIS game.
                    const filteredBaseOrder = specificVisualOrder.filter(id => activeIdsInGame.includes(id));
                     if (filteredBaseOrder.length === numActivePlayersTotal) {
                        startIndexInBase = filteredBaseOrder.indexOf(dealerPlayerId);
                         if (startIndexInBase !== -1) {
                            for (let i = 0; i < numActivePlayersTotal; i++) {
                                const playerOrderIndex = (startIndexInBase + 1 + i) % numActivePlayersTotal;
                                const playerId = filteredBaseOrder[playerOrderIndex];
                                const playerObj = allPlayersList.find(p => p.id === playerId);
                                if (playerObj && !playerObj.isFolded && (playerObj.chips > 0 || playerObj.isAllIn)) {
                                    orderedPlayerIds.push(playerId);
                                }
                            }
                            return orderedPlayerIds;
                        }
                     }
                }
                 // Fallback if dealer not in predefined order or mismatch in player counts
                console.warn("Dealer ID not in base visual order or player count mismatch. Falling back to simple +1 logic for active player order generation.");
                let currentIdx = allPlayersList.findIndex(p => p.id === dealerPlayerId);
                for (let i = 0; i < allPlayersList.length; i++) {
                    currentIdx = (currentIdx + 1) % allPlayersList.length;
                    const playerObj = allPlayersList[currentIdx];
                     if (playerObj && !playerObj.isFolded && (playerObj.chips > 0 || playerObj.isAllIn)) {
                        orderedPlayerIds.push(playerObj.id);
                    }
                }
                return orderedPlayerIds.filter(id => allPlayersList.find(p=>p.id === id && !p.isFolded && (p.chips>0 || p.isAllIn))).slice(0, numActivePlayersTotal);
            }


            // Standard case using VISUAL_ORDER_RULES
            for (let i = 0; i < numActivePlayersTotal; i++) {
                const playerOrderIndex = (startIndexInBase + 1 + i) % numActivePlayersTotal; // +1 because order starts AFTER dealer (for SB)
                const playerId = baseOrder[playerOrderIndex];
                const playerObj = allPlayersList.find(p => p.id === playerId);
                 // Ensure player is actually in the game and active
                if (playerObj && !playerObj.isFolded && (playerObj.chips > 0 || playerObj.isAllIn) && allPlayersList.map(p=>p.id).includes(playerId) ) {
                    orderedPlayerIds.push(playerId);
                }
            }
            // Final filter to ensure only active players relevant to the current hand are included
             return orderedPlayerIds.filter(id => {
                const p = allPlayersList.find(player => player.id === id);
                return p && !p.isFolded && (p.chips > 0 || p.isAllIn);
            });
        }


         function getPlayerPositionCategory(player, dealerPlayerId, numActivePlayersInHandForPos, currentHandOrder) {
            if (numActivePlayersInHandForPos <= 1) return "OnlyPlayer";
            
            const playerActualOrder = currentHandOrder || getActivePlayerOrderForHand(dealerPlayerId, players, players.filter(p=>!p.isFolded && (p.chips>0 || p.isAllIn)).length);
            const playerIndexInOrder = playerActualOrder.indexOf(player.id);

            if (playerIndexInOrder === -1) return "PositionError_NotFoundInOrder";

            if (numActivePlayersInHandForPos === 2) { // Heads Up
                return player.isSB ? "SB_Dealer" : "BB_Opponent"; // SB is always dealer in HU
            }

            // Order is [SB, BB, UTG, ..., Dealer] if dealer is last in this conceptual array
            // Or [SB, BB, ..., Cutoff, Dealer]
            if (playerIndexInOrder === 0) return "SB";
            if (playerIndexInOrder === 1) return "BB";
            
            // Relative to BB
            const bbPlayer = players.find(p => p.isBB);
            let bbIndexInOrder = bbPlayer ? playerActualOrder.indexOf(bbPlayer.id) : 1; // Default to 1 if not found

            if (playerIndexInOrder === (bbIndexInOrder + 1) % numActivePlayersInHandForPos) return "UTG";
            
            if (player.id === dealerPlayerId) return "Dealer"; // Dealer is always "Dealer"
            
            // Calculate position from the end of the order (relative to dealer)
            // If dealer is at playerActualOrder[numActivePlayersInHandForPos -1]
            const dealerIndexInActualOrder = playerActualOrder.indexOf(dealerPlayerId);
            if (dealerIndexInActualOrder !== -1) {
                 if (playerIndexInOrder === (dealerIndexInActualOrder - 1 + numActivePlayersInHandForPos) % numActivePlayersInHandForPos) return "CutOff";
            }


            if (numActivePlayersInHandForPos <= 6) { 
                 if (playerIndexInOrder < Math.floor(numActivePlayersInHandForPos / 2) && playerIndexInOrder > 1) return "Early"; // After BB, before middle
                 else if (playerIndexInOrder >= Math.floor(numActivePlayersInHandForPos / 2) && player.id !== dealerPlayerId && playerActualOrder.indexOf(dealerPlayerId) !== playerIndexInOrder -1 ) return "Late"; 
            } else { 
                 if (playerIndexInOrder < numActivePlayersInHandForPos / 3 && playerIndexInOrder > 1) return "Early";
                 if (playerIndexInOrder < (numActivePlayersInHandForPos * 2) / 3  && playerIndexInOrder > 1) return "Middle";
                 if (player.id !== dealerPlayerId && playerActualOrder.indexOf(dealerPlayerId) !== playerIndexInOrder -1 ) return "Late";
            }
            return "Middle"; // Fallback
        }

        function calculatePotOdds(amountToCall, currentPotTotal) {
            if (amountToCall <= 0) return 1; 
            return amountToCall / (currentPotTotal + amountToCall);
        }
        function analyzeBoardTexture(communityCards) {
            if (!communityCards || communityCards.length < 3) return { type: "preflop", isWet: false, isPaired: false, flushDraws: 0, straightDraws: 0, highCardValue:0 };

            let texture = { type: "unknown", isWet: false, isPaired: false, flushDraws: 0, straightDraws: 0, highCardValue:0 };
            const ranks = communityCards.map(c => c.value).sort((a,b)=>b-a);
            const suits = communityCards.map(c => c.suit);

            texture.highCardValue = ranks[0] || 0;

            const rankCounts = {};
            ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            if (Object.values(rankCounts).some(count => count >= 2)) texture.isPaired = true;
            if (Object.values(rankCounts).some(count => count >= 3)) { texture.isPaired = true; texture.isWet = true; }

            const suitCounts = {};
            suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            Object.values(suitCounts).forEach(count => {
                if (count === 2 && communityCards.length === 3) texture.flushDraws = 1; 
                if (count >= 3) {texture.flushDraws = Math.max(texture.flushDraws, count); texture.isWet = true;}
            });
            
            const uniqueSortedRanks = [...new Set(ranks)].sort((a,b)=>a-b); 
            if (uniqueSortedRanks.length >= 3) {
                for (let i = 0; i <= uniqueSortedRanks.length - 3; i++) {
                    if (uniqueSortedRanks[i+2] - uniqueSortedRanks[i] <= 4) { 
                        texture.straightDraws++;
                        texture.isWet = true;
                    }
                }
                if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(2) && uniqueSortedRanks.includes(3)) texture.straightDraws++; // A23xx
                if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(2) && uniqueSortedRanks.includes(4) && !uniqueSortedRanks.includes(3)) texture.straightDraws++; // A2x4x (gutshot with A)
                if (uniqueSortedRanks.includes(RANK_VALUES.A) && uniqueSortedRanks.includes(3) && uniqueSortedRanks.includes(4) && !uniqueSortedRanks.includes(2)) texture.straightDraws++; // Ax34x
            }
            if (texture.straightDraws > 1 || (texture.straightDraws > 0 && texture.flushDraws >=3 )) texture.isWet = true;

            if (!texture.isWet && !texture.isPaired && texture.highCardValue < RANK_VALUES.J && ranks.length >=3 && (ranks[0] - ranks[ranks.length-1] > 5)) {
                 texture.type = "dry_uncoordinated";
            } else if (texture.isWet) {
                texture.type = "wet_drawy";
            } else if (texture.isPaired) {
                texture.type = "paired";
            } else {
                texture.type = "semi_coordinated";
            }
            return texture;
        }
        function showPlayerActionFeedback(playerId, actionText) {
            const playerSlot = getPlayerSlotElement(playerId);
            if (!playerSlot) return;

            let feedbackDiv = playerSlot.querySelector('.action-text-feedback');
            if (!feedbackDiv) {
                feedbackDiv = document.createElement('div');
                feedbackDiv.classList.add('action-text-feedback');
                playerSlot.appendChild(feedbackDiv);
            }
            feedbackDiv.textContent = actionText.toUpperCase();
            feedbackDiv.classList.add('show');
            setTimeout(() => {
                feedbackDiv.classList.remove('show');
            }, 1500); 
        }


        // --- Card Functions ---
        function createDeck() {
            deck = [];
            for (let suit of SUITS) {
                for (let rank of RANKS) {
                    deck.push({ suit, rank, value: RANK_VALUES[rank], id: rank+suit+Date.now()+Math.random() });
                }
            }
        }
        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }
        function dealCardFromDeck(hiddenInitially = false) { 
            if (deck.length > 0) {
                const card = deck.pop();
                card.hidden = hiddenInitially; 
                card.revealed = !hiddenInitially; 
                return card;
            }
            return null; 
        }
        function burnCard() { if (deck.length > 0) deck.pop(); }
        
        // --- UI Update Functions ---
        function createPlayerSlotUI(player) {
            const slotDiv = getPlayerSlotElement(player.id);
            if (!slotDiv) { console.error(`Slot DIV for player ${player.id} not found`); return; }
            
            slotDiv.innerHTML = `
                <div class="player-name-display">
                    ${player.name} 
                    <span id="dealer-chip-${player.id}" class="dealer-chip-ui" style="display:none;">D</span>
                    <span id="sb-chip-${player.id}" class="blind-chip-ui" style="display:none;">SB</span>
                    <span id="bb-chip-${player.id}" class="blind-chip-ui" style="display:none;">BB</span>
                </div>
                <div id="cards-player-${player.id}" class="cards-container"></div>
                <div id="chips-player-${player.id}" class="chips-display">칩: ${Math.floor(player.chips)}원</div>
                <div id="bet-player-${player.id}" class="bet-amount-display" style="display:none;"></div>
                <div id="current-hand-player-${player.id}" class="current-hand-display"></div>
                <div class="action-text-feedback"></div> 
            `;
            slotDiv.style.display = "block"; 
        }

        function renderPlayerCard(player, cardData, hiddenInitially = false) {
            const cardsContainer = document.getElementById(`cards-player-${player.id}`);
            if (!cardsContainer) return;
            
            let cardIsActuallyHiddenForRender = hiddenInitially;
            if (isAdminMode && player.type === 'ai') {
                cardIsActuallyHiddenForRender = false; 
            }

            const cardElement = renderSingleCard(cardData, false, cardIsActuallyHiddenForRender); 
            cardsContainer.appendChild(cardElement);
            return cardElement; 
        }

        function renderSingleCard(card, isCommunity = false, hiddenInitially = false) { 
            const cardDiv = document.createElement('div');
            cardDiv.classList.add('card');
            cardDiv.dataset.cardId = card.id; 

            const cardFaceFront = document.createElement('div');
            cardFaceFront.classList.add('card-face', 'card-front');
            const rankDiv = document.createElement('span');
            rankDiv.classList.add('rank');
            rankDiv.textContent = card.rank;
            const suitDiv = document.createElement('span');
            suitDiv.classList.add('suit', `suit-${card.suit}`);
            suitDiv.innerHTML = card.suit; 
            cardFaceFront.appendChild(rankDiv);
            cardFaceFront.appendChild(suitDiv);
            cardFaceFront.style.color = (card.suit === "♥" || card.suit === "♦") ? "red" : "black";

            const cardFaceBack = document.createElement('div');
            cardFaceBack.classList.add('card-face', 'card-back');

            cardDiv.appendChild(cardFaceFront);
            cardDiv.appendChild(cardFaceBack);

            if (hiddenInitially) { 
                cardDiv.classList.add('hidden');
            }
            
            let delay = 0;
            if (isCommunity) delay = communityCardsDiv.children.length * 150;

            setTimeout(() => {
                cardDiv.classList.add('is-dealt');
                 if (!hiddenInitially) { 
                     setTimeout(() => {
                        if (!cardDiv.classList.contains('hidden')) { 
                            cardDiv.classList.add('is-flipping');
                        }
                    }, 50 + delay + (isCommunity ? 100 : 0) );
                 }
            }, 50 + delay);
            return cardDiv;
        }
        
        async function dealAnimatedCommunityCard(cardData) {
            communityCards.push(cardData); 
            const cardElement = renderSingleCard(cardData, true, false); 
            communityCardsDiv.appendChild(cardElement);
            await sleep(200); 
        }

        function revealHiddenCard(player, cardObj) { 
            const cardElement = document.querySelector(`#cards-player-${player.id} .card[data-card-id="${cardObj.id}"]`);
            if (cardElement && cardElement.classList.contains('hidden')) {
                cardElement.classList.remove('hidden');
                cardElement.classList.add('is-flipping');
            }
            if(player.type === 'ai') {
                const gameCard = player.cards.find(c => c.id === cardObj.id);
                if(gameCard) {
                    gameCard.hidden = false;
                    gameCard.revealed = true;
                }
            }
        }


        function updateOverallUI() {
            players.forEach(p => {
                const slotDiv = getPlayerSlotElement(p.id);
                if (!slotDiv) return;

                document.getElementById(`chips-player-${p.id}`).textContent = `칩: ${Math.floor(p.chips)}원`;
                const betDiv = document.getElementById(`bet-player-${p.id}`);
                if (p.betInRound > 0) {
                    betDiv.textContent = `벳: ${Math.floor(p.betInRound)}원`;
                    betDiv.style.display = 'inline-block';
                } else {
                    betDiv.style.display = 'none';
                }
                document.getElementById(`dealer-chip-${p.id}`).style.display = p.isDealer ? 'inline-block' : 'none';
                document.getElementById(`sb-chip-${p.id}`).style.display = p.isSB ? 'inline-block' : 'none';
                document.getElementById(`bb-chip-${p.id}`).style.display = p.isBB ? 'inline-block' : 'none';
                
                const currentHandDiv = document.getElementById(`current-hand-player-${p.id}`);
                if (currentHandDiv && p.type === "human" && p.cards.length >= 2 && !p.isFolded) {
                    if (communityCards.length >= 3) {
                        const handDetails = getHandDetails([...p.cards, ...communityCards]);
                        currentHandDiv.textContent = `현재 최고패: ${handDetails.handName}`;
                    } else if (p.cards.length === 2) { // Preflop or Flop not dealt yet
                        let preflopHandName = "";
                        const card1 = p.cards[0];
                        const card2 = p.cards[1];
                        if (card1.value === card2.value) {
                            preflopHandName = `${card1.rank} 페어`;
                        } else {
                            const highRankValue = Math.max(card1.value, card2.value);
                            const lowRankValue = Math.min(card1.value, card2.value);
                            // Find rank names from RANKS array using RANK_VALUES
                            const highRankName = Object.keys(RANK_VALUES).find(key => RANK_VALUES[key] === highRankValue && key !== "A_LOW");
                            const lowRankName = Object.keys(RANK_VALUES).find(key => RANK_VALUES[key] === lowRankValue && key !== "A_LOW");
                            preflopHandName = `${highRankName || card1.rank}${lowRankName || card2.rank}`;
                            if (card1.suit === card2.suit) {
                                preflopHandName += "s"; // s for suited
                            } else {
                                preflopHandName += "o"; // o for offsuit
                            }
                             preflopHandName += ` (하이: ${highRankName || card1.rank})`;
                        }
                        currentHandDiv.textContent = `손패: ${preflopHandName}`;
                    }
                } else if (currentHandDiv) {
                    currentHandDiv.textContent = ""; 
                }


                slotDiv.classList.remove('acting', 'folded');
                const currentPlayerObject = players[currentPlayerIndex];
                if (currentPlayerObject && p.id === currentPlayerObject.id && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND" && !p.isFolded && !p.isAllIn) {
                    slotDiv.classList.add('acting');
                }
                if (p.isFolded) slotDiv.classList.add('folded');

                if (isAdminMode && p.type === 'ai' && !p.isFolded) {
                    p.cards.forEach(cardData => {
                        const cardElement = document.querySelector(`#cards-player-${p.id} .card[data-card-id="${cardData.id}"]`);
                        if (cardElement && cardElement.classList.contains('hidden')) {
                            cardElement.classList.remove('hidden');
                            if (!cardElement.classList.contains('is-flipping') && !cardElement.classList.contains('is-dealt')) {
                                setTimeout(() => cardElement.classList.add('is-dealt'), 50);
                                setTimeout(() => cardElement.classList.add('is-flipping'), 150);
                            } else if (!cardElement.classList.contains('is-flipping')) {
                                 cardElement.classList.add('is-flipping'); 
                            }
                        }
                        cardData.hidden = false; 
                        cardData.revealed = true;
                    });
                }
            });

            potDiv.textContent = `팟: ${Math.floor(pot)}원`;
            updateActionButtonsForHuman();
        }

        function updateActionButtonsForHuman() {
            const humanPlayer = players.find(p => p.type === "human");
            if (!humanPlayer) { 
                checkCallButton.disabled = true; betRaiseButton.disabled = true;
                raiseInput.disabled = true; foldButton.disabled = true;
                return;
            }
            const currentPlayerObject = players[currentPlayerIndex];
            const isHumanTurn = currentPlayerObject && humanPlayer.id === currentPlayerObject.id && !humanPlayer.isFolded && !humanPlayer.isAllIn && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND";
            
            checkCallButton.disabled = !isHumanTurn;
            betRaiseButton.disabled = !isHumanTurn;
            raiseInput.disabled = !isHumanTurn;
            foldButton.disabled = !isHumanTurn;

            if (isHumanTurn) {
                const amountToCall = currentBet - humanPlayer.betInRound;
                if (amountToCall > 0) { 
                    checkCallButton.textContent = `콜 (${Math.floor(Math.min(amountToCall, humanPlayer.chips))}원)`;
                    betRaiseButton.textContent = "레이즈";
                } else { 
                    checkCallButton.textContent = "체크";
                    betRaiseButton.textContent = "벳";
                }
                
                let minNewTotalBet = currentBet + minRaiseAmount; 
                if (currentBet === 0) minNewTotalBet = minRaiseAmount; 
                
                minNewTotalBet = Math.max(minNewTotalBet, humanPlayer.betInRound + (currentBet > 0 ? minRaiseAmount : SMALL_BLIND_AMOUNT));

                raiseInput.min = Math.floor(Math.min(humanPlayer.chips + humanPlayer.betInRound, minNewTotalBet)); 
                raiseInput.value = Math.floor(Math.min(humanPlayer.chips + humanPlayer.betInRound, minNewTotalBet)); 
                raiseInput.max = Math.floor(humanPlayer.chips + humanPlayer.betInRound); 
            } else {
                checkCallButton.textContent = "체크"; 
                betRaiseButton.textContent = "벳";   
            }
        }

        function displayMessage(msg, type = "system-message") {
            const p = document.createElement('p');
            p.classList.add(type);
            p.innerHTML = msg; 
            messageLogDiv.appendChild(p);
            messageLogDiv.scrollTop = messageLogDiv.scrollHeight;
        }

        // --- Game Initialization and Hand Cycling ---
        async function initializeNewGame() {
            actualNumPlayersInCurrentGame = parseInt(numPlayersSelect.value); 
            players = [];
            // Player 0 is human (South)
            // AI 1 is North, AI 2 is West, AI 3 is East
            // This fixed ID assignment is important for VISUAL_ORDER_RULES
            for (let i = 0; i < actualNumPlayersInCurrentGame; i++) {
                players.push({
                    id: i, name: i === 0 ? "플레이어" : `AI ${i}`, type: i === 0 ? "human" : "ai",
                    chips: STARTING_CHIPS, cards: [], betInRound: 0, isFolded: false, isAllIn: false,
                    isDealer: false, isSB: false, isBB: false,
                    handDetails: null, hasActedThisBettingRound: false, 
                    positionCategory: "Unknown", 
                    previousAction: null, 
                    aggressionFactor: Math.random() * 0.5 + 0.75, 
                    tightnessFactor: Math.random() * 0.5 + 0.75,  
                });
                createPlayerSlotUI(players[i]); 
            }
            
            for (let i = actualNumPlayersInCurrentGame; i <= 3; i++) { 
                 const slot = getPlayerSlotElement(i);
                 if(slot) slot.style.display = "none";
            }

            dealerIndex = Math.floor(Math.random() * actualNumPlayersInCurrentGame); // Initial dealer index in `players` array
            
            controlButtonsArea.innerHTML = `<button id="start-game-button-main">새 게임</button>`; 
            document.getElementById('start-game-button-main').addEventListener('click', initializeNewGame);

            numPlayersSelect.disabled = false; 
            await startNewHand();
        }
        
        async function startNewHand() { 
            controlButtonsArea.innerHTML = `<button id="start-game-button-main" style="display:none;">새 게임</button>`; 
            document.getElementById('start-game-button-main').addEventListener('click', initializeNewGame);

            numPlayersSelect.disabled = true; 

            if (players.length === 0) {
                await initializeNewGame(); 
                return;
            }

            const activePlayersWithChips = players.filter(p => p.chips > 0);
            if (activePlayersWithChips.length <= 1 && players.length > 0) { 
                await endCurrentHand(false); 
                return;
            }
            
            gamePhase = "SETUP";
            createDeck();
            shuffleDeck();
            communityCards = [];
            communityCardsDiv.innerHTML = '';
            pot = 0;
            currentBet = 0;
            minRaiseAmount = BIG_BLIND_AMOUNT;
            lastRaiserIndex = -1; // Store original players array index
            currentHandActivePlayerIdsOrder = [];
            currentTurnInOrderIndex = -1;


            players.forEach(p => { 
                p.cards = [];
                p.betInRound = 0;
                if (p.chips <= 0) p.isFolded = true; else p.isFolded = false; 
                p.isAllIn = (p.chips === 0 && !p.isFolded); 
                p.isDealer = false; p.isSB = false; p.isBB = false;
                p.handDetails = null; p.hasActedThisBettingRound = false;
                p.previousAction = null; 
                const cardsDiv = document.getElementById(`cards-player-${p.id}`);
                if (cardsDiv) cardsDiv.innerHTML = '';
                 const currentHandDiv = document.getElementById(`current-hand-player-${p.id}`);
                if(currentHandDiv) currentHandDiv.textContent = "";
            });

            // --- MODIFIED DEALER SELECTION & ACTION ORDER ---
            let currentDealerPlayerId;
            if (dealerIndex === -1 || !players[dealerIndex] || players[dealerIndex].chips <= 0) { // First hand or previous dealer busted
                 dealerIndex = Math.floor(Math.random() * actualNumPlayersInCurrentGame);
                 while(players[dealerIndex].chips <= 0 || players[dealerIndex].isFolded) { // Ensure dealer has chips
                    dealerIndex = (dealerIndex + 1) % actualNumPlayersInCurrentGame;
                 }
            } else { // Move dealer button
                const initialDealerIdForSearch = players[dealerIndex].id;
                let nextDealerIdCand = initialDealerIdForSearch;
                let searchCount = 0;
                const baseOrderForDealerMove = VISUAL_ORDER_RULES[actualNumPlayersInCurrentGame] || players.map(p=>p.id).sort((a,b)=>a-b);
                let currentDealerPosInBase = baseOrderForDealerMove.indexOf(initialDealerIdForSearch);
                if(currentDealerPosInBase === -1) currentDealerPosInBase = 0; // Fallback

                do {
                    currentDealerPosInBase = (currentDealerPosInBase + 1) % baseOrderForDealerMove.length;
                    nextDealerIdCand = baseOrderForDealerMove[currentDealerPosInBase];
                    const pCand = players.find(p=>p.id === nextDealerIdCand);
                    if (pCand && pCand.chips > 0 && !pCand.isFolded) {
                        dealerIndex = players.findIndex(p => p.id === nextDealerIdCand);
                        break;
                    }
                    searchCount++;
                } while (searchCount < baseOrderForDealerMove.length * 2);
                if(searchCount >= baseOrderForDealerMove.length * 2){ // Fallback if visual order fails
                    dealerIndex = (dealerIndex + 1) % players.length;
                     while(players[dealerIndex].chips <= 0 || players[dealerIndex].isFolded) {
                        dealerIndex = (dealerIndex + 1) % players.length;
                    }
                }
            }
            players[dealerIndex].isDealer = true;
            currentDealerPlayerId = players[dealerIndex].id;
            displayMessage(`${players[dealerIndex].name}가 딜러입니다.`, "game-event");
            
            // Generate the order of active player IDs for this hand based on visual flow
            // This order starts from SB.
            let tempActivePlayersForOrder = players.filter(p => !p.isFolded && (p.chips > 0 || p.isAllIn));
            currentHandActivePlayerIdsOrder = getActivePlayerOrderForHand(currentDealerPlayerId, players, tempActivePlayersForOrder.length);
            
            if (currentHandActivePlayerIdsOrder.length === 0 && tempActivePlayersForOrder.length > 0) { // Fallback if getActivePlayerOrderForHand fails
                 console.warn("getActivePlayerOrderForHand returned empty, using fallback simple order for blinds.");
                 let startIdx = players.findIndex(p => p.id === currentDealerPlayerId);
                 for(let i=0; i < players.length; i++){
                     startIdx = (startIdx + 1) % players.length;
                     if(players[startIdx] && !players[startIdx].isFolded && (players[startIdx].chips > 0 || players[startIdx].isAllIn)){
                         currentHandActivePlayerIdsOrder.push(players[startIdx].id);
                     }
                 }
                 currentHandActivePlayerIdsOrder = currentHandActivePlayerIdsOrder.slice(0, tempActivePlayersForOrder.length);
            }


            const numActiveForPosDetermination = currentHandActivePlayerIdsOrder.length;
            players.forEach(p => {
                if (!p.isFolded && (p.chips > 0 || p.isAllIn) ) {
                     // Pass currentHandActivePlayerIdsOrder to getPlayerPositionCategory
                    p.positionCategory = getPlayerPositionCategory(p, currentDealerPlayerId, numActiveForPosDetermination, currentHandActivePlayerIdsOrder);
                } else {
                    p.positionCategory = "Folded/Out";
                }
            });

            // Assign SB and BB based on the generated order
            let sbPlayer = null, bbPlayer = null;
            if (currentHandActivePlayerIdsOrder.length >= 1) {
                sbPlayer = players.find(p => p.id === currentHandActivePlayerIdsOrder[0]);
                if (sbPlayer) sbPlayer.isSB = true;
            }
            if (currentHandActivePlayerIdsOrder.length >= 2) {
                bbPlayer = players.find(p => p.id === currentHandActivePlayerIdsOrder[1]);
                if (bbPlayer) bbPlayer.isBB = true;
            }
             // Special case for 2 players: SB is dealer
            if (numActiveForPosDetermination === 2) {
                players[dealerIndex].isSB = true; // Dealer is SB
                sbPlayer = players[dealerIndex];
                const otherPlayerId = currentHandActivePlayerIdsOrder.find(id => id !== sbPlayer.id);
                bbPlayer = players.find(p=>p.id === otherPlayerId);
                if (bbPlayer) bbPlayer.isBB = true;
                 // Ensure currentHandActivePlayerIdsOrder reflects SB then BB
                currentHandActivePlayerIdsOrder = [sbPlayer.id, bbPlayer.id];
            }


            if (sbPlayer) {
                const sbAmountToPost = Math.min(SMALL_BLIND_AMOUNT, sbPlayer.chips); 
                sbPlayer.chips -= sbAmountToPost; sbPlayer.betInRound = sbAmountToPost; pot += sbAmountToPost;
                displayMessage(`${sbPlayer.name} (SB) ${Math.floor(sbAmountToPost)}원 자동 베팅.`, sbPlayer.type === "human" ? "player-action" : "ai-action");
                if (sbPlayer.chips === 0 && sbAmountToPost > 0) sbPlayer.isAllIn = true; 
            }
            if (bbPlayer) {
                const bbAmountToPost = Math.min(BIG_BLIND_AMOUNT, bbPlayer.chips); 
                bbPlayer.chips -= bbAmountToPost; bbPlayer.betInRound = bbAmountToPost; pot += bbAmountToPost;
                displayMessage(`${bbPlayer.name} (BB) ${Math.floor(bbAmountToPost)}원 자동 베팅.`, bbPlayer.type === "human" ? "player-action" : "ai-action");
                if (bbPlayer.chips === 0 && bbAmountToPost > 0) bbPlayer.isAllIn = true;
            }
            currentBet = BIG_BLIND_AMOUNT;

            // Deal cards in the visual action order
            for (let i = 0; i < 2; i++) { 
                for (const playerIdToDeal of currentHandActivePlayerIdsOrder) {
                    const p = players.find(pl => pl.id === playerIdToDeal);
                    if (p && !p.isFolded) { // Only deal to non-folded players in order
                        const newCard = dealCardFromDeck(p.type === "ai");
                        p.cards.push(newCard);
                        renderPlayerCard(p, newCard, p.type === "ai"); 
                        await sleep(100); 
                    }
                }
            }
            
            gamePhase = "PREFLOP";
            // Determine first player to act preflop
            if (currentHandActivePlayerIdsOrder.length > 0) {
                let firstToActOrderIndex = 0;
                if (numActiveForPosDetermination === 2) { // HU, SB (dealer) acts first
                    firstToActOrderIndex = 0; 
                } else if (numActiveForPosDetermination > 2) { // More than 2 players, player after BB acts first (UTG)
                    firstToActOrderIndex = 2 % currentHandActivePlayerIdsOrder.length;
                }
                
                currentTurnInOrderIndex = firstToActOrderIndex;
                // Skip folded/all-in players to find the actual first to act
                let initialSearchOrderIndex = currentTurnInOrderIndex;
                let foundFirst = false;
                for(let i=0; i<currentHandActivePlayerIdsOrder.length; i++){
                    const pId = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
                    const pObj = players.find(p=>p.id === pId);
                    if(pObj && !pObj.isFolded && !pObj.isAllIn) {
                        foundFirst = true; break;
                    }
                    currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length;
                    if(currentTurnInOrderIndex === initialSearchOrderIndex && i > 0) break; // Full loop
                }

                if(foundFirst){
                    currentPlayerIndex = players.findIndex(p => p.id === currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]);
                } else { currentPlayerIndex = -1; } // No one can act

            } else {
                currentPlayerIndex = -1; // No active players
            }
            
            lastRaiserIndex = bbPlayer ? players.findIndex(p => p.id === bbPlayer.id) : (sbPlayer ? players.findIndex(p => p.id === sbPlayer.id) : -1);

            updateOverallUI();
            const activeNonAllInPlayers = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            if (currentPlayerIndex === -1 || activeNonAllInPlayers.length === 0) { 
                 await advanceGamePhase(); 
            } else if (activeNonAllInPlayers.length === 1 && players[currentPlayerIndex] && players[currentPlayerIndex].isAllIn) { // Only one non-all-in who is already all-in
                await advanceGamePhase();
            }
             else { 
                 await startBettingRound();
            }
        }

        async function startBettingRound() {
            players.forEach(p => { if (!p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
            displayMessage(`--- ${gamePhase} 라운드 시작 ---`, "game-event");
            
            if (gamePhase !== "PREFLOP") { // Postflop: SB acts first
                currentTurnInOrderIndex = 0; // Start with the first player in `currentHandActivePlayerIdsOrder` (SB)
                let initialSearchOrderIndex = currentTurnInOrderIndex;
                let foundFirst = false;
                 for(let i=0; i<currentHandActivePlayerIdsOrder.length; i++){
                    const pId = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
                    const pObj = players.find(p=>p.id === pId);
                    if(pObj && !pObj.isFolded && !pObj.isAllIn && pObj.chips > 0) {
                        foundFirst = true; break;
                    }
                    currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length;
                     if(currentTurnInOrderIndex === initialSearchOrderIndex && i > 0) break; 
                }
                if(foundFirst){
                    currentPlayerIndex = players.findIndex(p => p.id === currentHandActivePlayerIdsOrder[currentTurnInOrderIndex]);
                } else { currentPlayerIndex = -1; }

                players.forEach(p => { 
                    if(!p.isFolded && !p.isAllIn) p.betInRound = 0; 
                });
                currentBet = 0; 
                minRaiseAmount = BIG_BLIND_AMOUNT;
                lastRaiserIndex = -1; 
            }
            
            const activeForBetting = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0);
            const allInPlayersThisRound = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && p.isAllIn);

            if (currentPlayerIndex === -1 || activeForBetting.length === 0 && allInPlayersThisRound.length > 0) {
                 displayMessage("모든 잔여 플레이어가 올인 상태거나 액션할 플레이어 없음. 다음 단계로 진행.", "game-event");
                 await sleep(1000); await advanceGamePhase(); return;
            } else if (activeForBetting.length <=1 ) {
                const nonAllInCanAct = activeForBetting;
                let bettingStillPossible = false;
                if (nonAllInCanAct.length === 1) {
                    const actor = nonAllInCanAct[0];
                    const actorPlayerObj = players[currentPlayerIndex]; // Assuming currentPlayerIndex points to this actor
                    bettingStillPossible = (currentBet > 0 && actor.betInRound < currentBet && actor.chips > 0) || 
                                           (gamePhase === "PREFLOP" && actor.isBB && currentBet === BIG_BLIND_AMOUNT && !actor.hasActedThisBettingRound && lastRaiserIndex === players.findIndex(p=>p.id === actor.id));
                }

                if (!bettingStillPossible) {
                    const isOnlyOnePlayerLeftOverall = players.filter(p => !p.isFolded).length === 1;
                    if(!isOnlyOnePlayerLeftOverall && activeForBetting.length <=1){ 
                        displayMessage("베팅할 플레이어가 한 명 이하. 다음 단계로 진행.", "game-event");
                        await sleep(1000); await advanceGamePhase(); return;
                    }
                }
            }

            updateOverallUI(); 
            await processPlayerTurn();
        }

        async function processPlayerTurn() {
            if (currentPlayerIndex === -1 || currentTurnInOrderIndex === -1) {
                 console.warn("processPlayerTurn: No current player to act. Advancing phase.");
                 await advanceGamePhase(); return;
            }
            
            const currentPlayerIdToAct = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
            const currentPlayerObject = players.find(p => p.id === currentPlayerIdToAct);
            
            if (!currentPlayerObject || currentPlayerObject.isFolded || currentPlayerObject.isAllIn) {
                 // This player cannot act, try to switch to next
                 console.warn(`processPlayerTurn: Player ${currentPlayerIdToAct} cannot act. Switching.`);
                 await switchToNextPlayerOrEndRound();
                 return;
            }
            currentPlayerIndex = players.findIndex(p => p.id === currentPlayerIdToAct); // Ensure currentPlayerIndex is correct

            displayMessage(`${currentPlayerObject.name}의 턴. (포지션: ${currentPlayerObject.positionCategory}) 현재 베팅액: ${Math.floor(currentBet)}원`, "system-message");
            updateOverallUI(); 

            if (currentPlayerObject.type === "human") {
                updateActionButtonsForHuman(); 
            } else { 
                await sleep(800 + Math.random() * 1000); 
                await handleAIAction(currentPlayerObject);
            }
        }
        
        async function handleHumanAction(actionType) {
            const humanPlayer = players[currentPlayerIndex]; // currentPlayerIndex should be correct from processPlayerTurn
            if (!humanPlayer || humanPlayer.type !== "human" || humanPlayer.isFolded || humanPlayer.isAllIn) {
                console.warn("Human action attempted but player cannot act or not human's turn. Switching turn.");
                await switchToNextPlayerOrEndRound();
                return;
            }
            
            humanPlayer.hasActedThisBettingRound = true;
            humanPlayer.previousAction = actionType; 
            let actualBetMadeThisAction = 0;
            let actionText = "";

            switch (actionType) {
                case 'FOLD':
                    humanPlayer.isFolded = true;
                    actionText = "폴드";
                    displayMessage(`${humanPlayer.name} ${actionText}.`, "player-action");
                    break;
                case 'CHECK_CALL':
                    const amountToCall = currentBet - humanPlayer.betInRound;
                    if (amountToCall > 0) { 
                        actualBetMadeThisAction = Math.min(amountToCall, humanPlayer.chips);
                        humanPlayer.chips -= actualBetMadeThisAction;
                        humanPlayer.betInRound += actualBetMadeThisAction;
                        pot += actualBetMadeThisAction;
                        actionText = `콜 (${Math.floor(actualBetMadeThisAction)}원)`;
                        displayMessage(`${humanPlayer.name} ${Math.floor(actualBetMadeThisAction)}원 콜 (총 ${Math.floor(humanPlayer.betInRound)}원).`, "player-action");
                        if (humanPlayer.chips === 0 && actualBetMadeThisAction > 0) humanPlayer.isAllIn = true;
                    } else { 
                        actionText = "체크";
                        displayMessage(`${humanPlayer.name} ${actionText}.`, "player-action");
                    }
                    break;
                case 'BET_RAISE':
                    let desiredTotalBet = parseInt(raiseInput.value);
                    if (isNaN(desiredTotalBet) || desiredTotalBet < 0) { displayMessage("유효한 금액 입력.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return; }

                    if (desiredTotalBet > humanPlayer.chips + humanPlayer.betInRound) desiredTotalBet = humanPlayer.chips + humanPlayer.betInRound;
                    
                    actualBetMadeThisAction = desiredTotalBet - humanPlayer.betInRound;
                    if (actualBetMadeThisAction < 0) { displayMessage("잘못된 베팅 금액.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return; }

                    if (currentBet === 0) { 
                        if (desiredTotalBet < minRaiseAmount && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) {
                            displayMessage(`최소 벳: ${Math.floor(minRaiseAmount)}원.`, "system-message"); humanPlayer.hasActedThisBettingRound = false; return;
                        }
                        actionText = `벳 (${Math.floor(actualBetMadeThisAction)}원)`;
                    } else { 
                        if (desiredTotalBet < currentBet + minRaiseAmount && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) {
                             displayMessage(`최소 레이즈 총액: ${Math.floor(currentBet + minRaiseAmount)}원.`, "system-message"); humanPlayer.hasActedThisBettingRound = false; return;
                        }
                         if (desiredTotalBet <= currentBet && desiredTotalBet < humanPlayer.chips + humanPlayer.betInRound) {
                             displayMessage("레이즈는 현재 베팅보다 커야 함.", "system-message"); humanPlayer.hasActedThisBettingRound = false; return;
                         }
                        actionText = `레이즈 (${Math.floor(actualBetMadeThisAction)}원)`;
                    }
                    
                    humanPlayer.chips -= actualBetMadeThisAction;
                    humanPlayer.betInRound += actualBetMadeThisAction;
                    pot += actualBetMadeThisAction;
                    displayMessage(`${humanPlayer.name} ${Math.floor(actualBetMadeThisAction)}원 벳/레이즈 (총 ${Math.floor(humanPlayer.betInRound)}원).`, "player-action");
                    if (humanPlayer.chips === 0 && actualBetMadeThisAction > 0) humanPlayer.isAllIn = true;
                    
                    if (humanPlayer.betInRound > currentBet) { 
                        minRaiseAmount = humanPlayer.betInRound - currentBet; 
                        currentBet = humanPlayer.betInRound; 
                        lastRaiserIndex = humanPlayer.id; // Store player ID now
                        players.forEach(p => { if (p.id !== humanPlayer.id && !p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
                    }
                    break;
            }
            if (actionText) showPlayerActionFeedback(humanPlayer.id, actionText);
            updateOverallUI();
            await switchToNextPlayerOrEndRound(); 
        }

        async function handleAIAction(aiPlayer) { // aiPlayer is the actual player object
            if (aiPlayer.isFolded || aiPlayer.isAllIn) {
                 await switchToNextPlayerOrEndRound(); return;
            }
            showAIActionEffect();
            aiPlayer.hasActedThisBettingRound = true;

            let amountToCall = currentBet - aiPlayer.betInRound;
            let decisionType = "FOLD"; 
            let aiActionAmount = 0; 
            let isBluffing = false; 
            let actionText = "";

            const holeCardStrength = evaluateHoleCards(aiPlayer.cards);
            const combinedHand = [...aiPlayer.cards, ...communityCards];
            const currentMadeHandDetails = getHandDetails(combinedHand);
            const drawPotential = evaluateDrawPotential(communityCards, aiPlayer.cards); 
            const boardInfo = analyzeBoardTexture(communityCards);
            let effectiveHandStrength = currentMadeHandDetails.strength / 9; 
            if (drawPotential.outs > 0) effectiveHandStrength += drawPotential.outs * 0.02 + Math.random() * 0.03; 

            const activeOpponents = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && p.id !== aiPlayer.id && !p.isFolded && !p.isAllIn && p.chips > 0);
            
            const aggressionMod = aiPlayer.aggressionFactor;
            const tightnessMod = aiPlayer.tightnessFactor;

            // --- PREFLOP AI LOGIC (largely same, ensure references are to player objects) ---
            if (gamePhase === "PREFLOP") {
                let openRaiseMultiplier = 2.3 + (1.2 / tightnessMod) + (aggressionMod - 0.8);
                if (aiPlayer.positionCategory === "Early" || aiPlayer.positionCategory === "UTG" || aiPlayer.positionCategory === "SB_Dealer") openRaiseMultiplier = Math.max(2.7, openRaiseMultiplier * 1.1);
                let openRaiseSize = Math.floor(BIG_BLIND_AMOUNT * openRaiseMultiplier);

                let callThreshold = 0.42 * tightnessMod;
                let raiseThreshold = 0.58 * tightnessMod * aggressionMod;
                if (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer") { callThreshold *= 0.88; raiseThreshold *= 0.92; }
                
                const isFoldedToSBvsBB = aiPlayer.isSB && currentBet === BIG_BLIND_AMOUNT && 
                                       activeOpponents.length === 1 && activeOpponents[0].isBB;

                if (amountToCall === 0) { 
                    if (isFoldedToSBvsBB) {
                        let sbStealRaiseThreshold = 0.45 / tightnessMod * aggressionMod; 
                        let sbCompleteCallThreshold = 0.20 / tightnessMod; 
                        if (holeCardStrength > sbStealRaiseThreshold || (holeCardStrength > 0.33 && Math.random() < 0.35 * aggressionMod)) {
                            decisionType = "BET_RAISE";
                            aiActionAmount = Math.floor(BIG_BLIND_AMOUNT * (2.2 + aggressionMod * 0.8 + Math.random()*0.5)); 
                        } else if (holeCardStrength > sbCompleteCallThreshold && ( (aiPlayer.cards[0].suit === aiPlayer.cards[1].suit) || Math.abs(aiPlayer.cards[0].value - aiPlayer.cards[1].value) <= 4) ) {
                            decisionType = "CHECK_CALL";
                            aiActionAmount = BIG_BLIND_AMOUNT - aiPlayer.betInRound; 
                            if (aiActionAmount < 0) aiActionAmount = 0;
                        } else { decisionType = "FOLD"; }
                    } else if (aiPlayer.isBB && currentBet === BIG_BLIND_AMOUNT && !players.some(p => p.id !== aiPlayer.id && p.betInRound > BIG_BLIND_AMOUNT && p.hasActedThisBettingRound && currentHandActivePlayerIdsOrder.indexOf(p.id) < currentHandActivePlayerIdsOrder.indexOf(aiPlayer.id) ) ) { // BB can check option if no raise before them
                        decisionType = "CHECK_CALL"; aiActionAmount = 0; 
                    } else if (holeCardStrength > raiseThreshold) { 
                        decisionType = "BET_RAISE"; aiActionAmount = openRaiseSize; 
                    } else if (holeCardStrength > (callThreshold * 0.75) && !aiPlayer.isSB && (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer") && Math.random() < (0.25 / tightnessMod) ) {
                        decisionType = "CHECK_CALL"; aiActionAmount = BIG_BLIND_AMOUNT - aiPlayer.betInRound;
                        if(aiActionAmount < 0) aiActionAmount = 0;
                    } else { decisionType = "FOLD"; }
                } else { 
                    const potOdds = calculatePotOdds(amountToCall, pot + currentBet); 
                    let threeBetThreshold = (0.72 / tightnessMod) * aggressionMod;
                    let threeBetTargetAdditional = Math.floor((currentBet * (1.8 + aggressionMod * 0.6)) + pot * 0.1); 

                    if (currentBet >= aiPlayer.chips + aiPlayer.betInRound) { 
                        decisionType = (holeCardStrength > (callThreshold * 0.80 / tightnessMod) ) ? "CHECK_CALL" : "FOLD";
                        if (decisionType === "CHECK_CALL") aiActionAmount = amountToCall;
                    } else if (holeCardStrength > threeBetThreshold && amountToCall < aiPlayer.chips / 2.5) {
                        decisionType = "BET_RAISE"; aiActionAmount = threeBetTargetAdditional;
                    } else if (holeCardStrength > callThreshold || (holeCardStrength > 0.22 && potOdds < 0.42 && activeOpponents.length <= 1) || (aiPlayer.isBB && potOdds < 0.48 && holeCardStrength > 0.18)) {
                        decisionType = "CHECK_CALL"; aiActionAmount = amountToCall;
                    } else { 
                        const bluff3BetChance = 0.12 * aggressionMod; 
                        const lastRaiserPlayerObj = players.find(p => p.id === lastRaiserIndex); // lastRaiserIndex is ID now
                        if (lastRaiserPlayerObj && (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer" || aiPlayer.isBB) && 
                            (lastRaiserPlayerObj.positionCategory.includes("Early") || lastRaiserPlayerObj.positionCategory === "UTG" || lastRaiserPlayerObj.positionCategory.includes("Middle")) &&
                            Math.random() < bluff3BetChance && amountToCall < aiPlayer.chips / 2.8) {
                            decisionType = "BET_RAISE";
                            aiActionAmount = Math.floor(threeBetTargetAdditional * (0.85 + Math.random() * 0.2)); isBluffing = true;
                        } else { decisionType = "FOLD"; }
                    }
                }
            } 
            // --- POSTFLOP AI LOGIC (largely same, ensure references are to player objects) ---
            else { 
                let valueBetStrength = 0.52 / tightnessMod;
                let semiBluffStrength = 0.28 / tightnessMod;
                let callStrength = 0.22 / tightnessMod;
                let checkRaiseStrength = 0.65 / tightnessMod * aggressionMod;

                if (gamePhase === "FLOP" && lastRaiserIndex === aiPlayer.id && amountToCall === 0) { 
                    let cbetProb = (0.55 + 0.25 * aggressionMod); 
                    if (boardInfo.type === "dry_uncoordinated") cbetProb = Math.min(0.95, cbetProb * 1.3);
                    else if (boardInfo.isWet) cbetProb *= 0.7;
                    if (activeOpponents.length === 1) { if (boardInfo.highCardValue >= RANK_VALUES.Q && !boardInfo.isWet) cbetProb = Math.min(0.95, cbetProb * 1.15); } 
                    else if (activeOpponents.length > 1) { cbetProb *= (1 / (1 + 0.4 * (activeOpponents.length -1))); }

                    if (effectiveHandStrength > 0.45 || (drawPotential.outs >= 7 && Math.random() < 0.7) || Math.random() < cbetProb) {
                        decisionType = "BET_RAISE"; let cbetSizeRatio = 0.35 + Math.random() * 0.30 * aggressionMod;
                        if (boardInfo.isWet) cbetSizeRatio = Math.min(0.75, cbetSizeRatio * 1.2); 
                        aiActionAmount = Math.floor(pot * cbetSizeRatio);
                        if (effectiveHandStrength < 0.4 && drawPotential.outs < 5 && Math.random() < cbetProb) isBluffing = true; 
                    } else { decisionType = "CHECK_CALL"; } 
                }
                else if (amountToCall === 0 && (gamePhase === "TURN" || gamePhase === "RIVER") &&
                         ( (lastRaiserIndex !== aiPlayer.id && players.find(p=>p.id===lastRaiserIndex)?.previousAction === 'CHECK_CALL' && players.find(p=>p.id===lastRaiserIndex)?.betInRound === 0) || 
                           (lastRaiserIndex === -1 && players.filter(p=>currentHandActivePlayerIdsOrder.includes(p.id)).every(p => p.isFolded || p.isAllIn || (p.hasActedThisBettingRound && p.betInRound === 0) || p.id === aiPlayer.id)) 
                         ) ) { 
                    let probeBetProb = 0.38 * aggressionMod;
                    if(boardInfo.type === "dry_uncoordinated" || (boardInfo.type === "paired" && !boardInfo.isWet) ) probeBetProb = Math.min(0.8, probeBetProb * 1.25);
                    if (effectiveHandStrength > 0.42 || (drawPotential.outs >= 5 && Math.random() < 0.6) || Math.random() < probeBetProb) {
                        decisionType = "BET_RAISE"; aiActionAmount = Math.floor(pot * (0.38 + Math.random() * 0.28 * aggressionMod));
                         if (effectiveHandStrength < 0.38 && drawPotential.outs < 4 && Math.random() < probeBetProb) isBluffing = true;
                    } else { decisionType = "CHECK_CALL"; }
                }
                else if (amountToCall === 0) { 
                    if (effectiveHandStrength > valueBetStrength) { 
                        decisionType = "BET_RAISE"; let valueBetSize = 0.48 + effectiveHandStrength * 0.30 * aggressionMod;
                        if (boardInfo.isWet) valueBetSize = Math.min(0.8, valueBetSize * 1.15);
                        aiActionAmount = Math.floor(pot * valueBetSize);
                    } else if (effectiveHandStrength > semiBluffStrength && (drawPotential.outs >= 5 || Math.random() < (0.33 * aggressionMod))) { 
                        decisionType = "BET_RAISE"; aiActionAmount = Math.floor(pot * (0.30 + Math.random() * 0.3 * aggressionMod));
                        if (effectiveHandStrength < 0.38 && drawPotential.outs < 8) isBluffing = true; 
                    } else { decisionType = "CHECK_CALL"; } 
                } 
                else { 
                    const potOdds = calculatePotOdds(amountToCall, pot + currentBet);
                    if ( (aiPlayer.positionCategory.includes("Early") || aiPlayer.positionCategory === "SB" || aiPlayer.positionCategory === "BB") &&
                         !aiPlayer.hasActedThisBettingRound && 
                         effectiveHandStrength > checkRaiseStrength && amountToCall < pot * 0.75 && Math.random() < 0.18 * aggressionMod && (!boardInfo.isWet || drawPotential.outs > 7)) { 
                        decisionType = "BET_RAISE"; 
                        aiActionAmount = Math.floor(amountToCall * (1.8 + aggressionMod * 0.8) + pot * 0.2); 
                        if(effectiveHandStrength < (checkRaiseStrength * 0.8) && drawPotential.outs < 5) isBluffing = true; 
                    } 
                    else if (currentBet >= aiPlayer.chips + aiPlayer.betInRound) { 
                        decisionType = (effectiveHandStrength > (callStrength * 0.85) + (drawPotential.outs * 0.018)) ? "CHECK_CALL" : "FOLD";
                        if (decisionType === "CHECK_CALL") aiActionAmount = amountToCall;
                    } 
                    else if (effectiveHandStrength > (valueBetStrength * 1.1) && amountToCall < aiPlayer.chips / 1.4) { 
                        decisionType = "BET_RAISE"; aiActionAmount = Math.floor(amountToCall * (1.7 + aggressionMod * 0.75) + pot * 0.22);
                    } 
                    else if (effectiveHandStrength > callStrength || (drawPotential.outs >= 8 && potOdds < 0.48) || (drawPotential.outs >=5 && potOdds < 0.40)) { 
                        decisionType = "CHECK_CALL"; aiActionAmount = amountToCall;
                    } 
                    else if (drawPotential.outs >= 7 && potOdds < (0.35 / tightnessMod) && Math.random() < (0.35 * aggressionMod) && !boardInfo.isPaired && gamePhase !== "RIVER") { 
                        decisionType = "BET_RAISE"; aiActionAmount = Math.floor(amountToCall * (1.6 + aggressionMod * 0.6) + pot * 0.15);
                        isBluffing = true; 
                    } 
                    else { 
                        const spr = aiPlayer.chips > 0 ? pot / aiPlayer.chips : 100;
                        if (spr < 1.5 && effectiveHandStrength > 0.12 && potOdds < 0.65) { 
                            decisionType = "CHECK_CALL"; aiActionAmount = amountToCall;
                        } else { decisionType = "FOLD"; }
                    }
                }
            }

            if (decisionType === "FOLD" || (decisionType === "CHECK_CALL" && amountToCall === 0 && effectiveHandStrength < 0.35)) {
                let currentBluffChance = BLUFF_PROBABILITY_BASE * aggressionMod * (boardInfo.isWet ? 0.8 : 1.25); 
                if (aiPlayer.positionCategory.includes("Late") || aiPlayer.positionCategory === "Dealer" || aiPlayer.positionCategory === "SB_Dealer") currentBluffChance *= 1.4;
                if (gamePhase === "RIVER") {
                    const communitySuitCounts = {}; communityCards.forEach(c => communitySuitCounts[c.suit] = (communitySuitCounts[c.suit] || 0) + 1);
                    const flushPossibleOnBoardCount = Math.max(...Object.values(communitySuitCounts).map(Number), 0);
                    if (flushPossibleOnBoardCount === 4 && currentMadeHandDetails.strength < HAND_STRENGTH.FLUSH) { currentBluffChance *= 1.8; isBluffing = true; } 
                    else if (flushPossibleOnBoardCount === 3 && currentMadeHandDetails.strength < HAND_STRENGTH.FLUSH && drawPotential.type.includes("flush")) { currentBluffChance *= 1.6; isBluffing = true; }
                    if (currentMadeHandDetails.strength < HAND_STRENGTH.ONE_PAIR && !boardInfo.isPaired && (boardInfo.type === "dry_uncoordinated" || boardInfo.highCardValue < RANK_VALUES["10"])) { currentBluffChance *= 1.6; }
                }
                if (activeOpponents.every(opp => opp.previousAction === 'CHECK_CALL' && opp.betInRound === 0 && opp.chips > 0)) { currentBluffChance *= 1.75; }
                const lastRaiserPlayerObjForBluff = players.find(p=>p.id === lastRaiserIndex);
                if (lastRaiserPlayerObjForBluff && lastRaiserPlayerObjForBluff.previousAction === "CHECK_CALL" && lastRaiserPlayerObjForBluff.betInRound === 0) { currentBluffChance *= 1.35; }
                if (Math.random() < currentBluffChance && amountToCall < aiPlayer.chips * 0.65) {
                    isBluffing = true; decisionType = "BET_RAISE"; 
                    let bluffSizeRatioBase = (gamePhase === "RIVER") ? 0.60 : 0.50; 
                    let bluffSizeRatio = bluffSizeRatioBase + Math.random() * 0.35 * aggressionMod;
                    aiActionAmount = Math.floor(pot * bluffSizeRatio); 
                }
            }
            
            aiActionAmount = Math.max(0, Math.floor(aiActionAmount)); 
            let actualChipsToCommit = 0; 
            if (decisionType === "BET_RAISE") {
                let intendedAdditionalBet = aiActionAmount; let intendedTotalBetForRound = aiPlayer.betInRound + intendedAdditionalBet;
                if (currentBet === 0) { 
                    if (intendedTotalBetForRound < minRaiseAmount && intendedTotalBetForRound < aiPlayer.chips + aiPlayer.betInRound) {
                        if (aiPlayer.betInRound === 0 && amountToCall === 0) { decisionType = "CHECK_CALL"; actualChipsToCommit = 0; } 
                        else { decisionType = "FOLD"; actualChipsToCommit = 0;}
                    } else { actualChipsToCommit = Math.min(aiPlayer.chips, intendedAdditionalBet); }
                } else { 
                    if (intendedTotalBetForRound < currentBet + minRaiseAmount && intendedTotalBetForRound < aiPlayer.chips + aiPlayer.betInRound) {
                        if (amountToCall <= aiPlayer.chips) { decisionType = "CHECK_CALL"; actualChipsToCommit = amountToCall; } 
                        else { decisionType = "FOLD"; actualChipsToCommit = 0; }
                    } else if (intendedTotalBetForRound === currentBet) { decisionType = "CHECK_CALL"; actualChipsToCommit = amountToCall; } 
                    else { actualChipsToCommit = Math.min(aiPlayer.chips, intendedAdditionalBet); }
                }
            } else if (decisionType === "CHECK_CALL") { actualChipsToCommit = Math.min(aiPlayer.chips, amountToCall); } 
            else { actualChipsToCommit = 0; }
            
            aiPlayer.previousAction = decisionType; actionText = ""; 
            switch (decisionType) {
                case 'FOLD':
                    actionText = "폴드";
                    if (amountToCall > 0 || currentBet > 0 || (aiPlayer.previousAction === "FOLD" && !(amountToCall === 0 && currentBet === 0 && aiPlayer.betInRound === 0 ))) { 
                        aiPlayer.isFolded = true; displayMessage(`${aiPlayer.name} ${actionText}.`, "ai-action");
                    } else { actionText = "체크"; displayMessage(`${aiPlayer.name} ${actionText}.`, "ai-action"); }
                    break;
                case 'CHECK_CALL':
                    if (amountToCall > 0) { actionText = `콜 (${Math.floor(actualChipsToCommit)}원)`; } 
                    else { actionText = "체크"; actualChipsToCommit = 0; }
                    aiPlayer.chips -= actualChipsToCommit; aiPlayer.betInRound += actualChipsToCommit; pot += actualChipsToCommit;
                    displayMessage(`${aiPlayer.name} ${actionText} (총 ${Math.floor(aiPlayer.betInRound)}원).`, "ai-action");
                    if (aiPlayer.chips === 0 && actualChipsToCommit >= 0) aiPlayer.isAllIn = true; 
                    break;
                case 'BET_RAISE':
                    actionText = currentBet === 0 ? `벳 (${Math.floor(actualChipsToCommit)}원)` : `레이즈 (${Math.floor(actualChipsToCommit)}원)`;
                    aiPlayer.chips -= actualChipsToCommit; aiPlayer.betInRound += actualChipsToCommit; pot += actualChipsToCommit;
                    displayMessage(`${aiPlayer.name} ${Math.floor(actualChipsToCommit)}원 ${currentBet === 0 ? '벳' : '레이즈'} (총 ${Math.floor(aiPlayer.betInRound)}원).`, "ai-action");
                    if (aiPlayer.chips === 0 && actualChipsToCommit > 0) aiPlayer.isAllIn = true;
                    if (aiPlayer.betInRound > currentBet) {
                        minRaiseAmount = aiPlayer.betInRound - currentBet; currentBet = aiPlayer.betInRound;
                        lastRaiserIndex = aiPlayer.id; // Store player ID
                        players.forEach(p => { if (p.id !== aiPlayer.id && !p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
                    }
                    break;
            }
            if (actionText && !aiPlayer.isFolded) showPlayerActionFeedback(aiPlayer.id, actionText.split('(')[0].trim()); 
            updateOverallUI();
            await switchToNextPlayerOrEndRound();
        }

        async function switchToNextPlayerOrEndRound() {
            const unfoldedPlayersStillInHand = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded);

            if (unfoldedPlayersStillInHand.length <= 1) {
                if (unfoldedPlayersStillInHand.length === 1) {
                    const winner = unfoldedPlayersStillInHand[0];
                    displayMessage(`${winner.name} 승리! 다른 플레이어 폴드. (팟: ${Math.floor(pot)}원)`, "game-event");
                    winner.chips += pot; pot = 0;
                } else { displayMessage("모든 플레이어가 폴드했습니다.", "game-event");  }
                await endCurrentHand(false); return;
            }

            let bettingOver = true; 
            const activePlayersWhoCanBet = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn && p.chips > 0); 

            if (activePlayersWhoCanBet.length === 0 && unfoldedPlayersStillInHand.length > 0) { 
                 bettingOver = true; 
            } else if (activePlayersWhoCanBet.length > 0) {
                bettingOver = activePlayersWhoCanBet.every(p => {
                    return p.hasActedThisBettingRound && (p.betInRound === currentBet || p.chips === 0); 
                });

                if (bettingOver && gamePhase === "PREFLOP" && currentBet === BIG_BLIND_AMOUNT) {
                    const bbPlayer = players.find(p => p.isBB && currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded && !p.isAllIn);
                    const lastRaiserPlayer = players.find(p=>p.id === lastRaiserIndex);

                    if (bbPlayer && !bbPlayer.hasActedThisBettingRound && (!lastRaiserPlayer || lastRaiserPlayer.id === bbPlayer.id || players.every(plr => plr.isFolded || plr.isAllIn || plr.betInRound <= BIG_BLIND_AMOUNT || plr.id === bbPlayer.id)) ) {
                         const currentPlayerObjectForBBCheck = players[currentPlayerIndex];
                         if(currentPlayerObjectForBBCheck && currentPlayerObjectForBBCheck.id === bbPlayer.id){
                             bettingOver = false; 
                         }
                    }
                }
            } else { bettingOver = true; }
            

            if (bettingOver) {
                await advanceGamePhase();
            } else {
                let nextPlayerFound = false;
                let initialSearchOrderIndex = currentTurnInOrderIndex;
                for (let i = 0; i < currentHandActivePlayerIdsOrder.length; i++) { 
                    currentTurnInOrderIndex = (currentTurnInOrderIndex + 1) % currentHandActivePlayerIdsOrder.length;
                    const nextPlayerIdToAct = currentHandActivePlayerIdsOrder[currentTurnInOrderIndex];
                    const nextPlayer = players.find(p => p.id === nextPlayerIdToAct);

                    if (nextPlayer && !nextPlayer.isFolded && !nextPlayer.isAllIn && nextPlayer.chips > 0) {
                        if (!nextPlayer.hasActedThisBettingRound || (nextPlayer.betInRound < currentBet && nextPlayer.chips > 0)) {
                             currentPlayerIndex = players.findIndex(p => p.id === nextPlayerIdToAct);
                             nextPlayerFound = true;
                             break;
                        }
                    }
                     if (currentTurnInOrderIndex === initialSearchOrderIndex && i > 0 && !nextPlayerFound) { // Full loop check if stuck
                        console.warn("Full loop in switchToNextPlayer without finding next actor, though bettingOver is false. Advancing.");
                        await advanceGamePhase(); return;
                    }
                }
                if (nextPlayerFound) {
                    await processPlayerTurn();
                } else {
                    console.warn("SwitchToNext: Betting not over logically, but no specific next player found by ID order. CurrentPlayerIndex:", currentPlayerIndex, "CurrentBet:", currentBet);
                    await advanceGamePhase(); 
                }
            }
        }
        
        async function advanceGamePhase() {
            displayMessage(`--- ${gamePhase} 베팅 종료 ---`, "game-event");
            
            const activePlayersForShowdown = players.filter(p => currentHandActivePlayerIdsOrder.includes(p.id) && !p.isFolded);
            const playersCanStillBet = activePlayersForShowdown.filter(p => !p.isAllIn && p.chips > 0);
            const playersAllInThisRound = activePlayersForShowdown.filter(p => p.isAllIn);

            let runOutBoard = false;
            if (activePlayersForShowdown.length > 0) { 
                if (playersCanStillBet.length === 0 && playersAllInThisRound.length >= 1) { runOutBoard = true; } 
                else if (playersCanStillBet.length === 1 && playersAllInThisRound.length >= 1) { 
                    const soleBettor = playersCanStillBet[0];
                    let allAllInsCoveredByBettor = true;
                    for (const pAllIn of playersAllInThisRound) {
                        if (soleBettor.betInRound < pAllIn.betInRound && soleBettor.chips > 0) { allAllInsCoveredByBettor = false; break; }
                    }
                    if (allAllInsCoveredByBettor) runOutBoard = true;
                } 
            }

            if ( runOutBoard && gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND") { 
                displayMessage("올인 상황 또는 베팅 가능한 플레이어가 한명 이하. 남은 카드 공개.", "game-event");
                await revealAllAICards(); 
                if (gamePhase === "PREFLOP") { await dealCommunityCardsForPhase("FLOP"); gamePhase = "FLOP"; }
                if (gamePhase === "FLOP" && communityCards.length < 4) { await dealCommunityCardsForPhase("TURN"); gamePhase = "TURN"; } 
                if (gamePhase === "TURN" && communityCards.length < 5) { await dealCommunityCardsForPhase("RIVER"); gamePhase = "RIVER"; }
                gamePhase = "SHOWDOWN"; 
            }

            if (gamePhase !== "SHOWDOWN" && gamePhase !== "END_HAND") {
                switch (gamePhase) {
                    case "PREFLOP": gamePhase = "FLOP"; await dealCommunityCardsForPhase("FLOP"); break;
                    case "FLOP": gamePhase = "TURN"; await dealCommunityCardsForPhase("TURN"); break;
                    case "TURN": gamePhase = "RIVER"; await dealCommunityCardsForPhase("RIVER"); break;
                    case "RIVER": gamePhase = "SHOWDOWN"; break; 
                }
            }
            
            updateOverallUI();

            if (gamePhase === "SHOWDOWN") {
                await determineWinner();
            } else if (gamePhase !== "END_HAND") {
                players.forEach(p => { if(!p.isFolded && !p.isAllIn) p.hasActedThisBettingRound = false; });
                await startBettingRound();
            }
        }

        async function dealCommunityCardsForPhase(phaseToDeal) {
            displayMessage(`--- ${phaseToDeal} 카드 공개 ---`, "game-event");
            burnCard();
            if (phaseToDeal === "FLOP") {
                if (communityCards.length < 3) for (let i=0; i<3; i++) await dealAnimatedCommunityCard(dealCardFromDeck(false));
            } else if (phaseToDeal === "TURN") {
                if (communityCards.length < 4) await dealAnimatedCommunityCard(dealCardFromDeck(false));
            } else if (phaseToDeal === "RIVER") {
                 if (communityCards.length < 5) await dealAnimatedCommunityCard(dealCardFromDeck(false));
            }
            await sleep(500); 
        }
        
        async function revealAllAICards() {
            for (const p of players) {
                if (p.type === 'ai' && !p.isFolded) {
                    for (const card of p.cards) {
                        if (card.hidden) { revealHiddenCard(p, card); await sleep(200); }
                    }
                }
            }
            await sleep(400);
        }

        async function endCurrentHand(showdownOccurred) { 
            gamePhase = "END_HAND"; updateOverallUI(); 
            const activePlayersWithChips = players.filter(p => p.chips > 0);
            const controlBtnArea = document.getElementById('control-buttons-area'); 

            if (activePlayersWithChips.length <= 1) { 
                const winner = activePlayersWithChips.length > 0 ? activePlayersWithChips[0] : (players.length > 0 ? players.find(p => p.isAllIn && !p.isFolded) : null); 
                displayMessage(winner ? `${winner.name} 최종 승리!` : "게임 종료 - 최종 승자 없음", "game-event");
                controlBtnArea.innerHTML = `<button id="start-game-button-main">새 게임</button><button id="continue-game-button">이어하기</button>`;
                document.getElementById('start-game-button-main').addEventListener('click', initializeNewGame);
                document.getElementById('continue-game-button').addEventListener('click', () => {
                    if (players.length === 0 || players.filter(p=>p.chips > 0).length <=1) { initializeNewGame(); } 
                    else { actualNumPlayersInCurrentGame = players.length; players.forEach(p => { if(p.chips > 0) p.isFolded = false; }); startNewHand(); }
                });
                numPlayersSelect.disabled = false; 
            } else { 
                 controlBtnArea.innerHTML = `<button id="next-hand-button">다음 핸드</button><button id="start-game-button-main" style="margin-left: 10px;">새 게임</button>`; 
                const nextHandBtn = document.getElementById('next-hand-button'); if(nextHandBtn) nextHandBtn.addEventListener('click', startNewHand);
                const newGameBtnInMid = document.getElementById('start-game-button-main'); if(newGameBtnInMid) newGameBtnInMid.addEventListener('click', initializeNewGame);
                numPlayersSelect.disabled = true; 
            }
            checkCallButton.disabled = true; betRaiseButton.disabled = true; raiseInput.disabled = true; foldButton.disabled = true;
        }
        
        function evaluateHoleCards(holeCards) { 
            if (!holeCards || holeCards.length < 2) return 0;
            const [c1, c2] = holeCards; let score = (c1.value + c2.value) / 28; 
            if (c1.rank === c2.rank) score += 0.35; if (c1.suit === c2.suit) score += 0.15; 
            if (Math.abs(c1.value - c2.value) === 1 || (c1.value === RANK_VALUES.A && c2.value === RANK_VALUES["2"]) || (c2.value === RANK_VALUES.A && c1.value === RANK_VALUES["2"]) || (Math.abs(c1.value - c2.value) === 12 && (c1.value === RANK_VALUES.A || c2.value === RANK_VALUES.A))) { score += 0.1; }
            if (Math.abs(c1.value - c2.value) <= 4 && Math.abs(c1.value - c2.value) > 1) score += 0.05; 
            return Math.min(1, score);
        }
        function evaluateDrawPotential(allCommunityCards, holeCards) { 
            let outs = 0; let drawType = "none";
            const revealedCommunityCards = allCommunityCards.filter(c => c.revealed !== false); 
            const combinedCardsForDraw = [...holeCards, ...revealedCommunityCards]; 
            if (combinedCardsForDraw.length < 4 || !holeCards || holeCards.length < 2) return { outs: 0, type: "none", hasFlushDraw: false, hasStraightDraw: false };
            let hasFlushDraw = false; let hasStraightDraw = false; const suitCounts = {};
            combinedCardsForDraw.forEach(c => suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1);
            for (const suit in suitCounts) {
                if (suitCounts[suit] === 4 && (holeCards[0].suit === suit || holeCards[1].suit === suit)) {
                    outs += (13 - 4); drawType = drawType === "none" ? "flush" : "combo"; hasFlushDraw = true; break; 
                }
            }
            const uniqueRanks = [...new Set(combinedCardsForDraw.map(c => c.value))].sort((a, b) => a - b);
            if (uniqueRanks.length >= 3) {
                 for (let i = 0; i <= uniqueRanks.length - 4; i++) { 
                    const sub = uniqueRanks.slice(i, i + 4); 
                    if (sub[3] - sub[0] === 3) { 
                        const usesHoleCard = sub.some(r => holeCards.some(hc => hc.value === r));
                        if(usesHoleCard){
                            let tempOuts = 8; if (sub[0] === RANK_VALUES["2"]) tempOuts = 4; if (sub[3] === RANK_VALUES.A) tempOuts = 4; 
                            if (drawType === "flush" || drawType === "combo") tempOuts = Math.max(1, tempOuts - 2); outs += tempOuts;
                            drawType = (drawType === "flush" || drawType === "combo_straight_gutshot") ? "combo_OESD_flush" : (drawType === "none" ? "straight_OESD" : "combo_OESD");
                            hasStraightDraw = true; break; 
                        }
                    }
                }
                if (!hasStraightDraw && uniqueRanks.length >= 4) { 
                    for (let i = 0; i <= uniqueRanks.length - 4; i++) {
                        const sub = uniqueRanks.slice(i, i + 4); const usesHoleCard = sub.some(r => holeCards.some(hc => hc.value === r)); if(!usesHoleCard) continue;
                        if ((sub[3] - sub[0] === 4 && ( (sub[1]-sub[0] > 1 && sub[2]-sub[1]===1 && sub[3]-sub[2]===1) || (sub[1]-sub[0] ===1 && sub[2]-sub[1]>1 && sub[3]-sub[2]===1) || (sub[1]-sub[0] ===1 && sub[2]-sub[1]===1 && sub[3]-sub[2]>1) ))) {
                            let tempOuts = 4; if (drawType === "flush" || drawType === "combo_OESD_flush") tempOuts = Math.max(1, tempOuts - 1);
                            outs += tempOuts; drawType = (drawType === "flush" || drawType === "combo_OESD_flush") ? "combo_gutshot_flush" : (drawType === "none" ? "straight_gutshot" : "combo_gutshot");
                            hasStraightDraw = true; break;
                        }
                    }
                }
                const hasAce = uniqueRanks.includes(RANK_VALUES.A); const has2 = uniqueRanks.includes(RANK_VALUES["2"]); const has3 = uniqueRanks.includes(RANK_VALUES["3"]); const has4 = uniqueRanks.includes(RANK_VALUES["4"]); const has5 = uniqueRanks.includes(RANK_VALUES["5"]);
                if (hasAce && has2 && has3 && has4 && !has5 && (holeCards.some(hc=>[RANK_VALUES.A,2,3,4].includes(hc.value))) && !isStraightFiveHigh(uniqueRanks) && !hasStraightDraw) { outs +=4; drawType= drawType.includes("flush") ? "combo_gutshot_flush" : "straight_gutshot"; hasStraightDraw = true; }
                else if (has2 && has3 && has4 && has5 && !hasAce && (holeCards.some(hc=>[2,3,4,5].includes(hc.value))) && !isStraightFiveHigh(uniqueRanks) && !hasStraightDraw) { outs +=4; drawType= drawType.includes("flush") ? "combo_gutshot_flush" : "straight_gutshot"; hasStraightDraw = true; }
            }
            function isStraightFiveHigh(ranksArray) { return ranksArray.includes(RANK_VALUES.A)&&ranksArray.includes(RANK_VALUES["2"])&&ranksArray.includes(RANK_VALUES["3"])&&ranksArray.includes(RANK_VALUES["4"])&&ranksArray.includes(RANK_VALUES["5"]); }
            return { outs: Math.min(outs, 17), type: drawType, hasFlushDraw, hasStraightDraw }; 
        }

        function getCombinations(arr, k) { 
            if (k === 0) return [[]]; if (!arr || arr.length < k) return []; if (arr.length === k) return [arr]; if (k === 1) return arr.map(e => [e]);
            const first = arr[0]; const woFirst = getCombinations(arr.slice(1), k - 1);
            const wFirst = woFirst.map(c => [first, ...c]); const fRest = getCombinations(arr.slice(1), k); return [...wFirst, ...fRest];
        }
        
        function getHandDetails(sevenCards) { 
            if (!sevenCards || sevenCards.length < 5) { return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: [0], handName: "카드 부족", bestHand: [] };}
            const all5CardCombinations = getCombinations(sevenCards, 5);
            if (!all5CardCombinations || all5CardCombinations.length === 0) { return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: [0], handName: "조합 생성 실패", bestHand: [] };}
            let bestHandFound = { strength: -1, rankValues: [0], handName: "N/A", bestHand: [] };
            for (const fiveCardArr of all5CardCombinations) {
                const currentEval = evaluateSingleHand(fiveCardArr);
                if (currentEval.strength > bestHandFound.strength) { bestHandFound = currentEval; } 
                else if (currentEval.strength === bestHandFound.strength) {
                    for (let i = 0; i < currentEval.rankValues.length; i++) {
                        if (currentEval.rankValues[i] > bestHandFound.rankValues[i]) { bestHandFound = currentEval; break; }
                        if (currentEval.rankValues[i] < bestHandFound.rankValues[i]) { break; }
                    }
                }
            }
            return bestHandFound;
        }
        
        function evaluateSingleHand(fiveCards) { 
            const ranks = fiveCards.map(c => c.value).sort((a, b) => b - a); const suits = fiveCards.map(c => c.suit);
            const isFlush = suits.every(s => s === suits[0]); const rankCounts = {}; ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
            let isStraight = false; const uniqueRanksForStraight = [...new Set(ranks)].sort((a,b) => b-a); 
            if (uniqueRanksForStraight.length === 5 && uniqueRanksForStraight[0] - uniqueRanksForStraight[4] === 4) { isStraight = true; }
            let aceLowStraightRanks = null; 
            if (uniqueRanksForStraight.length === 5 && uniqueRanksForStraight[0] === RANK_VALUES.A && uniqueRanksForStraight[1] === RANK_VALUES["5"] && uniqueRanksForStraight[2] === RANK_VALUES["4"] && uniqueRanksForStraight[3] === RANK_VALUES["3"] && uniqueRanksForStraight[4] === RANK_VALUES["2"]) {
                isStraight = true; aceLowStraightRanks = [RANK_VALUES["5"], RANK_VALUES["4"], RANK_VALUES["3"], RANK_VALUES["2"], RANK_VALUES.A_LOW]; 
            }
            const finalRanksForComparison = aceLowStraightRanks ? aceLowStraightRanks : ranks.slice(0,5);
            if (isStraight && isFlush) {
                const isRoyalCandidate = ranks[0] === RANK_VALUES.A && ranks[1] === RANK_VALUES.K && ranks[2] === RANK_VALUES.Q && ranks[3] === RANK_VALUES.J && ranks[4] === RANK_VALUES["10"]; 
                if (isRoyalCandidate) { return { strength: HAND_STRENGTH.ROYAL_FLUSH, rankValues: ranks.slice(0,5), handName: "로열 플러쉬", bestHand: fiveCards }; }
                return { strength: HAND_STRENGTH.STRAIGHT_FLUSH, rankValues: finalRanksForComparison, handName: "스트레이트 플러쉬", bestHand: fiveCards };
            }
            const counts = Object.values(rankCounts);
            if (counts.includes(4)) { const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4)); const kicker = ranks.find(r => r !== quadRank); return { strength: HAND_STRENGTH.FOUR_OF_A_KIND, rankValues: [quadRank, kicker].filter(v => v !== undefined), handName: "포카드", bestHand: fiveCards };}
            if (counts.includes(3) && counts.includes(2)) { const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3)); const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2)); return { strength: HAND_STRENGTH.FULL_HOUSE, rankValues: [tripRank, pairRank].sort((a,b)=>b-a), handName: "풀하우스", bestHand: fiveCards };}
            if (isFlush) { return { strength: HAND_STRENGTH.FLUSH, rankValues: ranks.slice(0,5), handName: "플러쉬", bestHand: fiveCards };}
            if (isStraight) { return { strength: HAND_STRENGTH.STRAIGHT, rankValues: finalRanksForComparison, handName: "스트레이트", bestHand: fiveCards };}
            if (counts.includes(3)) { const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3)); const kickers = ranks.filter(r => r !== tripRank).sort((a,b) => b-a).slice(0,2); return { strength: HAND_STRENGTH.THREE_OF_A_KIND, rankValues: [tripRank, ...kickers], handName: "쓰리 오브 어 카인드", bestHand: fiveCards };}
            const numPairs = counts.filter(c => c === 2).length;
            if (numPairs === 2) { const pairRanksVal = []; for (const r in rankCounts) { if (rankCounts[r] === 2) pairRanksVal.push(parseInt(r)); } pairRanksVal.sort((a,b) => b-a); const kicker = ranks.find(r => !pairRanksVal.includes(r)); return { strength: HAND_STRENGTH.TWO_PAIR, rankValues: [...pairRanksVal, kicker].filter(v => v !== undefined), handName: "투 페어", bestHand: fiveCards };}
            if (numPairs === 1) { const pairRankVal = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2)); const kickers = ranks.filter(r => r !== pairRankVal).sort((a,b) => b-a).slice(0,3); return { strength: HAND_STRENGTH.ONE_PAIR, rankValues: [pairRankVal, ...kickers], handName: "원 페어", bestHand: fiveCards };}
            return { strength: HAND_STRENGTH.HIGH_CARD, rankValues: ranks.slice(0,5), handName: "하이 카드", bestHand: fiveCards };
        }

        async function determineWinner() {
            displayMessage("--- 쇼다운 ---", "game-event"); await revealAllAICards();
            let eligiblePlayers = players.filter(p => !p.isFolded && currentHandActivePlayerIdsOrder.includes(p.id)); // Only consider players in the hand
            if (eligiblePlayers.length === 0) { displayMessage("쇼다운 할 플레이어가 없습니다.", "game-event"); await endCurrentHand(true); return; }
            eligiblePlayers.forEach(p => { p.handDetails = getHandDetails([...p.cards, ...communityCards]); displayMessage(`${p.name}: ${p.handDetails.handName} (${p.handDetails.bestHand.map(c=>c.rank+c.suit).join(',')})`, "system-message"); });
            eligiblePlayers.sort((a, b) => { if (b.handDetails.strength !== a.handDetails.strength) return b.handDetails.strength - a.handDetails.strength; for (let i = 0; i < a.handDetails.rankValues.length; i++) { if (b.handDetails.rankValues[i] !== a.handDetails.rankValues[i]) return b.handDetails.rankValues[i] - a.handDetails.rankValues[i]; } return 0; });
            const winners = eligiblePlayers.filter(p => p.handDetails.strength === eligiblePlayers[0].handDetails.strength && p.handDetails.rankValues.every((val, index) => val === eligiblePlayers[0].handDetails.rankValues[index]));
            if (winners.length > 0) { const potPerWinner = Math.floor(pot / winners.length); winners.forEach(winner => { winner.chips += potPerWinner; displayMessage(`${winner.name} 승리! 팟 ${Math.floor(potPerWinner)}원 획득.`, "game-event"); }); pot = pot - (potPerWinner * winners.length); if (pot > 0 && winners.length > 0) winners[0].chips += pot; pot = 0; } 
            else { displayMessage("승자를 결정할 수 없습니다.", "system-message"); }
            updateOverallUI(); await endCurrentHand(true);
        }

        // --- Event Listeners ---
        document.getElementById('start-game-button-main').addEventListener('click', initializeNewGame); 
        checkCallButton.addEventListener('click', () => handleHumanAction('CHECK_CALL'));
        betRaiseButton.addEventListener('click', () => handleHumanAction('BET_RAISE'));
        foldButton.addEventListener('click', () => handleHumanAction('FOLD'));
        pokerHandsInfoBtn.addEventListener('mouseover', () => { pokerHandsGuideDiv.style.display = 'block'; });
        pokerHandsInfoBtn.addEventListener('mouseout', () => { pokerHandsGuideDiv.style.display = 'none'; });
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase(); 
            if (key === KONAMI_CODE[konamiCodePosition].toLowerCase()) {
                konamiCodePosition++;
                if (konamiCodePosition === KONAMI_CODE.length) {
                    isAdminMode = !isAdminMode; displayMessage(`사기꾼 기능 ${isAdminMode ? "활성화" : "비활성화"} 되었습니다!`, "admin-message");
                    konamiCodePosition = 0; if (gamePhase !== "" && gamePhase !== "SETUP") updateOverallUI(); 
                }
            } else { konamiCodePosition = 0; }
        });

        displayMessage("참가 인원을 선택하고 '새 게임'을 누르세요.", "system-message");
        for(let i=0; i<=3; i++) { const slot = getPlayerSlotElement(i); if(slot) slot.style.display = "none"; }

    </script>
</body>
</html>